---
title: 着色器之书02
index_img: 'https://www.aigisss.com/static/images/bg.jpg'
abbrlink: db34898e
categories: 未分类
date: 2020-08-28 19:56:57
tags: 着色器之书
---

# 开始

## 什么是 Fragment Shader(片段着色器)？

在之前的章节我们把 shaders 和古腾堡印刷术相提并论。为什么这样类比呢？更重要的是，什么是 shader？

![From Letter-by-Letter, Right: William Blades, Left: Rolt-Wheeler (1920).](%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E4%B9%A602/print.png)

如果你曾经有用计算机绘图的经验，你就知道在这个过程中你需要画一个圆，然后一个长方形，一条线，一些三角形……直到画出你想要的图像。这个过程很像用手写一封信或一本书 —— 都是一系列的指令，需要你一件一件完成。

Shaders 也是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。也就是说，你的代码必须根据像素在屏幕上的不同位置执行不同的操作。就像活字印刷，你的程序就像一个 function（函数），输入位置信息，输出颜色信息，当它编译完之后会以相当快的速度运行。

![Chinese movable type](%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E4%B9%A602/typepress.jpg)

## 为什么 shaders 运行特别快？

为了回答这个问题，不得不给大家介绍**并行处理**（parallel processing）的神奇之处。

想象你的 CPU 是一个大的工业管道，然后每一个任务都是通过这个管道的某些东西 —— 就像一个生产流水线那样。有些任务要比别的大，也就是说要花费更多时间和精力去处理。我们就称它要求更强的处理能力。由于计算机自身的架构，这些任务需要串行；即一次一个地依序完成。现代计算机通常有一组四个处理器，就像这个管道一样运行，一个接一个地处理这些任务，从而使计算机流畅运行。每个管道通常被称为**线程**。

![CPU](%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E4%B9%A602/00.jpeg)

视频游戏和其他图形应用比起别的程序来说，需要高得多的处理能力。因为它们的图形内容需要操作无数像素。想想看，屏幕上的每一个像素都需要计算，而在 3D 游戏中几何和透视也都需要计算。

让我们回到开始那个关于管道和任务的比喻。屏幕上的每个像素都代表一个最简单的任务。单独来看完成任何一个像素的任务对 CPU 来说都很容易，那么问题来了，屏幕上的每一个像素都需要解决这样的小任务！也就是说，哪怕是对于一个老式的屏幕（分辨率 800x600）来说，都需要每帧处理480000个像素，即每秒进行14400000次计算！是的，这对于微处理器就是大问题了！而对于一个现代的 2800x1800 视网膜屏，每秒运行60帧，就需要每秒进行311040000次计算。图形工程师是如何解决这个问题的？

![](%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E4%B9%A602/03.jpeg)

这个时候，并行处理就是最好的解决方案。比起用三五个强大的微处理器（或者说“管道”）来处理这些信息，用一大堆小的微处理器来并行计算，就要好得多。这就是图形处理器（GPU : Graphic Processor Unit)的来由。

![GPU](%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E4%B9%A602/04.jpeg)

设想一堆小型微处理器排成一个平面的画面，假设每个像素的数据是乒乓球。14400000个乒乓球可以在一秒内阻塞几乎任何管道。但是一面800x600的管道墙，每秒接收30波480000个像素的信息就可以流畅完成。这在更高的分辨率下也是成立的 —— 并行的处理器越多，可以处理的数据流就越大。

另一个 GPU 的魔法是特殊数学函数可通过硬件加速。非常复杂的数学操作可以直接被微芯片解决，而无须通过软件。这就表示可以有更快的三角和矩阵运算 —— 和电流一样快。

## GLSL是什么？

GLSL 代表 openGL Shading Language，openGL 着色语言，这是你在接下来章节看到的程序所遵循的具体标准。根据硬件和操作系统的不同，还有其他的着色器（shaders)。这里我们将依照[Khronos Group](https://www.khronos.org/opengl/)的规则来执行。了解 OpenGL 的历史将有助于你理解大多数奇怪的约定，所以建议不妨阅读[openglbook.com/chapter-0-preface-what-is-opengl.html](http://openglbook.com/chapter-0-preface-what-is-opengl.html)。

## 为什么 Shaders 有名地不好学？

就像蜘蛛侠里的那句名言，能力越大责任越大，并行计算也是如此；GPU 的强大的架构设计也有其限制与不足。

为了能使许多管线并行运行，每一个线程必须与其他的相独立。我们称这些线程对于其他线程在进行的运算是“盲视”的。这个限制就会使得所有数据必须以相同的方向流动。所以就不可能检查其他线程的输出结果，修改输入的数据，或者把一个线程的输出结果输入给另一个线程。如果允许线程到线程的数据流动将使所有的数据面临威胁。

并且 GPU 会让所有并行的微处理器（管道们）一直处在忙碌状态；只要它们一有空闲就会接到新的信息。一个线程不可能知道它前一刻在做什么。它可能是在画操作系统界面上的一个按钮，然后渲染了游戏中的一部分天空，然后显示了一封 email 中的一些文字。每个线程不仅是“盲视”的，而且还是“无记忆”的。同时，它要求编写一个通用的规则，依据像素的不同位置依次输出不同的结果。这种抽象性，和盲视、无记忆的限制使得 shaders 在程序员新手中不是很受欢迎。

但是不要担心！在接下来的章节中，我们会一步一步地，由浅入深地学习着色语言。如果你是在用一个靠谱的浏览器阅读这个教程，你会喜欢边读边玩书中的示例的。好了，不要再浪费时间了，赶快去玩起来吧！ 

## Hello World

“Hello world!”通常都是学习一个新语言的第一个例子。这是一个非常简单，只有一行的程序。它既是一个热情的欢迎，也传达了编程所能带来的可能性。

然而在 GPU 的世界里，第一步就渲染一行文字太难了，所以我们改为选择一个鲜艳的欢迎色，来吧躁起来！

<div class="container" style="background:red;margin:0;padding:0">
    <div class="codeAndCanvas" data="/blog/glsl/hello_world.frag" style="width:100%;height:auto;margin-bottom:10px"></div>
</div>


如果你是在线阅读这本书的话，上面的代码都是可以交互的。你可以点击或者改动代码中任何一部分，尽情探索。多亏 GPU 的架构，shader 会**飞速**地编译和更新，这使得你的改动都会立刻出现在你眼前。试试改动第 6 行的值，看会发生什么。

尽管这几行简单的代码看起来不像有很多内容，我们还是可以据此推测出一些知识点：

1. shader 语言 有一个 `main` 函数，会在最后返回颜色值。这点和 C 语言很像。

2. 最终的像素颜色取决于预设的全局变量 `gl_FragColor`。

3. 这个类 C 语言有内建的**变量**（像`gl_FragColor`），**函数**和**数据类型**。在本例中我们刚刚介绍了`vec4`（四分量浮点向量）。之后我们会见到更多的类型，像 `vec3` （三分量浮点向量）和 `vec2` （二分量浮点向量），还有非常著名的：`float`（单精度浮点型）， `int`（整型） 和 `bool`（布尔型）。

4. 如果我们仔细观察 `vec4` 类型，可以推测这四个变元分别响应红，绿，蓝和透明度通道。同时我们也可以看到这些变量是**规范化**的，意思是它们的值是从 0 到 1 的。之后我们会学习如何规范化变量，使得在变量间**map**（映射）数值更加容易。

5. 另一个可以从本例看出来的很重要的类 C 语言特征是，预处理程序的宏指令。宏指令是预编译的一部分。有了宏才可以 `#define` （定义）全局变量和进行一些基础的条件运算（通过使用 `#ifdef` 和 `#endif`）。所有的宏都以 `#` 开头。预编译会在编译前一刻发生，把所有的命令复制到 `#defines` 里，检查`#ifdef` 条件句是否已被定义， `#ifndef` 条件句是否没有被定义。在我们刚刚的“hello world!”的例子中，我们在第 2 行检查了 `GL_ES` 是否被定义，这个通常用在移动端或浏览器的编译中。

6. `float`类型在 shaders 中非常重要，所以**精度**非常重要。更低的精度会有更快的渲染速度，但是会以质量为代价。你可以选择每一个浮点值的精度。在第一行（`precision mediump float;`）我们就是设定了所有的浮点值都是中等精度。但我们也可以选择把这个值设为“低”（`precision lowp float;`）或者“高”（`precision highp float;`）。

7. 最后可能也是最重要的细节是，GLSL 语言规范并不保证变量会被自动转换类别。这句话是什么意思呢？显卡的硬件制造商各有不同的显卡加速方式，但是却被要求有最精简的语言规范。因而，自动强制类型转换并没有包括在其中。在我们的“hello world!”例子中，`vec4` 精确到单精度浮点，所以应被赋予 `float` 格式。但是如果你想要代码前后一致，不要之后花费大量时间 debug 的话，最好养成在 `float` 型数值里加一个 `.` 的好习惯。如下这种代码就可能不能正常运行：

```glsl
void main() {
	gl_FragColor = vec4(1,0,0,1);	// 出错
}
```

现在我们已经基本讨论完了“hello world!”例子中所有主要的内容，是时候点击代码，检验一下我们所学的知识了。你会发现出错时程序会编译失败，只留一个寂寞的白屏。你可以试试一些好玩的小点子，比如说：

- 把单精度浮点值换成整型数值，猜猜你的显卡能不能容忍这个行为。

- 试试把第六行注释掉，不给函数赋任何像素的值。

- 尝试另外写个函数，返回某个颜色，然后在 `main()` 里面使用这个函数。给个提示，这个函数应该长这样：

```glsl
vec4 red(){
    return vec4(1.0,0.0,0.0,1.0);
}
```

- 有很多种构造 `vec4` 类型的方式，试试看其他方式。下面就是其中一种方式：

```glsl
vec4 color = vec4(vec3(1.0,0.0,1.0),1.0);
```

尽管这个例子看起来不那么刺激，它却是最最基础的 —— 我们把画布上的每一个像素都改成了一个确切的颜色。在接下来的章节中我们将会看到如何用两种输入源来改变像素的颜色：空间（依据像素在屏幕上的位置）和时间（依据页面加载了多少秒）。