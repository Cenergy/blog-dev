<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack学习与总结]]></title>
    <url>%2Fposts%2F6e7939e6.html</url>
    <content type="text"><![CDATA[初识 Webpackwebpack 是模块打包工具，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。历史上先后出现一系列构建工具，它们各有其优缺点。由于前端工程师很熟悉 JavaScript ，Node.js 又可以胜任所有构建需求，所以大多数构建工具都是用 Node.js 开发的。下面来一一介绍它们。Npm ScriptNpm Script 是一个任务执行者。Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 package.json 文件里面使用 scripts 字段定义任务：123456&#123; "scripts": &#123; "dev": "node dev.js", "pub": "node build.js" &#125;&#125;里面的 scripts 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 dev 和 pub。 其底层实现原理是通过调用 Shell 去运行脚本命令，例如执行 npm run pub 命令等同于执行命令 node build.js。Npm Script的优点是内置，无须安装其他依赖。其缺点是功能太简单，虽然提供了 pre 和 post 两个钩子，但不能方便地管理多个任务之间的依赖。GruntGrunt 和 Npm Script 类似，也是一个任务执行者。Grunt 有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 Gruntfile.js 里，例如：1234567891011121314151617181920212223242526module.exports = function(grunt) &#123; // 所有插件的配置信息 grunt.initConfig(&#123; // uglify 插件的配置信息 uglify: &#123; app_task: &#123; files: &#123; 'build/app.min.js': ['lib/index.js', 'lib/test.js'] &#125; &#125; &#125;, // watch 插件的配置信息 watch: &#123; another: &#123; files: ['lib/*.js'], &#125; &#125; &#125;); // 告诉 grunt 我们将使用这些插件 grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); // 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务 grunt.registerTask('dev', ['uglify','watch']);&#125;;在项目根目录下执行命令 grunt dev 就会启动 JavaScript 文件压缩和自动刷新功能。Grunt的优点是：灵活，它只负责执行你定义的任务；大量的可复用插件封装好了常见的构建任务。Grunt的缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。Grunt 相当于进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足。GulpGulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5个方法就可以胜任几乎所有构建场景：通过 gulp.task 注册一个任务；通过 gulp.run 执行任务；通过 gulp.watch 监听文件变化；通过 gulp.src 读取文件；通过 gulp.dest 写文件。Gulp 的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：1234567891011121314151617181920212223242526272829303132// 引入 Gulpvar gulp = require('gulp'); // 引入插件var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');// 编译 SCSS 任务gulp.task('sass', function() &#123; // 读取文件通过管道喂给插件 gulp.src('./scss/*.scss') // SCSS 插件把 scss 文件编译成 CSS 文件 .pipe(sass()) // 输出文件 .pipe(gulp.dest('./css'));&#125;);// 合并压缩 JSgulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;);// 监听文件变化gulp.task('watch', function()&#123; // 当 scss 文件被编辑时执行 SCSS 任务 gulp.watch('./scss/*.scss', ['sass']); gulp.watch('./js/*.js', ['scripts']); &#125;);Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。WebpackWebpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。其官网的首页图很形象的画出了 Webpack 是什么，如下：一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。Webpack 具有很大的灵活性，能配置如何处理文件，大致使用如下：12345678module.exports = &#123; // 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块 entry: './app.js', output: &#123; // 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 filename: 'bundle.js' &#125;&#125;Webpack的优点是：专注于处理模块化的项目，能做到开箱即用一步到位；通过 Plugin 扩展，完整好用又不失灵活；使用场景不仅限于 Web 开发；社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。Webpack的缺点是只能用于采用模块化开发的项目。为什么选择 Webpack上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物，侧面反映出 Web 开发的发展趋势如下：在 Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入，用于简化流程；在 Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想的出现是为了简化文件转换的流程，例如将 ES6 转换成 ES5。在 Webpack 时代由于单页应用的流行，一个网页的功能和实现代码变得庞大，Web 开发向模块化改进。这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务，也可以相互搭配起来弥补各自的不足。 在了解这些常见的构建工具后，你需要根据自己的需求去判断应该如何选择和搭配它们才能更好地完成自己的需求。经过多年的发展， Webpack 已经成为构建工具中的首选，这是有原因的：大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。使用Webpack安装 Webpack 到本项目在开始给项目加入构建前， 在安装 Webpack 前请确保你的系统安装了5.0.0及以上版本的 Node.js。你还需要先新建一个 Web 项目，进入项目根目录执行 npm init 来初始化最简单的采用了模块化开发的项目；要安装 Webpack 到本项目，可按照你的需要选择以下任意命令运行：123456789# npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies# 安装最新稳定版npm i -D webpack# 安装指定版本npm i -D webpack@&lt;version&gt;# 安装最新体验版本npm i -D webpack@beta安装完后你可以通过这些途径运行安装到本项目的 Webpack：在项目根目录下对应的命令行里通过 node_modules/.bin/webpack 运行 Webpack 可执行文件。在 Npm Script 里定义的任务会优先使用本项目下的 Webpack，代码如下：123"scripts": &#123; "start": "webpack --config webpack.config.js"&#125;可以使用npx webpackNode 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。1npm install -g npxnpx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 webpack 而且全局没有安装 webpack。1npm install -D webpack一般来说，调用 webpack，只能在项目脚本和 package.json 的scripts字段里面， 如果想在命令行下调用，必须像下面这样。123# 项目的根目录下执行cd node_modules\.binwebpack --version # 输出 4.41.0npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。12# 项目的根目录下执行npx webpack --versionnpx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装。12&gt; $ npx create-react-app my-react-app&gt;上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。下载全局模块时，npx 允许指定版本。12&gt; $ npx uglify-js@3.1.0 main.js -o ./dist/main.js&gt;上面代码指定使用 3.1.0 版本的uglify-js压缩脚本。注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。12&gt; $ npx http-server&gt;参考：npx 使用教程安装 Webpack 到全局安装到全局后你可以在任何地方共用一个 Webpack 可执行文件，而不用各个项目重复安装，安装方式如下：1npm i -g webpack虽然介绍了以上两种安装方式，但是我们推荐安装到本项目，原因是可防止不同项目依赖不同版本的 Webpack 而导致冲突。### 使用 Webpack默认配置Webpack 在执行构建时默认会从项目根目录下的 webpack.config.js 文件读取配置，所以你还需要新建它，其内容如下：123456789101112const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;&#125;;由于 Webpack 构建运行在 Node.js 环境下，所以该文件最后需要通过 CommonJS 规范导出一个描述如何构建的 Object 对象。使用loaderWebpack 把一切文件看作模块，CSS 文件也不例外，Webpack 不原生支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制。Webpack的配置修改使用如下：123456789101112131415161718192021const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\.css$/, use: ['style-loader', 'css-loader?minimize'], &#125; ] &#125;&#125;;Loader 可以看作具有文件转换功能的翻译员，配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 .css 结尾的文件时先使用 css-loader 读取 CSS 文件，再交给 style-loader 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：use 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 css-loader?minimize 中的 minimize 告诉 css-loader 要开启 CSS 压缩。Webpack 构建前要先安装新引入的 Loader：1npm i -D style-loader css-loader给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入，以上的 Loader 配置可以修改为如下：123456789use: [ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true, &#125; &#125;]除了在 webpack.config.js 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 main.js 如下：1require('style-loader!css-loader?minimize!./main.css');这样就能指定对 ./main.css 这个文件先采用 css-loader 再采用 style-loader 转换。使用 Pluginplugin 可以在 webpack 运行到某一时刻的时候，帮你做一些事情。htmlWepackPluginnn 会在打包结束后，自动生成一个 html 文件，并把打包的生成的 js 自动引入到这个 html 文件中。1234567891011121314151617181920212223const HtmlWebpackPlugin = require("html-webpack-plugin"); //通过 npm 安装const webpack = require("webpack"); //访问内置的插件const path = require("path");const config = &#123; mode: "production", entry: "./src/index.js", output: &#123; filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125;, module: &#123; rules: [ &#123; test: /\.(png|jpg|gif)$/, use: "file-loader" &#125; ] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: "./src/index.html" &#125;)]&#125;;module.exports = config;使用 DevServerDevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。首先需要安装 DevServer：1npm i -D webpack-dev-server安装成功后执行 webpack-dev-server 命令， DevServer 就启动了，这时你会看到控制台有一串日志输出：12Project is running at http://localhost:8080/webpack output is served from /这意味着 DevServer 启动的 HTTP 服务器监听在 http://localhost:8080/ ，DevServer 启动后会一直驻留在后台保持运行，访问这个网址你就能获取项目根目录下的 index.html。 用浏览器打开这个地址你会发现页面空白错误原因是 ./dist/bundle.js 加载404了。 同时你会发现并没有文件输出到 dist 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。 由于 DevServer 不会理会 webpack.config.js 里配置的 output.path 属性，所以要获取 bundle.js的正确 URL 是 http://localhost:8080/bundle.js，对应的 index.html 应该修改为：12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;!--导入 DevServer 输出的 JavaScript 文件--&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Webpack 可以在启动 Webpack 时通过 webpack --watch 来开启监听模式，实时预览。Webpack 支持生成 Source Map，只需在启动时带上 --devtool source-map 参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。DevServer 还有一种被称作模块热替换的刷新技术。 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上 --hot 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。核心概念Webpack 有以下几个核心概念。Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。Loader：模块转换器，用于把模块原内容按照需求转换成新内容。Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。webpack的配置loaderfile-loader就会拷贝到打包文件夹内1234567891011121314151617181920212223module.exports = &#123; mode: "development", entry: &#123; main: "./src/index.js" &#125;, module: &#123; rules: [ &#123; test: /\.jpg$/, use: &#123; loader: "file-loader", options: &#123; name: "[name].[ext]" &#125; &#125; &#125; ] &#125;, output: &#123; filename: "main.js", path: path.resolve(__dirname, "dist") &#125;&#125;;url-loader会变成 base64，在 js 文件中直接加载1234567891011121314151617181920212223242526const path = require("path");module.exports = &#123; mode: "development", entry: &#123; main: "./src/index.js" &#125;, module: &#123; rules: [ &#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: "url-loader", options: &#123; name: "[name].[ext]", outputPath: "images/", limit: 1024 &#125; &#125; &#125; ] &#125;, output: &#123; filename: "main.js", path: path.resolve(__dirname, "dist") &#125;&#125;;css-loader style-loaderWebpack 进阶Webpack 配置及案例Webpack 原理及脚手架]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程总结]]></title>
    <url>%2Fposts%2F9364fbab.html</url>
    <content type="text"><![CDATA[What is Object-oriented ProgrammingOOP是一种编程范例，或者编程风格，这是围绕对象而不是函数面向对象编程中的四个核心概念Encapsulation—封装 Abstraction—抽象 Inheritance—继承 Polymorphism—多态区别与面向过程编程改变了其中一个函数，然后其他几个函数可能就奔溃了，这就是我们说的意大利面条代码。 函数之间深层次的关联变成了各种问题的来源，OOP就应运而生。OOP 就一组相关的变量和函数组成合成一个单元，我们称之为对象(object)。把里面的函数称为方法，里面的变量称之为属性。最好的函数是那些没有参数的函数，参数个数越少，使用和维护就越简单。这就是封装！![1568869634914](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568869634914.png)多态意味着多种形态![1568873343511](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568873343511.png)使用封装重新组合的相关的变量和函数，这样可以减少复杂性，可以在程序的不同部分重用这些对象 或者在不同程序中，通过抽象，隐藏细节和复杂性，只显示必要性，这种技术降低了复杂性，也隔离了代码更改的影响。 继承让我们消除多余的代码 多态性可以避免写出复杂丑陋的选择性代码原型与原型继承原型Prototypes 和 原型继承Prototyical InheritanceJavaScript 中的类并不同于 Java 或者 c#中的类，因为 Javascript 是动态语言，所以类的本质上是更像是为了配合原型和原型继承所采取的必要的技术。1234567891011121314151617181920212223242526//使用字面量创建对象const circle = &#123;&#125;;//一个Javascript的对象实际上是一组键值对的集合//使用字面量语法来创建多个对象是有问题的，那就是对象的行为性，就像人一样可以做很多事就叫做行为性。//解决方法就是用工厂函数（factory）或者构造函数（constructor）//工厂函数function createCircle(radius) &#123; return &#123; radius, draw() &#123; console.log("draw"); &#125; &#125;;&#125;const circle2 = createCircle(1);// 构造函数function Circle(radius) &#123; this.radius = raius; this.draw = function() &#123; console.log("draw"); &#125;;&#125;const circle3 = new Circle(2);//当我们使用new操作符调用一个函数时，3件事发生了//首先new操作符创建了一个空对象，然后设置this指向这个对象，最后返回这个对象补充：字面量是变量的字符串表示形式。它不是一种值，而是一种变量记法。1234const a = 1; //1是字面量const b = "hello world"; //hello world是字面量const c = [1, 2, 3]; //[1,2,3]是字面量const d = &#123; foo: "bar" &#125;; //&#123;"foo":"bar"&#125;是字面量每个对象都有构造函数属性这个属性引用了用来创建这个对象的构造函数1234new String(); // ''," ",``new Boolean(); // true ,falsenew Number(); //1,2,3,4,5,6new Object(); //&#123;&#125;值类型复制值对象或者引用类型复制他们的引用123456789101112131415let number=10;function increase(number)&#123; number++;&#125;increase(number);console.log(number) //10let object=&#123;value:10&#125;;function increase(object)&#123;object.value++;&#125;increase(object);console.log(object) //&#123;value:11&#125;`不知道要访问的对象名称属性，是在运行时产生的，可以使用方括号的语法,或者属性名不符合命名规则时。抽象意味着我们应该隐藏细节和复杂部分，只显示或者暴露必要的部分123456789this.defaultLocaltion=&#123;x:0,y:1&#125; // ====&gt; let defaultLocaltion=&#123;x:0,y:1&#125;Object.defineProperty(this,'defaultLocaltion',&#123; get()&#123; return defaultLocaltion &#125;, set(value)&#123; defaultLocaltion=value &#125;&#125;)Javascript 中没有类，只有对象，那只有对象的时候如何引入继承？答案是原型。 原型可以理解为一个对象的父母，原型就是一般的对象。12345678const person = &#123; name: "hello" &#125;;Object.defineProperty(person, "name", &#123;writable: false,enumerable: true,configurable: false&#125;);delete person.name;console.log(person); // &#123; name: 'hello' &#125;获得对象原型的方法是调用 Object 对象的 getPrototypeOf 方法123456function Circle(radius) &#123; this.radius = radius;&#125;const circle = new Circle(1);Circle.prototype; //这是构造函数创建的对象的父母真身circle.__proto__ === Circle.prototype; // trueObject.keys 只返回实例的成员for-in 循环返回所有的成员，对象实例本身的和它的原型的在 Javascript 中，有个函数可以从给定的原型创建对象，就是 Object.create(第一个参数是用作创建的原型)Javascript 里每个对象都有一个构造函数属性，能返回用以创建这个对象的构造函数避免创建层级式继承关系，因为这十分脆弱。如果要用继承特性，最好维持在一级。好的组合胜过继承。Object.assign()可以用这个方法从一个对象拷贝所有成员到另外一个对象123456789101112131415161718192021222324252627282930 const canEat = &#123; eat: function() &#123; console.log("eating"); &#125; &#125;; const canWalk = &#123; walk: function() &#123; console.log("eating"); &#125; &#125;; const canSwin = &#123; swin: function() &#123; console.log("swining"); &#125; &#125;; // const person = Object.assign(&#123;&#125;, canEat, canWalk);// 空对象实际上变成了2个对象的组合 // console.log(person); function mixins(target, ...sources) &#123; Object.assign(target.prototype, ...sources); &#125; // function Person() &#123;&#125; // Object.assign(Person.prototype, canEat, canWalk); // console.log(new Person()); function Dog() &#123;&#125; mixins(Dog, canEat, canWalk); console.log(new Dog()); function GoldFish() &#123;&#125; mixins(GoldFish, canEat, canSwin); console.log(new GoldFish());ES6函数声明 funciton sayHello(){} 结尾不需要加分号，函数声明是置顶的。函数表达式const sayGoodbye=function(){} 结尾需要加分号，不会被置顶。不同于函数，类声明和类表达式都不会被置顶实例方法和静态方法1234567891011121314class Circle &#123; constructor(radius) &#123; this.radius = radius; &#125; // Instance Method draw() &#123;&#125; // Static Mthod static parse(str) &#123; const &#123; radius &#125; = JSON.parse(str); return new Circle(radius); &#125;&#125;const circle = Circle.parse('&#123;"radius":1&#125;');console.log("Go: circle", circle); // Go: circle Circle &#123; radius: 1 &#125;所以我们用静态方法的方式创建不属于具体实例的工具函数123456const c = new Circle(2);// Method callc.draw(); // Circle &#123; radius: 2 &#125;const draw = c.draw;// Function calldraw(); // undefinedES6 私有第一种是用在命名的时候加下划线第二种是使用 Symbol123456789101112131415const _radius = Symbol();const _draw = Symbol();// Symbol() 是一个函数，能创建一个Symbol，这个不是构造函数，不能在前面加new修饰符，这样会报错class Circle &#123; constructor(radius) &#123; this[_radius] = radius; &#125; [_draw]() &#123; // 计算生成属性 &#125;&#125;const c = new Circle(1);const key = Object.getOwnPropertySymbols(c)[0];console.log(c[key]); // 1第三种是使用 WeakMap12345678910111213141516171819const _radius = new WeakMap();const _move = new WeakMap();class Circle &#123; constructor(radius) &#123; _radius.set(this, radius); _move.set(this, () =&gt; &#123; // 箭头函数将从调用它的构造器继承过来，在这个构造器里。this是circle对象实例的引用。 // 当我们在构造器函数里使用箭头函数时，this不会重新绑定，也不会重设，直接从构造器继承 console.log("moving", this); &#125;); &#125; draw() &#123; _move.get(this)(); console.log("drawing..."); &#125;&#125;const c = new Circle(2);c.draw();getter&amp;&amp;setter方法重写12345678910111213class Shape &#123; move() &#123; console.log("moving...."); &#125;&#125;class Circle extends Shape &#123; move() &#123; super.move(); console.log("circle move"); &#125;&#125;const c = new Circle();AMD，也就是异步模块定义，主要是在浏览器程序中使用。CommonJSclass Circle{}module.exports.Circle=Circle只需要引入一个模块时，可以简化代码module.exports=Circle引入时，使用 require 函数。所以时 CommonJS 定义了 require 函数和 module 函数，这是 CommonJS 当中的语法。ES6export &amp;&amp; import在模块化之前，要记住一个首要原则，高度关联的东西应该放在一起。就好比在厨房放置了杯子盘子勺子等餐具，不应该把衣服存放在厨房，这就是高度关联。这就是编程中说的 Cohesion(内聚)。Webpacknpm i -g webpack-cliwebpack-cli initnpm init –yes完结]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapboxgl实现marker的聚类]]></title>
    <url>%2Fposts%2Fa2d9d205.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习与总结]]></title>
    <url>%2Fposts%2F3d0c447.html</url>
    <content type="text"><![CDATA[插值表达式v-cloakv-textv-htmlv-bind(缩写:)v-on(缩写@)v-model 只能用于表单元素v-forv-ifv-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换，v-show 较好，如果运行时条件不太可能改变 v-if 较好事件修饰符.stop 阻止冒泡.prevent 阻止默认事件.capture 添加事件侦听器时使用事件捕获模式.self 只当事件在该元素本身（比如不是子元素）触发时触发回调.once 事件只触发一次在Vue中使用样式使用class样式数组1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;数组中使用三元表达式1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;数组中嵌套对象1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;直接使用对象1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;使用内联样式直接在元素上通过 :style 的形式，书写样式对象1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt;将样式对象，定义到 data 中，并直接引用到 :style 中在data上定义样式：123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;在 :style 中通过数组，引用多个 data 上的样式对象在data上定义样式：1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;Vue指令之v-if和v-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；私有过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt;私有 filters 定义方式：12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125;使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;);注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！键盘修饰符以及自定义键盘修饰符通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名：1Vue.config.keyCodes.f2 = 113;使用自定义的按键修饰符：1&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;自定义指令使用 Vue.directive()定义全局的指令，比如 v-focus其中 参数 1：指令的名称，定义时不需要加 v-的前缀使用的时候必须在指令名称前面加上 v-前缀来调用参数 2：是一个对象，这个对象上有一些指令相关的函数，这些函数可以在特定的阶段执行相关的操作123456789101112131415Vue.dirctive('focus',&#123;bind:function(el)&#123; //每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次 //每个函数中的第一个参数永远是el表示被绑定的指令的那个元素，是原生的js对象 //每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次 // 和样式相关的操作，一般都可以在bind执行&#125;, inserted(el)&#123; el.focus(); // 和js行为相关的操作，最好在inserted中执行，防止js行为不生效 &#125;, updated(el)&#123; //当Vnode更新时，会执行updated，可能会触发多次 &#125;&#125;私有指令的定义123456dirctives:&#123; //自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 'fontsize':function (el,binding)&#123; el.style.fontSize=binding.value &#125; &#125;自定义指令的使用方式：1&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt;实现筛选的方式显示过滤-排序结果：筛选框绑定到 VM 实例中的 searchName 属性：123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去：12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;search 过滤方法中，使用 数组的 filter 方法进行过滤：123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125;JSONP的实现原理由于浏览器安全限制，不允许AXAJ访问协议不同、域名不同、端口号不同——不符合同源策略的。可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址。因为script标签不存在跨域限制，这种数据获取方式称之为JSONP具体实现过程先在客户端定义一个回调方法，预定义对数据的操作；再把这个回调方法的名称通过URL传参的形式提交到服务器的数据接口；服务器数据接口组织好要发送给客户端的数据，再拿客户端传递过来的回调方法名称拼接出一个调用这个方法的字符串，发送给客户端解析执行；客户端拿到服务器的返回的字符串之后，当作script脚本执行。Node.js 实现一个JSONP的请求例子1234567891011121314151617181920212223242526272829303132333435const http = require(&apos;http&apos;); // 导入解析 URL 地址的核心模块 const urlModule = require(&apos;url&apos;); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on(&apos;request&apos;, (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === &apos;/getjsonp&apos;) &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: &apos;zs&apos;, age: 22, gender: &apos;男&apos;, hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end(&apos;404&apos;); &#125; &#125;); server.listen(3000, () =&gt; &#123; console.log(&apos;server running at =http://127.0.0.1:3000&apos;); &#125;);Vue中的动画使用过渡类名HTML结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;VM 实例：123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;);定义两组类样式：12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125;使用第三方 CSS 动画库导入动画类库：1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;定义 transition 及属性：123456&lt;transition enter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt;使用动画钩子函数定义 transition 组件以及三个钩子函数：123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;定义三个 methods 钩子方法：12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = &apos;translateX(500px)&apos;; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = &apos;translateX(0px)&apos;; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125;定义动画过渡时长和样式：123.show&#123; transition: all 0.4s ease; &#125;v-for 的列表过渡定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt;定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;定义 VM中的结构：1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; txt: &apos;&apos;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = &apos;&apos;; &#125; &#125;&#125;);列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125;定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同：模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos; &#125;); Vue.component(&apos;login&apos;, login);直接使用 Vue.component 方法：123Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos; &#125;);将模板字符串，定义到script标签种：123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt;同时，需要使用 Vue.component 来定义组件：123Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos; &#125;);注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！组件中展示数据和响应事件在组件中，data需要被定义为一个方法，例如：12345678910111213Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos;, data() &#123; return &#123; msg: &apos;大家好！&apos; &#125; &#125;, methods:&#123; login()&#123; alert(&apos;点击了登录按钮&apos;); &#125; &#125; &#125;);在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问；组件切换vue 提供了 component，来展示对应的名称组件component 是一个占位符,:is 属性，可以用来指定展示的组件的名称父组件向子组件传值组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;这是父组件中的消息&apos; &#125;, components: &#123; son: &#123; template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;, props: [&apos;finfo&apos;] &#125; &#125; &#125;); &lt;/script&gt;使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt;子组件向父组件传值原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>编程</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构2——改善既有代码的设计]]></title>
    <url>%2Fposts%2Fb189f81a.html</url>
    <content type="text"><![CDATA[前言都能写出计算机可以理解代码，唯有写出人类容易理解的代码的，才是优秀的程序员。好代码的标准就是人们能否轻而易举地修改它重构的原则何谓重构重构这个词既可以是名词也可以是动词，名词形式的定义的是：对软件内部结构的调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。动词形式的定义的是：使用一系列的重构手法，在不改变可观察行为的前提下，调整其结构为何重构重构改进软件的设计重构时软件更容易理解重构帮助找到bug重构提高编程速度何时重构预备性重构：让添加的新功能更容易帮助理解的重构：使代码更容易理解捡垃圾式重构有计划的重构和见机行事的重构长期重构复审代码时重构何时不重构重写比重构还容易只有需要理解其工作原理时，对其重构才有价值。]]></content>
      <categories>
        <category>技术</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode中python代码输出中文乱码解决方法]]></title>
    <url>%2Fposts%2F87ed0839.html</url>
    <content type="text"><![CDATA[在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：先检查右下角编码集设置是否正确修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改在 json 中添加下列属性123"code-runner.executorMap": &#123;"python": "set PYTHONIOENCODING=utf8 &amp;&amp; python -u"&#125;https://mp.weixin.qq.com/s/QIJ-QHkxZUyKyQAPG49vPg]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo下next主题时出错]]></title>
    <url>%2Fposts%2F326cb881.html</url>
    <content type="text"><![CDATA[next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用在主题下的_config.yml文件中设置：使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。issue：https://github.com/rozbo/hexo-abbrlink/issues/19解决方法：https://github.com/foreveryang321/hexo-asset-image]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + NexT 快速搭建博客]]></title>
    <url>%2Fposts%2Feba3f111.html</url>
    <content type="text"><![CDATA[安装安装 node.js如果你已经安装了 node.js，请忽略。访问node.js 官网，根据指引进行安装。安装 Git如果你已经安装了 Git，请忽略。访问Git 官网，根据指引进行安装。由于众所周知的原因，Windows 从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。安装 Hexo国内的朋友，因为众所周知的原因，从 npm 直接安装 hexo 会非常慢，所以你需要用到镜像源，参考上面的步骤，使用 cnpm 命令行工具代替默认的 npm: 在 windows 控制台（cmd）里输入并执行npm install -g cnpm --registry=https://registry.npm.taobao.org，然后安装 hexo: cnpm install -g hexo-cli国外的朋友，请直接打开 windows 控制台，输入npm install -g hexo-cli并执行。建站建立本地博客文件夹在命令行执行如下命令，其中&lt;folder&gt;为文件夹路径12hexo init &lt;folder&gt;cd &lt;folder&gt;所有有关hexo的命令 均要在&lt;folder&gt;路径下执行。建立好后文件夹目录如下123456789.├── _config.yml├── package.json├── .gitignore├── node_modules├── scaffolds├── source| ├── _posts└── themes其中_config.yml：站点的配置文件，可以在此配置大部分的参数。package.json：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。123456789101112131415161718&#123;"name": "hexo-site","version": "0.0.0","private": true,"hexo": &#123;"version": "3.9.0"&#125;,"dependencies": &#123;"version": "3.9.0""hexo-generator-archive": "^0.1.5","hexo-generator-category": "^0.1.3","hexo-generator-index": "^0.2.1","hexo-generator-tag": "^0.2.0","hexo-renderer-ejs": "^0.3.1","hexo-renderer-stylus": "^0.3.3","hexo-renderer-marked": "^1.0.1","hexo-server": "^0.3.3"&#125;scaffolds：模板文件夹，是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source：资源文件夹，存放用户资源的地方。除_posts文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes：主题文件夹。Hexo 会根据主题来生成静态页面。node_modules：node.js 模块，一些 插件 和 依赖 会被安装到这里。更加详细的解释请参考hexo 官方文档安装 NexT 主题进入本地博客文件夹并将 NexT 主题clone至themes文件夹下1git clone https://github.com/theme-next/hexo-theme-next themes/next你会看到，在next下也有一个_config.yml的文件，这是 NexT 主题的配置文件，为了区别它和 博客配置文件，下面会用带路径的文件名来描述它们：&lt;folder&gt;/_config.yml：站点配置文件next/_config.yml：主题配置文件启用 NexT 主题在&lt;folder&gt;/_config.yml里theme:选项填next，=&gt;theme: next，注意冒号后空一格。到这里，建站的任务就完成了。你现在可以打开控制台，输入并执行如下命令：1hexo g完成没有报错之后执行如下命令：1hexo s其中hexo g：新建public文件夹，并在其中生成网站静态文件（html，css，等文件）hexo s：启动 hexo 服务器，默认情况下，访问网址为：http://localhost:4000/更多有关 hexo 的命令，请参考hexo 官方文档的命令部分。你最后会看到控制台有如下输出：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.在浏览器地址栏输入http://localhost:4000/并访问，你应该会看到如下页面：&nbsp;**恭喜你！你已经完成了博客搭建的主要工作！接下来就是细节的配置了。请耐心阅读以下内容。**配置网站脚注12345678910111213141516171819202122footer: #建站时间 since: 2018 #作者头像并且是动画效果 icon: name: user animated: true color: "##66CDAA" #显示版权作者 copyright: aigisss 爱即是诗 #不显示Hexo powered: enable: false version: false #不显示主题和版本 theme: enable: false version: false #显示备案号 beian: enable: true icp: 赣ICP备18013338-1号版权声明1234creative_commons: license: by-nc-sa sidebar: false post: true代码块123456789codeblock: # 自定义边框半径，默认是1 # 值越大弧度越大 border_radius: 6 # 右上角显示复制按钮 copy_button: enable: true # 显示复制结果 show_result: true分享123456789101112131415161718needmoreshare2: enable: true postbottom: #文章底部 enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook #左下角悬浮按钮 float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook访问次数123456789101112# busuanzi统计busuanzi_count: enable: true # 总访客数 total_visitors: true total_visitors_icon: user # 总浏览量 total_views: true total_views_icon: eye # 文章浏览量 post_views: true post_views_icon: eye顶部阅读进度条1234reading_progress: enable: true color: "#37c6c0" height: 2px加载动画123456789101112131415161718192021222324motion: # 启用 enable: true # 异步加载 async: true transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut # 文章摘要动画 post_block: bounceIn # 加载各种页面动画（分类，关于，标签等等） post_header: fadeIn # 文章详情动画 post_body: fadeIn # coll_header: fadeIn # Only for Pisces | Gemini. # 侧边栏（人物头像的那部分） sidebar: fadeIn搜索功能NexT自带提供了两个搜索algolia_searchlocal_search其实这个local_search已经很好用了，配置algolia_search挺麻烦的，而且搜索功能也用的不多毕竟有万能的Ctrl + F123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false添加 RSS 订阅12345678910npm install hexo-generator-feed --save复制代码# Extensionsplugins: hexo-generate-feedfeed: # RSS订阅插件 type: atom path: atom.xml limit: 0 #0就是代表所有数学公式1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex还需要在文章的 Front-matter 里打开 mathjax 开关，比如：12345title: 使用hexo下next主题搭建博客的记录tags: 日常abbrlink: 326cb881date: 2019-09-09 09:58:21mathjax: true网上一大堆说会出现语义冲突—–类 Latex 格式书写的数学公式下划线_表示下标，有特殊的含义，如果被强制转换为&lt;em&gt;标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括*, {, }, \\等。但是！！在我试验下没有出现此类问题，只要在主题中打开，md 中申明 mathjax: true 就好了，可能在我使用的next6.7中解决了冲突。比如以下的公式能出来！1\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.$$12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$$$P = \frac{\sum_{i=1}^n (x_i- x)(y_i- y)}{\displaystyle \left[\sum_{i=1}^n (x_i-x)^2\sum_{i=1}^n (y_i-y)^2\right]^{1/2} }$$添加自定义菜单以新建「相册」菜单为例：在博客目录下的 source 文件夹下新建名为 photo 文件夹，然后在 photo 文件夹下新建一个 index.md 文件，然后在该文件填写：12345---title: 相册date: 2018-04-16 22:14:07type: "photo"---然后打开主题配置文件 _config.yml，在 menu 中添加：1234567menu: home: / || home archives: /archives || archive categories: /categories || th tags: /tags || tags #添加「相册」菜单 相册: /photo || camera这里的「相册」是博客中显示的菜单名称，紧跟的 photo 要和前面 index.md 文件的 type 值一致，|| 后面的菜单的图标，图标名称来自于 FontAwesome icon，若没有配置图标，默认会使用问号图标修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;参考Hexo+NexT 打造一个炫酷博客篇Ⅱ：NexT主题的配置和优化指南]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的操作记录]]></title>
    <url>%2Fposts%2Fd5d49586.html</url>
    <content type="text"><![CDATA[与服务器上的代码产生冲突如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:error: Your local changes to the following files would be overwritten by merge:protected/config/main.phpPlease, commit your changes or stash them before you can merge.如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:123git stashgit pullgit stash pop然后可以使用 git diff -w +文件名来确认代码自动合并的情况.反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:12git reset --hardgit pull其中 git reset 是针对版本,如果想针对文件回退本地修改,使用1git checkout HEAD file/to/restore辛辛苦苦加班一星期敲的代码没了过程是这样的，在终端输入 git log，列出所有的 commit 信息，如下图：commit 的信息很简单，就是做了 6 个功能，每个功能对应一个 commit 的提交，分别是 feature-1 到 feature-6。接下来执行了强制回滚，如下：1git reset --hard 2216d4e回滚到了 feature-1 上，并且回滚的时候加了–hard，导致之前 feature-2 到 feature-6 的所有代码全部弄丢了，现在 git log 的显示如下：现在 feature-2 到 feature-6 的代码没了。。。。。然鹅还没完，在这个基础上新添加了一个 commit 提交，信息叫 feature-7，如下图：现在 feature-2 到 feature-6 全没了，还多了一个 feature-7请问 如何把丢失的代码 feature-2 到 feature-6 全部恢复回来，并且 feature-7 的代码也要保留用git reflog和git cherry-pick就能解决在终端里输入：1git reflog然后就会展示出所有你之前git操作，你以前所有的操作都被git记录了下来，如下图：这时候要记好两个值：4c97ff3和cd52afc，他们分别是feature-7和feature-6的hash码。然后执行回滚，回到feature-6上：1git reset --hard cd52afc现在我们回到了feature-6上，如下图：我们回到了feature-6上，但是feature-7没了，如何加上来呢？这个时候就用上了git cherry-pick，刚刚我们知道了feature-7的hash码为4c97ff3，操作如下：1git cherry-pick 4c97ff3回车之后，你的feature-7的代码就回来了。期间可能会有一些冲突，按照提示解决就好。最后的结果如下图：feature-1 到 feature-7的代码就合并到了一起，以前的代码也都回来了。原文出自前端时光机]]></content>
      <categories>
        <category>编程</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用coding-pages时出现静态文件丢失]]></title>
    <url>%2Fposts%2F372cd070.html</url>
    <content type="text"><![CDATA[出现这种情况，发现静态资源都加载不到，后来网上搜索了半天，才发现原来你要打算用 coding 的 pages 服务部署你的博客的话，你创建项目的名字必须和用户名保持一致，不能自己随便自定义。我重新创建了一个和用户名一致的项目，部署到他的 pages 服务，访问正常]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
