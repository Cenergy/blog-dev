<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Threejs学习与总结2]]></title>
    <url>%2Fposts%2Fb59ace26.html</url>
    <content type="text"><![CDATA[Scene 场景和页面调试场景是我们每个 Three.js 项目里面放置内容的容器，我们也可以拥有多个场景进行切换展示，你可以在场景内放置你的模型、灯光和照相机。还可以通过调整场景的位置，让场景内的所有内容都一起跟着调整位置。场景的结构之前在刚刚开始学 JavaScript 基础时，我们总免不了去操作 DOM 对象，而且我们都知道 DOM 的结构是树形结构的，Three.js 也遵循了这样的理念，将所有可以添加到场景内的结构梳理成了一种树形的结构，方便我们能够更好的理解Three.js。我们可以把 Scene 想象成一个 body，body 内可以添加 DOM 对象，scene 内也可以添加它的 3D 对象，这样一层层的嵌套出来，组成了我们现在需要的项目。所以，在 Three.js 中，为了方便操作，将所有 3D 对象共同的内容抽象成了一个基类，就是 THREE.Object3D。THREE.Object3D为了方便操作，Three.js 将每个能够直接添加到场景内的对象都继承自一个基类——THREE.Object3D，以后我们将继承自这个基类的对象称为 3D 对象，判断一个对象是否是继承自 THREE.Object3D，我们可以这么做：12obj instanceof THREE.Object3D//继承至返回 true 否则返回false这个基类上封装了我们常用的一些方法，下面我们分别介绍下。添加一个 3D 对象1scene.add(mesh); //将网格添加到场景将一个立方体添加到场景内显示。这个方法不光能够在场景内使用，而且也可以将一个 3D 对象添加到另一个 3D 对象里面，代码如下：1parent.add(child);获取一个 3D 对象获取一个 3D 对象可以使用 getObjectByName 通过 3D 对象的 name 值进行获取，在获取前我们首先要设置当前 3D 对象的 name 值：123object3D.name = "firstObj";scene.add(object3D);scene.getObjectByName("firstObj"); //返回第一个匹配的3d对象另一种方式就是使用 getObjectById 通过 3D 对象的 id 值进行获取，3D 对象的 id 值只能读取，它是在添加到场景时，按 1、2、3、4、5……的顺序默认生成的一个值，无法自定义：1scene.getObjectById(1); //返回id值为1的3d对象删除一个 3D 对象如果我们想隐藏一个 3D 对象，而不让它显示，可以通过设置它的 visible的值来实现：1mesh.visible = false; //设置为false，模型将不会被渲染到场景内如果一个模型不再被使用到，需要彻底删除，我们可以使用 remove 方法进行删除：12scene.add(mesh); //将一个模型添加到场景当中scene.remove(mesh); //将一个模型从场景中删除获取到所有的子类每一个 3D 对象都有一个 children 属性，这是一个数组，里面包含所有添加的 3D 对象：1234scene.add(mesh1);scene.add(mesh2);console.log(scene.children);// [mesh1, mesh2]如果想获取 3D 对象下面所有的 3D 对象，我们可以通过 traverse方法获取：123456mesh1.add(mesh2); //mesh2是mesh1的子元素scene.add(mesh1); //mesh1是场景对象的子元素scene.traverse(fucntion(child)&#123; console.log(child);&#125;);//将按顺序分别将mesh1和mesh2打印出来获取 3D 对象的父元素每个 3D 对象都有一个父元素，可以通过 parent 属性进行获取：12scene.add(mesh); //将模型添加到场景console.log(mesh.parent === scene); //true修改 3D 对象前面介绍了场景的结构以及场景的 3D 对象添删查，下面，我们接着介绍对场景内模型的一些操作。修改位置方式我们可以通过设置模型的 position 属性来修改模型的当前位置，具体方法有以下几种。单独设置每个方向的属性。123mesh.position.x = 3; //将模型的位置调整到x正轴距离原点为3的位置。mesh.position.y += 5; //将模型的y轴位置以当前的位置向上移动5个单位。mesh.position.z -= 6;直接一次性设置所有方向的属性。1mesh.position.set(3, 5, -6); //直接将模型的位置设置在x轴为3，y轴为5，z轴为-6的位置Three.js 模型的位置属性是一个 THREE.Vector3（三维向量）的对象，我们可以直接重新赋值一个新的对象。1mesh.position = new THREE.Vector3(3, 5, -6); //上面的设置位置也可以通过这样设置。修改大小的方式模型导入后，很多情况下都需要调整模型的大小。我们可以通过设置模型的 scale 属性来调整大小。第一种方式是单独设置每个方向的缩放。123mesh.scale.x = 2; //模型沿x轴放大一倍mesh.scale.y = 0.5; //模型沿y轴缩小一倍mesh.scale.z = 1; //模型沿z轴保持不变第二种是使用 set 方法。12mesh.scale.set(2, 2, 2); //每个方向等比放大一倍mesh.scale.set(0.5, 0.5, 0.5); //每个方向等比缩小一倍第三种方式，由于 scale 属性也是一个三维向量，我们可以通过赋值的方式重新修改。1mesh.scale = new THREE.Vector3(2, 2, 2); //每个方向都放大一倍修改模型的转向很多情况下，我们需要对模型进行旋转，以达到将模型显示出它需要显示的方位，我们可以通过设置模型的 rotation 属性进行旋转（注意：旋转 Three.js 使用的是弧度不是角度）。第一种方式是单独设置每个轴的旋转。123mesh.rotation.x = Math.PI; //模型沿x旋转180度mesh.rotation.y = Math.PI * 2; //模型沿y轴旋转360度，跟没旋转一样的效果。。。mesh.rotation.z = - Math.PI / 2; //模型沿z轴逆时针旋转90度第二种方式就是使用 set 方法重新赋值。1mesh.rotation.set(Math.PI, 0, - Math.PI / 2); //旋转效果和第一种显示的效果相同正常模型的旋转方式是按照 XYZ 依次旋转的，如果你想先旋转其他轴，我们可以添加第四项修改，有可能的情况为：YZX、ZXY、XZY、YXZ 和 ZYX。1mesh.rotation.set(Math.PI, 0, - Math.PI / 2, "YZX"); //先沿y轴旋转180度，再沿z轴旋转0度，最后沿x轴逆时针旋转90度第三种方式，模型的 rotation 属性其实是一个欧拉角对象（THREE.Euler），欧拉角后面会讲解到，我们可以通过重新赋值一个欧拉角对象来实现旋转调整：1mesh.rotation = new THREE.Euler(Math.PI, 0, - Math.PI / 2, "YZX");使用 dat.GUI 实现页面调试有些时候，我们需要调整模型的位置或者大小等，且需要每次都去场景内调试，一种常用的插件 dat.GUI首先，需要将插件的源码引入到页面当中，我这里直接使用 CDN 的连接。1&lt;script src="https://cdn.bootcss.com/dat-gui/0.7.1/dat.gui.min.js"&gt;&lt;/script&gt;创建一个对象，在里面设置我们需要修改的一些数据。12345controls = &#123; positionX:0, positionY:0, positionZ:0&#125;;实例化dat.GUI对象，将需要修改的配置添加对象中，并监听变化回调。12345678gui = new dat.GUI();gui.add(controls, "positionX", -1, 1).onChange(updatePosition);gui.add(controls, "positionY", -1, 1).onChange(updatePosition);gui.add(controls, "positionZ", -1, 1).onChange(updatePosition);function updatePosition() &#123; mesh.position.set(controls.positionX, controls.positionY, controls.positionZ);&#125;这样，只要我们每次修改对象里面的值，都会触发 updatePosition 回调，来更新模型的位置。这样，我们就实现了一个简单的案例。接下来，我列出一下经常会使用到一些方式和方法。生成一个输入框dat.GUI 能够根据 controls 值的不同而生成不同的操作方法，如果值的类型为字符串或者数字类型，则可以生成一个默认的输入框：123gui.add(controls, "positionX");gui.add(controls, "positionY");gui.add(controls, "positionZ");生成一个可以滑动的滑块使用 gui.add() 方法，如果值为数字类型，传入的第三个值（最小值）和第四个值（最大值），就限制了值能够取值的范围，这样就生成了可以滑动的滑块：123gui.add(controls, "positionX", -1, 1); //设置了最小值和最大值，可以生成滑块gui.add(controls, "positionY").max(1); //只设置了最大值，无法生成滑块gui.add(controls, "positionZ").min(-1); //只设置了最小值，也无法生成滑块我们还可以通过 step() 方法来限制每次变化的最小值，也就是你增加或者减少，必须都是这个值的倍数：123gui.add(controls, "positionX", -10, 10).step(1); //限制必须为整数gui.add(controls, "positionY", -10, 10).step(0.1); //每次变化都是0.1的倍数gui.add(controls, "positionZ", -10, 10).step(10); //每次变化都是10的倍数生成一个下拉框只要按规则在 gui.add() 的第三个值传入一个对象或者数组，dat.GUI 就能够自动匹配生成一个下拉框：12345678910controls = &#123; positionX:0, positionY:false, positionZ:"middle"&#125;;gui = new dat.GUI();gui.add(controls, "positionX", &#123;left:-10, middle:0, right:10&#125;); //数字类型的下拉框gui.add(controls, "positionY", [true, false]); //布尔值类型的下拉框gui.add(controls, "positionZ", ["left", "middle", "right"]); //字符串类型的下拉框生成一个 Checkbox只要 controls 的值是一个布尔类型，使用 gui.add() 方法就可以生成一个复选框：12345678910controls = &#123; positionX:true, positionY:false, positionZ:false&#125;;gui = new dat.GUI();gui.add(controls, "positionX");gui.add(controls, "positionY");gui.add(controls, "positionZ");生成一个点击事件按钮如果 controls 的值为一个函数 Function，dat.GUI 会自动生成一个可以点击的按钮，当按下时就会触发这个函数事件：12345678910controls = &#123; positionX:function () &#123;&#125;, positionY:function () &#123;&#125;, positionZ:function () &#123;&#125;&#125;;gui = new dat.GUI();gui.add(controls, "positionX");gui.add(controls, "positionY");gui.add(controls, "positionZ");修改显示的名称我们可以在后面使用 name() 事件设置显示的名称：123gui.add(controls, "positionX", -1, 1).name("x轴");gui.add(controls, "positionY", -1, 1).name("y轴");gui.add(controls, "positionZ", -1, 1).name("z轴");颜色选择框实现颜色选择框，首先需要一种正常格式的颜色值，比如 CSS 的颜色样式或者 RGB 格式，然后再使用 gui.addColor() 的方法添加：12345678910controls = &#123; positionX:"#cccccc", //css样式 positionY: [0, 255, 255], //RGB格式 positionZ: [0, 255, 255, 0.6] //RGBA格式&#125;;gui = new dat.GUI();gui.addColor(controls, "positionX").name("x轴");gui.addColor(controls, "positionY").name("y轴");gui.addColor(controls, "positionZ").name("z轴");监听事件回调dat.GUI 给我们提供了监听事件回调的方法 onChange()，如果值变化就能够触发函数回调：1234567gui.add(controls, "positionX", -1, 1).onChange(updatePosition);gui.add(controls, "positionY", -1, 1).onChange(updatePosition);gui.add(controls, "positionZ", -1, 1).onChange(updatePosition);function updatePosition() &#123; mesh.position.set(controls.positionX, controls.positionY, controls.positionZ);&#125;创建分组我们可以使用 gui.addFolder() 方法来创建分组：12345678gui = new dat.GUI();var first = gui.addFolder("第一个分组"); //创建第一个分组first.add(controls, "positionX", -1, 1).onChange(updatePosition);first.open();var two = gui.addFolder("第二个分组");two.add(controls, "positionY", -1, 1).onChange(updatePosition);two.add(controls, "positionZ", -1, 1).onChange(updatePosition);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Threejs学习与总结1]]></title>
    <url>%2Fposts%2F2c939f9c.html</url>
    <content type="text"><![CDATA[使用 Three.js 显示创建的内容，我们必须需要的三大件是：渲染器、相机和场景。相机获取到场景内显示的内容，然后再通过渲染器渲染到画布上面。要在屏幕上展示3D图形，思路大体上都是这样的：构建一个三维空间Three中称之为场景(Scene)选择一个观察点，并确定观察方向/角度等Three中称之为相机(Camera)在场景中添加供观察的物体Three中的物体有很多种，包括Mesh,Line,Points等，它们都继承自Object3D类将观察到的场景渲染到屏幕上的指定区域Three中使用Renderer完成这一工作构建场景 Scene场景是所有物体的容器，也对应着我们创建的三维世界。创建相机 Camera12345// 初始化相机function initCamera() &#123; camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200); // 实例化相机 camera.position.set(0, 0, 15);&#125;相机Three中的相机有两种，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。正交投影与透视投影的区别如上图所示，左图是正交投影，物体发出的光平行地投射到屏幕上，远近的方块都是一样大的；右图是透视投影，近大远小，符合我们平时看东西的感觉。维基百科：三维投影正交投影相机可以近似地认为，视景体里的物体平行投影到近平面上，然后近平面上的图像被渲染到屏幕上。透视投影相机坐标系Camera是三维世界中的观察者，为了观察这个世界，首先我们要描述空间中的位置，Three中使用采用常见的右手坐标系定位：我们这里使用到的是 THREE.PerspectiveCamera，这个相机模拟人眼看到的效果，就是具有透视的效果，近大远小。第一行，我们实例化了一个透视相机，需要四个值，分别是视野、宽高比、近裁面和远裁面。视野：当前相机视野的宽度，值越大，渲染出来的内容也会更多。宽高比：默认是按照画布显示的宽高比例来设置，如果比例设置的不对，会发现渲染出来的画面有拉伸或者压缩的感觉。近裁面和远裁面：这个是设置相机可以看到的场景内容的范围，如果场景内的内容位置不在这两个值内的话，将不会被显示到渲染的画面中。第二行，我们设置了相机的位置。创建渲染器 Renderer123456//初始化渲染器function initRenderer() &#123; renderer = new THREE.WebGLRenderer(); //实例化渲染器 renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高 document.body.appendChild(renderer.domElement); //添加到dom&#125;第一行实例化了一个 THREE.WebGLRenderer，这是一个基于 WebGL 渲染的渲染器，当然，Three.js 向下兼容，还有 CanvasRenderer、CSS2DRenderer、CSS3DRenderer 和 SVGRenderer，这四个渲染器分别基于 canvas2D、CSS2D、CSS3D 和 SVG 渲染的渲染器。由于，作为 3D 渲染，WebGL 渲染的效果最好，并且支持的功能更多。第二行，调用了一个设置函数 setSize 方法，这个是设置需要显示的窗口大小。案例是基于浏览器全屏显示，所以设置了浏览器窗口的宽和高。第三行，renderer.domElement 是在实例化渲染器时生成的一个 Canvas 画布，渲染器渲染界面生成的内容，都将在这个画布上显示。所以，我们将这个画布添加到了 DOM 当中，来显示渲染的内容。创建模型 Object3D渲染器，场景和相机都全了，是不是就能显示东西了？不能！因为场景内没有内容，即使渲染出来也是一片漆黑，所以我们需要往场景里面添加内容。接下来，我们将查看 initMesh 方法，看看如何创建一个最简单的模型：12345678//创建模型function initMesh() &#123; geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体 material = new THREE.MeshNormalMaterial(); //创建材质 mesh = new THREE.Mesh( geometry, material ); //创建网格 scene.add( mesh ); //将网格添加到场景&#125;创建一个网格（模型）需要两种对象：几何体和材质。几何体代表模型的形状，它是由固定的点的位置组成，点绘制出面，面组成了模型。材质是我们看到当前模型显示出来的效果，如显示的颜色，质感等。Three中供显示的物体有很多，它们都继承自Object3D类Mesh我们都知道，计算机的世界里，一条弧线是由有限个点构成的有限条线段连接得到的。线段很多时，看起来就是一条平滑的弧线了。计算机中的三维模型也是类似的，普遍的做法是用三角形组成的网格来描述，我们把这种模型称之为Mesh模型。这是那只著名的斯坦福兔子。它在3D图形中的地位与数字图像处理领域中著名的Lenna是类似的。看这只兔子，随着三角形数量的增加，它的表面越来越平滑在Three中，Mesh的构造函数是这样的：Mesh( geometry, material )geometry是它的形状，material是它的材质。不止是Mesh，创建很多物体都要用到这两个属性。下面我们来看看这两个重要的属性。GeometryGeometry，形状，相当直观。Geometry通过存储模型用到的点集和点间关系(哪些点构成一个三角形)来达到描述物体形状的目的。Three提供了立方体(其实是长方体)、平面(其实是长方形)、球体、圆形、圆柱、圆台等许多基本形状；你也可以通过自己定义每个点的位置来构造形状；对于比较复杂的形状，我们还可以通过外部的模型文件导入。MaterialMaterial，材质，这就没有形状那么直观了。材质其实是物体表面除了形状以为所有可视属性的集合，例如色彩、纹理、光滑度、透明度、反射率、折射率、发光度。这里讲一下材质(Material)、贴图(Map)和纹理(Texture)的关系。材质上面已经提到了，它包括了贴图以及其它。贴图其实是‘贴’和‘图’，它包括了图片和图片应当贴到什么位置。纹理嘛，其实就是‘图’了。Three提供了多种材质可供选择，能够自由地选择漫反射/镜面反射等材质。创建光影Light神说：要有光！光影效果是让画面丰富的重要因素。Three提供了包括环境光AmbientLight、点光源PointLight、 聚光灯SpotLight、方向光DirectionalLight、半球光HemisphereLight等多种光源。只要在场景中添加需要的光源就好了。让场景动起来动画，就是多幅图片一直切换便可显示动画的效果。为了能显示动画的效果，我们首先要了解一个函数 requestAnimationFrame，这个函数专门为了动画而出现。它与 setInterval 相比，优势在于不需要设置多长时间重新渲染，而是在当前线程内 JS 空闲时自动渲染，并且最大帧数控制在一秒60帧。所以，我们书写了一个可以循环调用的函数：1234function animate() &#123; requestAnimationFrame(animate); //循环调用函数 // ...&#125;在循环调用的函数中，每一帧我们都让页面重新渲染相机拍摄下来的内容：1renderer.render( scene, camera ); //渲染界面渲染的 render 方法需要两个值，第一个值是场景对象，第二个值是相机对象。这意味着，你可以有多个相机和多个场景，可以通过渲染不同的场景和相机让画布上显示不同的画面。但是，如果现在一直渲染的话，我们发现就一个立方体在那，也没有动，我们需要做的是让立方体动起来：12mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度每一个实例化的网格对象都有一个 rotation 的值，通过设置这个值可以让立方体旋转起来。在每一帧里，我们让立方体沿 x 轴方向旋转0.01弧度，沿 y 轴旋转0.02弧度（1π 弧度等于180度角度）。Three.js 的性能检测插件在 Three.js 里面，遇到最多的问题就是性能问题，所以我们需要时刻检测当前的 Three.js 的性能。现在 Three.js 常使用的一款插件叫 stats。接下来我们看看如何将 stats 插件在 Three.js 的项目中使用。首先在页面中引入插件代码：1&lt;script src="http://www.wjceo.com/lib/js/libs/stats.min.js"&gt;&lt;/script&gt;这是 一个 CDN 的地址，直接引入即可。然后，我们需要实例化一个 stats 对象，然后把对象内生成的 DOM 添加到页面当中。12stats = new Stats();document.body.appendChild(stats.dom);最后一步，我们需要在 requestAnimationFrame 的回调里面更新每次渲染的时间：12345function animate() &#123; requestAnimationFrame(animate); //循环调用函数 stats.update(); //更新性能插件 renderer.render( scene, camera ); //渲染界面&#125;使用了性能检测插件以后，整个代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Stats插件案例&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; canvas &#123; width: 100%; height: 100%; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;script src="https://cdn.bootcss.com/three.js/92/three.js"&gt;&lt;/script&gt; &lt;script src="http://www.wjceo.com/lib/js/libs/stats.min.js"&gt;&lt;/script&gt; &lt;script&gt; //声明一些全局变量 var renderer, camera, scene, geometry, material, mesh, stats; //初始化渲染器 function initRenderer() &#123; renderer = new THREE.WebGLRenderer(); //实例化渲染器 renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高 document.body.appendChild(renderer.domElement); //添加到dom &#125; //初始化场景 function initScene() &#123; scene = new THREE.Scene(); //实例化场景 &#125; //初始化相机 function initCamera() &#123; camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 ); //实例化相机 camera.position.set(0, 0, 15); &#125; //创建模型 function initMesh() &#123; geometry = new THREE.BoxGeometry(2, 2, 2); //创建几何体 material = new THREE.MeshNormalMaterial(); //创建材质 mesh = new THREE.Mesh(geometry, material); //创建网格 scene.add(mesh); //将网格添加到场景 &#125; //运行动画 function animate() &#123; requestAnimationFrame(animate); //循环调用函数 mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度 mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度 stats.update(); //更新性能检测框 renderer.render(scene, camera); //渲染界面 &#125; //性能检测框 function initStats() &#123; stats = new Stats(); document.body.appendChild(stats.dom); &#125; //初始化函数，页面加载完成是调用 function init() &#123; initRenderer(); initScene(); initCamera(); initMesh(); initStats(); animate(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>Threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THREE.js的学习与总结]]></title>
    <url>%2Fposts%2Fcb98d479.html</url>
    <content type="text"><![CDATA[Three.js基础知识使用Three.js绘制一个三维效果，至少需要以下几个步骤：创建一个容纳三维空间的场景 (\Sence**)将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置给定一个观察场景的位置，以及观察角度，我们用相机对象（\Camera**）来控制将绘制好的元素使用渲染器（\Renderer**）进行渲染，最终呈现在浏览器上拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。THREE.js文档场景场景允许你设置哪些对象被three.js渲染以及渲染在哪里。在场景中放置对象、灯光和相机。很简单，直接创建一个Scene的实例即可。_scene = new Scene()元素（包含光线）Three.js 为我们提供了非常多的Geometry，例如SphereGeometry（球体）、TetrahedronGeometry（四面体）、TorusGeometry（圆环体）等等。在Three.js中，材质（Material）决定了几何图形具体是以什么形式展现的。它包括了一个几何体如何形状以外的其他属性，例如色彩、纹理、透明度等等，Material和Geometry是相辅相成的，必须结合使用。相机坐标系我们可以在场景中添加一个坐标系，清楚的看到元素处于什么位置.12345//坐标系插件scene.add(new THREE.AxisHelper(1000));//坐标系插件scene.add(new THREE.AxisHelper(1000));PerspectiveCamera（透视相机）1_camera = new PerspectiveCamera(fov, aspect, near, far);最常用的摄像机类型，模拟人眼的视觉，近大远小（透视），如果是需要模拟现实，基本都是用这个相机。Fov表示的是视角，Fov越大，表示眼睛睁得越大，离得越远，看得更多。aspect代表水平方向和竖直方向可观测距离的比值。near、far分别对应相机可观测的最近和最远距离。OrthographicCamera（正交投影相机）1_camera = new OrthographicCamera(left, right, top, bottom, near, far);只有在这个矩形可视区域内才是可见的物体无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。对于渲染2D场景或者UI元素是非常有用的。position、lookAtposition属性指定了相机所处的位置。lookAt函数指定相机观察的方向。接收的参数都是一个类型为Vector3的对象。渲染器Three.js也为我们提供了几种不同的渲染器，主要看WebGL渲染器(WebGLRenderer)。WebGL渲染器使用WebGL来绘制场景，其够利用GPU硬件加速从而提高渲染性能。Three.js绘制的元素添加到浏览器上，这个过程需要一个载体，这个载体就是Canvas，你可以通过_renderer.domElement获取到这个Canvas，并将它给定到真实DOM中。123_renderer = new WebGLRenderer();_container = document.getElementById('conianer');_container.appendChild(_renderer.domElement);使用setSize函数设定你要渲染的范围，实际上它改变的就是上面Canvas的范围.通过render函数渲染上面指定的场景和相机.12_renderer.setSize(window.innerWidth, window.innerHeight);_renderer.render(_scene, _camera);requestAnimationFrame要渲染的元素可能并未被加载完，你就执行了渲染，并且只执行了一次，这时需要requestAnimationFrame方法，让场景和相机进行实时渲染。1234function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera);&#125;参考：VR全景功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[Threejs学习与总结0]]></title>
    <url>%2Fposts%2F456b6ccc.html</url>
    <content type="text"><![CDATA[学习Three.js之前要知道的什么是 WebGL？WebGL（Web 图形库）是一种 JavaScript API，用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形，而无需使用插件。WebGL 通过引入一个与 OpenGL ES 2.0 紧密相符合的 API，可以在 HTML5 &lt;canvas&gt; 元素中使用。WebGL 给我们提供了一系列的图形接口，能够让我们通过 JavaScript 去使用 GPU 来进行浏览器图形渲染的工具。什么是 Three.js？Three.js 是一款 webGL 框架，由于其易用性被广泛应用。Three.js 在 WebGL 的 API 接口基础上，又进行的一层封装。Three.js 以简单、直观的方式封装了 3D 图形编程中常用的对象。Three.js 在开发中使用了很多图形引擎的高级技巧，极大地提高了性能。另外，由于内置了很多常用对象和极易上手的工具，Three.js 的功能也非常强大，Three.js 还是完全开源的。WEBGL 和 Three.js 的关系WebGL 原生 API 是一种非常低级的接口，而且还需要一些数学和图形学的相关技术。对于没有相关基础的人来说，入门真的很难，Three.js 将入门的门槛降低了一大截，对 WebGL 进行封装，简化我们创建三维动画场景的过程。用最简单的一句话概括：WebGL 和 Three.js 的关系，相当于 JavaScript 和 jQuery 的关系。功能概述Three.js 作为 WebGL 框架中的佼佼者，由于它的易用性和扩展性，使得它能够满足大部分的开发需求，Three.js 的具体功能如下：Three.js 掩盖了 3D 渲染的细节：Three.js 将 WebGL 原生 API 的细节抽象化，将 3D 场景拆解为网格、材质和光源（即它内置了图形编程常用的一些对象种类）。面向对象：开发者可以使用上层的 JavaScript 对象，而不是仅仅调用 JavaScript 函数。功能非常丰富：Three.js 除封装了 WebGL 原始 API 之外，Three.js 还包含了许多实用的内置对象，可以方便地应用于游戏开发、动画制作、幻灯片制作、髙分辨率模型和一些特殊的视觉效果制作。速度很快：Three.js 采用了 3D 图形最佳实践来保证在不失可用性的前提下，保持极高的性能。支持交互：WebGL 本身并不提供拾取（Picking）功能（即是否知道鼠标正处于某个物体上）。而 Three.js 则固化了拾取支持，这就使得你可以轻松为你的应用添加交互功能。包含数学库：Three.js 拥有一个强大易用的数学库，你可以在其中进行矩阵、投影和矢量运算。内置文件格式支持：你可以使用流行的 3D 建模软件导出文本格式的文件，然后使用 Three.js 加载，也可以使用 Three.js 自己的 JSON 格式或二进制格式。扩展性很强：为 Three.js 添加新的特性或进行自定义优化是很容易的事情。如果你需要某个特殊的数据结构，那么只需要封装到 Three.js 即可。支持HTML5 Canvas：Three.js 不但支持 WebGL，而且还支持使用 Canvas2D、Css3D 和 SVG 进行渲染。在未兼容 WebGL 的环境中可以回退到其它的解决方案。缺点官网文档非常粗糙，对于新手极度不友好。国内的相关资源匮乏。Three.js 所有的资料都是以英文格式存在，对国内的朋友来说又提高了门槛。Three.js 不是游戏引擎，一些游戏相关的功能没有封装在里面，如果需要相关的功能需要进行二次开发。Three.js 与其他库的对比库名描述相比Three.jsBabylon.js是最好的 JavaScript 3D 游戏引擎，它能创建专业级三维游戏。主要以游戏开发和易用性为主Three.js 比较全面，而 Babylon.js 专注于游戏方面。Babylon.js 提供了对碰撞检测、场景重力、面向游戏的照相机，Three.js 本身不自带，需要依靠引入插件实现。对于 WebGL 的封装，双方做得各有千秋，Three.js 浅一些，好处是易于扩展，易于向更底层学习；Babylon.js 深一些，好处是易用，但扩展难度大一些。Three.js 的发展依靠社区推动，出来的比较早，发展比较成熟，Babylon.js 由微软公司在2013推出，文档和社区都比较健全，国内还不怎么火。PlayCanvas是一个基于 WebGL 游戏引擎的企业级开源 JavaScript 框架，它有许多的开发工具能帮你快速创建 3D 游戏PlayCanvas 的优势在于它有云端的在线可视化编辑工具。 PlayCanvas 的扩展性不如 Three.js。 最主要是 PlayCanvas 不完全开源，还商业付费。Cesium是国外一个基于 JavaScript 编写的使用 WebGL 的地图引擎，支持 3D、2D、2.5D 形式的地图展示，可以自行绘制图形，高亮区域。Cesium 是一个地图引擎，专注于 GIS，相关项目推荐使用它，其它项目还是算了。 至于库的扩展，其它的配套插件，以及周边的资源都不及Three.js。Three.js 在其库的扩展性，易用性以及功能方面有很好的优势。Three.js-master 源码目录结构build：里面含有 Three.js 构建出来的 JavaScript 文件，可以直接引入使用，并有压缩版；docs：Three.js 的官方文档；editor：Three.js 的一个网页版的模型编辑器；examples：Three.js 的官方案例，如果全都学会，必将成为大神；src：这里面放置的全是编译 Three.js 的源文件；test：一些官方测试代码，我们一般用不到；utils：一些相关插件；其他：开发环境搭建、开发所需要的文件，如果不对 Three.js 进行二次开发，用不到。使用Three.js第一个案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;第一个Three.js案例&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; canvas &#123; width: 100%; height: 100%; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;script src="https://cdn.bootcss.com/three.js/108/three.js"&gt;&lt;/script&gt; &lt;script&gt; //声明一些全局变量 var renderer, camera, scene, geometry, material, mesh; //初始化渲染器 function initRenderer() &#123; renderer = new THREE.WebGLRenderer(); //实例化渲染器 renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高 document.body.appendChild(renderer.domElement); //添加到dom &#125; //初始化场景 function initScene() &#123; scene = new THREE.Scene(); //实例化场景 &#125; //初始化相机 function initCamera() &#123; camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 ); //实例化相机 camera.position.set(0, 0, 15); &#125; //创建模型 function initMesh() &#123; geometry = new THREE.BoxGeometry(2, 2, 2); //创建几何体 material = new THREE.MeshNormalMaterial(); //创建材质 mesh = new THREE.Mesh(geometry, material); //创建网格 scene.add(mesh); //将网格添加到场景 &#125; //运行动画 function animate() &#123; requestAnimationFrame(animate); //循环调用函数 mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度 mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度 renderer.render(scene, camera); //渲染界面 &#125; //初始化函数，页面加载完成是调用 function init() &#123; initRenderer(); initScene(); initCamera(); initMesh(); animate(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack学习与总结]]></title>
    <url>%2Fposts%2F6e7939e6.html</url>
    <content type="text"><![CDATA[初识 Webpackwebpack 是模块打包工具，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。历史上先后出现一系列构建工具，它们各有其优缺点。由于前端工程师很熟悉 JavaScript ，Node.js 又可以胜任所有构建需求，所以大多数构建工具都是用 Node.js 开发的。下面来一一介绍它们。Npm ScriptNpm Script 是一个任务执行者。Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 package.json 文件里面使用 scripts 字段定义任务：123456&#123; "scripts": &#123; "dev": "node dev.js", "pub": "node build.js" &#125;&#125;里面的 scripts 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 dev 和 pub。 其底层实现原理是通过调用 Shell 去运行脚本命令，例如执行 npm run pub 命令等同于执行命令 node build.js。Npm Script的优点是内置，无须安装其他依赖。其缺点是功能太简单，虽然提供了 pre 和 post 两个钩子，但不能方便地管理多个任务之间的依赖。GruntGrunt 和 Npm Script 类似，也是一个任务执行者。Grunt 有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 Gruntfile.js 里，例如：1234567891011121314151617181920212223242526module.exports = function(grunt) &#123; // 所有插件的配置信息 grunt.initConfig(&#123; // uglify 插件的配置信息 uglify: &#123; app_task: &#123; files: &#123; 'build/app.min.js': ['lib/index.js', 'lib/test.js'] &#125; &#125; &#125;, // watch 插件的配置信息 watch: &#123; another: &#123; files: ['lib/*.js'], &#125; &#125; &#125;); // 告诉 grunt 我们将使用这些插件 grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); // 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务 grunt.registerTask('dev', ['uglify','watch']);&#125;;在项目根目录下执行命令 grunt dev 就会启动 JavaScript 文件压缩和自动刷新功能。Grunt的优点是：灵活，它只负责执行你定义的任务；大量的可复用插件封装好了常见的构建任务。Grunt的缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。Grunt 相当于进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足。GulpGulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5个方法就可以胜任几乎所有构建场景：通过 gulp.task 注册一个任务；通过 gulp.run 执行任务；通过 gulp.watch 监听文件变化；通过 gulp.src 读取文件；通过 gulp.dest 写文件。Gulp 的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：1234567891011121314151617181920212223242526272829303132// 引入 Gulpvar gulp = require('gulp'); // 引入插件var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');// 编译 SCSS 任务gulp.task('sass', function() &#123; // 读取文件通过管道喂给插件 gulp.src('./scss/*.scss') // SCSS 插件把 scss 文件编译成 CSS 文件 .pipe(sass()) // 输出文件 .pipe(gulp.dest('./css'));&#125;);// 合并压缩 JSgulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;);// 监听文件变化gulp.task('watch', function()&#123; // 当 scss 文件被编辑时执行 SCSS 任务 gulp.watch('./scss/*.scss', ['sass']); gulp.watch('./js/*.js', ['scripts']); &#125;);Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。WebpackWebpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。其官网的首页图很形象的画出了 Webpack 是什么，如下：一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。Webpack 具有很大的灵活性，能配置如何处理文件，大致使用如下：12345678module.exports = &#123; // 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块 entry: './app.js', output: &#123; // 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 filename: 'bundle.js' &#125;&#125;Webpack的优点是：专注于处理模块化的项目，能做到开箱即用一步到位；通过 Plugin 扩展，完整好用又不失灵活；使用场景不仅限于 Web 开发；社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。Webpack的缺点是只能用于采用模块化开发的项目。为什么选择 Webpack上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物，侧面反映出 Web 开发的发展趋势如下：在 Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入，用于简化流程；在 Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想的出现是为了简化文件转换的流程，例如将 ES6 转换成 ES5。在 Webpack 时代由于单页应用的流行，一个网页的功能和实现代码变得庞大，Web 开发向模块化改进。这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务，也可以相互搭配起来弥补各自的不足。 在了解这些常见的构建工具后，你需要根据自己的需求去判断应该如何选择和搭配它们才能更好地完成自己的需求。经过多年的发展， Webpack 已经成为构建工具中的首选，这是有原因的：大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。使用Webpack安装 Webpack 到本项目在开始给项目加入构建前， 在安装 Webpack 前请确保你的系统安装了5.0.0及以上版本的 Node.js。你还需要先新建一个 Web 项目，进入项目根目录执行 npm init 来初始化最简单的采用了模块化开发的项目；要安装 Webpack 到本项目，可按照你的需要选择以下任意命令运行：123456789# npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies# 安装最新稳定版npm i -D webpack# 安装指定版本npm i -D webpack@&lt;version&gt;# 安装最新体验版本npm i -D webpack@beta安装完后你可以通过这些途径运行安装到本项目的 Webpack：在项目根目录下对应的命令行里通过 node_modules/.bin/webpack 运行 Webpack 可执行文件。在 Npm Script 里定义的任务会优先使用本项目下的 Webpack，代码如下：123"scripts": &#123; "start": "webpack --config webpack.config.js"&#125;可以使用npx webpackNode 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。1npm install -g npxnpx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 webpack 而且全局没有安装 webpack。1npm install -D webpack一般来说，调用 webpack，只能在项目脚本和 package.json 的scripts字段里面， 如果想在命令行下调用，必须像下面这样。123# 项目的根目录下执行cd node_modules\.binwebpack --version # 输出 4.41.0npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。12# 项目的根目录下执行npx webpack --versionnpx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装。12&gt; $ npx create-react-app my-react-app&gt;上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。下载全局模块时，npx 允许指定版本。12&gt; $ npx uglify-js@3.1.0 main.js -o ./dist/main.js&gt;上面代码指定使用 3.1.0 版本的uglify-js压缩脚本。注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。12&gt; $ npx http-server&gt;参考：npx 使用教程安装 Webpack 到全局安装到全局后你可以在任何地方共用一个 Webpack 可执行文件，而不用各个项目重复安装，安装方式如下：1npm i -g webpack虽然介绍了以上两种安装方式，但是我们推荐安装到本项目，原因是可防止不同项目依赖不同版本的 Webpack 而导致冲突。### 使用 Webpack默认配置Webpack 在执行构建时默认会从项目根目录下的 webpack.config.js 文件读取配置，所以你还需要新建它，其内容如下：123456789101112const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;&#125;;由于 Webpack 构建运行在 Node.js 环境下，所以该文件最后需要通过 CommonJS 规范导出一个描述如何构建的 Object 对象。使用loaderWebpack 把一切文件看作模块，CSS 文件也不例外，Webpack 不原生支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制。Webpack的配置修改使用如下：123456789101112131415161718192021const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\.css$/, use: ['style-loader', 'css-loader?minimize'], &#125; ] &#125;&#125;;Loader 可以看作具有文件转换功能的翻译员，配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 .css 结尾的文件时先使用 css-loader 读取 CSS 文件，再交给 style-loader 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：use 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 css-loader?minimize 中的 minimize 告诉 css-loader 要开启 CSS 压缩。Webpack 构建前要先安装新引入的 Loader：1npm i -D style-loader css-loader给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入，以上的 Loader 配置可以修改为如下：123456789use: [ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true, &#125; &#125;]除了在 webpack.config.js 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 main.js 如下：1require('style-loader!css-loader?minimize!./main.css');这样就能指定对 ./main.css 这个文件先采用 css-loader 再采用 style-loader 转换。使用 Pluginplugin 可以在 webpack 运行到某一时刻的时候，帮你做一些事情。htmlWepackPluginnn 会在打包结束后，自动生成一个 html 文件，并把打包的生成的 js 自动引入到这个 html 文件中。1234567891011121314151617181920212223const HtmlWebpackPlugin = require("html-webpack-plugin"); //通过 npm 安装const webpack = require("webpack"); //访问内置的插件const path = require("path");const config = &#123; mode: "production", entry: "./src/index.js", output: &#123; filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125;, module: &#123; rules: [ &#123; test: /\.(png|jpg|gif)$/, use: "file-loader" &#125; ] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: "./src/index.html" &#125;)]&#125;;module.exports = config;使用 DevServerDevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。首先需要安装 DevServer：1npm i -D webpack-dev-server安装成功后执行 webpack-dev-server 命令， DevServer 就启动了，这时你会看到控制台有一串日志输出：12Project is running at http://localhost:8080/webpack output is served from /这意味着 DevServer 启动的 HTTP 服务器监听在 http://localhost:8080/ ，DevServer 启动后会一直驻留在后台保持运行，访问这个网址你就能获取项目根目录下的 index.html。 用浏览器打开这个地址你会发现页面空白错误原因是 ./dist/bundle.js 加载404了。 同时你会发现并没有文件输出到 dist 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。 由于 DevServer 不会理会 webpack.config.js 里配置的 output.path 属性，所以要获取 bundle.js的正确 URL 是 http://localhost:8080/bundle.js，对应的 index.html 应该修改为：12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;!--导入 DevServer 输出的 JavaScript 文件--&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Webpack 可以在启动 Webpack 时通过 webpack --watch 来开启监听模式，实时预览。Webpack 支持生成 Source Map，只需在启动时带上 --devtool source-map 参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。DevServer 还有一种被称作模块热替换的刷新技术。 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上 --hot 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。123const config=require('./webpack.config.js');const complier=wepack(config)// 在node中使用webpack的方法。核心概念Webpack 有以下几个核心概念。Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。Loader：模块转换器，用于把模块原内容按照需求转换成新内容。Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。webpack的配置Entryentry 是配置模块的入口，可抽象成输入， Webpack 执行构建的第 步将从入 口开始，搜寻及递归解析出所有入口依赖的模块。entry 配置是必填的，若不填则将导致 Webpack 报错、退出。contextWebpack 在寻找相对路径的文件时会以 context 为根目录， context 默认为执行启动Webpack 时所在的当前工作目录。如果想改变 context 的默认配置，则可以在配置文件里这样设置它123module.exports = &#123;context: path.resolve(__dirname,'app')&#125;loaderfile-loader就会拷贝到打包文件夹内1234567891011121314151617181920212223module.exports = &#123; mode: "development", entry: &#123; main: "./src/index.js" &#125;, module: &#123; rules: [ &#123; test: /\.jpg$/, use: &#123; loader: "file-loader", options: &#123; name: "[name].[ext]" &#125; &#125; &#125; ] &#125;, output: &#123; filename: "main.js", path: path.resolve(__dirname, "dist") &#125;&#125;;url-loader会变成 base64，在 js 文件中直接加载1234567891011121314151617181920212223242526const path = require("path");module.exports = &#123; mode: "development", entry: &#123; main: "./src/index.js" &#125;, module: &#123; rules: [ &#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: "url-loader", options: &#123; name: "[name].[ext]", outputPath: "images/", limit: 1024 &#125; &#125; &#125; ] &#125;, output: &#123; filename: "main.js", path: path.resolve(__dirname, "dist") &#125;&#125;;css-loader style-loaderWebpack 进阶Webpack 配置及案例Webpack 原理及脚手架]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程总结]]></title>
    <url>%2Fposts%2F9364fbab.html</url>
    <content type="text"><![CDATA[What is Object-oriented ProgrammingOOP是一种编程范例，或者编程风格，这是围绕对象而不是函数面向对象编程中的四个核心概念Encapsulation—封装 Abstraction—抽象 Inheritance—继承 Polymorphism—多态区别与面向过程编程改变了其中一个函数，然后其他几个函数可能就奔溃了，这就是我们说的意大利面条代码。 函数之间深层次的关联变成了各种问题的来源，OOP就应运而生。OOP 就一组相关的变量和函数组成合成一个单元，我们称之为对象(object)。把里面的函数称为方法，里面的变量称之为属性。最好的函数是那些没有参数的函数，参数个数越少，使用和维护就越简单。这就是封装！![1568869634914](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568869634914.png)多态意味着多种形态![1568873343511](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568873343511.png)使用封装重新组合的相关的变量和函数，这样可以减少复杂性，可以在程序的不同部分重用这些对象 或者在不同程序中，通过抽象，隐藏细节和复杂性，只显示必要性，这种技术降低了复杂性，也隔离了代码更改的影响。 继承让我们消除多余的代码 多态性可以避免写出复杂丑陋的选择性代码原型与原型继承原型Prototypes 和 原型继承Prototyical InheritanceJavaScript 中的类并不同于 Java 或者 c#中的类，因为 Javascript 是动态语言，所以类的本质上是更像是为了配合原型和原型继承所采取的必要的技术。1234567891011121314151617181920212223242526//使用字面量创建对象const circle = &#123;&#125;;//一个Javascript的对象实际上是一组键值对的集合//使用字面量语法来创建多个对象是有问题的，那就是对象的行为性，就像人一样可以做很多事就叫做行为性。//解决方法就是用工厂函数（factory）或者构造函数（constructor）//工厂函数function createCircle(radius) &#123; return &#123; radius, draw() &#123; console.log("draw"); &#125; &#125;;&#125;const circle2 = createCircle(1);// 构造函数function Circle(radius) &#123; this.radius = raius; this.draw = function() &#123; console.log("draw"); &#125;;&#125;const circle3 = new Circle(2);//当我们使用new操作符调用一个函数时，3件事发生了//首先new操作符创建了一个空对象，然后设置this指向这个对象，最后返回这个对象补充：字面量是变量的字符串表示形式。它不是一种值，而是一种变量记法。1234const a = 1; //1是字面量const b = "hello world"; //hello world是字面量const c = [1, 2, 3]; //[1,2,3]是字面量const d = &#123; foo: "bar" &#125;; //&#123;"foo":"bar"&#125;是字面量每个对象都有构造函数属性这个属性引用了用来创建这个对象的构造函数1234new String(); // ''," ",``new Boolean(); // true ,falsenew Number(); //1,2,3,4,5,6new Object(); //&#123;&#125;值类型复制值对象或者引用类型复制他们的引用123456789101112131415let number=10;function increase(number)&#123; number++;&#125;increase(number);console.log(number) //10let object=&#123;value:10&#125;;function increase(object)&#123;object.value++;&#125;increase(object);console.log(object) //&#123;value:11&#125;`不知道要访问的对象名称属性，是在运行时产生的，可以使用方括号的语法,或者属性名不符合命名规则时。抽象意味着我们应该隐藏细节和复杂部分，只显示或者暴露必要的部分123456789this.defaultLocaltion=&#123;x:0,y:1&#125; // ====&gt; let defaultLocaltion=&#123;x:0,y:1&#125;Object.defineProperty(this,'defaultLocaltion',&#123; get()&#123; return defaultLocaltion &#125;, set(value)&#123; defaultLocaltion=value &#125;&#125;)Javascript 中没有类，只有对象，那只有对象的时候如何引入继承？答案是原型。 原型可以理解为一个对象的父母，原型就是一般的对象。12345678const person = &#123; name: "hello" &#125;;Object.defineProperty(person, "name", &#123;writable: false,enumerable: true,configurable: false&#125;);delete person.name;console.log(person); // &#123; name: 'hello' &#125;获得对象原型的方法是调用 Object 对象的 getPrototypeOf 方法123456function Circle(radius) &#123; this.radius = radius;&#125;const circle = new Circle(1);Circle.prototype; //这是构造函数创建的对象的父母真身circle.__proto__ === Circle.prototype; // trueObject.keys 只返回实例的成员for-in 循环返回所有的成员，对象实例本身的和它的原型的在 Javascript 中，有个函数可以从给定的原型创建对象，就是 Object.create(第一个参数是用作创建的原型)Javascript 里每个对象都有一个构造函数属性，能返回用以创建这个对象的构造函数避免创建层级式继承关系，因为这十分脆弱。如果要用继承特性，最好维持在一级。好的组合胜过继承。Object.assign()可以用这个方法从一个对象拷贝所有成员到另外一个对象123456789101112131415161718192021222324252627282930 const canEat = &#123; eat: function() &#123; console.log("eating"); &#125; &#125;; const canWalk = &#123; walk: function() &#123; console.log("eating"); &#125; &#125;; const canSwin = &#123; swin: function() &#123; console.log("swining"); &#125; &#125;; // const person = Object.assign(&#123;&#125;, canEat, canWalk);// 空对象实际上变成了2个对象的组合 // console.log(person); function mixins(target, ...sources) &#123; Object.assign(target.prototype, ...sources); &#125; // function Person() &#123;&#125; // Object.assign(Person.prototype, canEat, canWalk); // console.log(new Person()); function Dog() &#123;&#125; mixins(Dog, canEat, canWalk); console.log(new Dog()); function GoldFish() &#123;&#125; mixins(GoldFish, canEat, canSwin); console.log(new GoldFish());ES6函数声明 funciton sayHello(){} 结尾不需要加分号，函数声明是置顶的。函数表达式const sayGoodbye=function(){} 结尾需要加分号，不会被置顶。不同于函数，类声明和类表达式都不会被置顶实例方法和静态方法1234567891011121314class Circle &#123; constructor(radius) &#123; this.radius = radius; &#125; // Instance Method draw() &#123;&#125; // Static Mthod static parse(str) &#123; const &#123; radius &#125; = JSON.parse(str); return new Circle(radius); &#125;&#125;const circle = Circle.parse('&#123;"radius":1&#125;');console.log("Go: circle", circle); // Go: circle Circle &#123; radius: 1 &#125;所以我们用静态方法的方式创建不属于具体实例的工具函数123456const c = new Circle(2);// Method callc.draw(); // Circle &#123; radius: 2 &#125;const draw = c.draw;// Function calldraw(); // undefinedES6 私有第一种是用在命名的时候加下划线第二种是使用 Symbol123456789101112131415const _radius = Symbol();const _draw = Symbol();// Symbol() 是一个函数，能创建一个Symbol，这个不是构造函数，不能在前面加new修饰符，这样会报错class Circle &#123; constructor(radius) &#123; this[_radius] = radius; &#125; [_draw]() &#123; // 计算生成属性 &#125;&#125;const c = new Circle(1);const key = Object.getOwnPropertySymbols(c)[0];console.log(c[key]); // 1第三种是使用 WeakMap12345678910111213141516171819const _radius = new WeakMap();const _move = new WeakMap();class Circle &#123; constructor(radius) &#123; _radius.set(this, radius); _move.set(this, () =&gt; &#123; // 箭头函数将从调用它的构造器继承过来，在这个构造器里。this是circle对象实例的引用。 // 当我们在构造器函数里使用箭头函数时，this不会重新绑定，也不会重设，直接从构造器继承 console.log("moving", this); &#125;); &#125; draw() &#123; _move.get(this)(); console.log("drawing..."); &#125;&#125;const c = new Circle(2);c.draw();getter&amp;&amp;setter方法重写12345678910111213class Shape &#123; move() &#123; console.log("moving...."); &#125;&#125;class Circle extends Shape &#123; move() &#123; super.move(); console.log("circle move"); &#125;&#125;const c = new Circle();AMD，也就是异步模块定义，主要是在浏览器程序中使用。CommonJSclass Circle{}module.exports.Circle=Circle只需要引入一个模块时，可以简化代码module.exports=Circle引入时，使用 require 函数。所以时 CommonJS 定义了 require 函数和 module 函数，这是 CommonJS 当中的语法。ES6export &amp;&amp; import在模块化之前，要记住一个首要原则，高度关联的东西应该放在一起。就好比在厨房放置了杯子盘子勺子等餐具，不应该把衣服存放在厨房，这就是高度关联。这就是编程中说的 Cohesion(内聚)。Webpacknpm i -g webpack-cliwebpack-cli initnpm init –yes完结]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapboxgl实现marker的聚类]]></title>
    <url>%2Fposts%2Fa2d9d205.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习与总结]]></title>
    <url>%2Fposts%2F3d0c447.html</url>
    <content type="text"><![CDATA[插值表达式v-cloakv-textv-htmlv-bind(缩写:)v-on(缩写@)v-model 只能用于表单元素v-forv-ifv-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换，v-show 较好，如果运行时条件不太可能改变 v-if 较好事件修饰符.stop 阻止冒泡.prevent 阻止默认事件.capture 添加事件侦听器时使用事件捕获模式.self 只当事件在该元素本身（比如不是子元素）触发时触发回调.once 事件只触发一次在Vue中使用样式使用class样式数组1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;数组中使用三元表达式1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;数组中嵌套对象1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;直接使用对象1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;使用内联样式直接在元素上通过 :style 的形式，书写样式对象1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt;将样式对象，定义到 data 中，并直接引用到 :style 中在data上定义样式：123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;在 :style 中通过数组，引用多个 data 上的样式对象在data上定义样式：1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125;在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;Vue指令之v-if和v-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；私有过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt;私有 filters 定义方式：12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125;使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;);注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！键盘修饰符以及自定义键盘修饰符通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名：1Vue.config.keyCodes.f2 = 113;使用自定义的按键修饰符：1&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;自定义指令使用 Vue.directive()定义全局的指令，比如 v-focus其中 参数 1：指令的名称，定义时不需要加 v-的前缀使用的时候必须在指令名称前面加上 v-前缀来调用参数 2：是一个对象，这个对象上有一些指令相关的函数，这些函数可以在特定的阶段执行相关的操作123456789101112131415Vue.dirctive('focus',&#123;bind:function(el)&#123; //每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次 //每个函数中的第一个参数永远是el表示被绑定的指令的那个元素，是原生的js对象 //每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次 // 和样式相关的操作，一般都可以在bind执行&#125;, inserted(el)&#123; el.focus(); // 和js行为相关的操作，最好在inserted中执行，防止js行为不生效 &#125;, updated(el)&#123; //当Vnode更新时，会执行updated，可能会触发多次 &#125;&#125;私有指令的定义123456dirctives:&#123; //自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 'fontsize':function (el,binding)&#123; el.style.fontSize=binding.value &#125; &#125;自定义指令的使用方式：1&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt;实现筛选的方式显示过滤-排序结果：筛选框绑定到 VM 实例中的 searchName 属性：123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去：12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;search 过滤方法中，使用 数组的 filter 方法进行过滤：123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125;JSONP的实现原理由于浏览器安全限制，不允许AXAJ访问协议不同、域名不同、端口号不同——不符合同源策略的。可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址。因为script标签不存在跨域限制，这种数据获取方式称之为JSONP具体实现过程先在客户端定义一个回调方法，预定义对数据的操作；再把这个回调方法的名称通过URL传参的形式提交到服务器的数据接口；服务器数据接口组织好要发送给客户端的数据，再拿客户端传递过来的回调方法名称拼接出一个调用这个方法的字符串，发送给客户端解析执行；客户端拿到服务器的返回的字符串之后，当作script脚本执行。Node.js 实现一个JSONP的请求例子1234567891011121314151617181920212223242526272829303132333435const http = require(&apos;http&apos;); // 导入解析 URL 地址的核心模块 const urlModule = require(&apos;url&apos;); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on(&apos;request&apos;, (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === &apos;/getjsonp&apos;) &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: &apos;zs&apos;, age: 22, gender: &apos;男&apos;, hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end(&apos;404&apos;); &#125; &#125;); server.listen(3000, () =&gt; &#123; console.log(&apos;server running at =http://127.0.0.1:3000&apos;); &#125;);Vue中的动画使用过渡类名HTML结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;VM 实例：123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;);定义两组类样式：12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125;使用第三方 CSS 动画库导入动画类库：1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;定义 transition 及属性：123456&lt;transition enter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt;使用动画钩子函数定义 transition 组件以及三个钩子函数：123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;定义三个 methods 钩子方法：12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = &apos;translateX(500px)&apos;; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = &apos;translateX(0px)&apos;; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125;定义动画过渡时长和样式：123.show&#123; transition: all 0.4s ease; &#125;v-for 的列表过渡定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt;定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;定义 VM中的结构：1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; txt: &apos;&apos;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = &apos;&apos;; &#125; &#125;&#125;);列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125;定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同：模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos; &#125;); Vue.component(&apos;login&apos;, login);直接使用 Vue.component 方法：123Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos; &#125;);将模板字符串，定义到script标签种：123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt;同时，需要使用 Vue.component 来定义组件：123Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos; &#125;);注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！组件中展示数据和响应事件在组件中，data需要被定义为一个方法，例如：12345678910111213Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos;, data() &#123; return &#123; msg: &apos;大家好！&apos; &#125; &#125;, methods:&#123; login()&#123; alert(&apos;点击了登录按钮&apos;); &#125; &#125; &#125;);在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问；组件切换vue 提供了 component，来展示对应的名称组件component 是一个占位符,:is 属性，可以用来指定展示的组件的名称父组件向子组件传值组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;这是父组件中的消息&apos; &#125;, components: &#123; son: &#123; template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;, props: [&apos;finfo&apos;] &#125; &#125; &#125;); &lt;/script&gt;使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt;子组件向父组件传值原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>编程</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构2——改善既有代码的设计]]></title>
    <url>%2Fposts%2Fb189f81a.html</url>
    <content type="text"><![CDATA[前言都能写出计算机可以理解代码，唯有写出人类容易理解的代码的，才是优秀的程序员。好代码的标准就是人们能否轻而易举地修改它重构的原则何谓重构重构这个词既可以是名词也可以是动词，名词形式的定义的是：对软件内部结构的调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。动词形式的定义的是：使用一系列的重构手法，在不改变可观察行为的前提下，调整其结构为何重构重构改进软件的设计重构时软件更容易理解重构帮助找到bug重构提高编程速度何时重构预备性重构：让添加的新功能更容易帮助理解的重构：使代码更容易理解捡垃圾式重构有计划的重构和见机行事的重构长期重构复审代码时重构何时不重构重写比重构还容易只有需要理解其工作原理时，对其重构才有价值。]]></content>
      <categories>
        <category>技术</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode中python代码输出中文乱码解决方法]]></title>
    <url>%2Fposts%2F87ed0839.html</url>
    <content type="text"><![CDATA[在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：先检查右下角编码集设置是否正确修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改在 json 中添加下列属性123"code-runner.executorMap": &#123;"python": "set PYTHONIOENCODING=utf8 &amp;&amp; python -u"&#125;https://mp.weixin.qq.com/s/QIJ-QHkxZUyKyQAPG49vPg]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo下next主题时出错]]></title>
    <url>%2Fposts%2F326cb881.html</url>
    <content type="text"><![CDATA[next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用在主题下的_config.yml文件中设置：使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。issue：https://github.com/rozbo/hexo-abbrlink/issues/19解决方法：https://github.com/foreveryang321/hexo-asset-image]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用总结]]></title>
    <url>%2Fposts%2F3c0dd009.html</url>
    <content type="text"><![CDATA[12345678910111213141516gitGraph:options&#123; "nodeSpacing": 150, "nodeRadius": 10&#125;endcommitbranch newbranchcheckout newbranchcommitcommitcheckout mastercommitcommitmerge newbranch12345678910111213141516gitGraph:options&#123; &quot;nodeSpacing&quot;: 150, &quot;nodeRadius&quot;: 10&#125;endcommitbranch newbranchcheckout newbranchcommitcommitcheckout mastercommitcommitmerge newbranch1234567gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划中 : des3, after des2, 5d1234567gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划中 : des3, after des2, 5d]]></content>
  </entry>
  <entry>
    <title><![CDATA[Threejs学习与总结10]]></title>
    <url>%2Fposts%2F456b67a9.html</url>
    <content type="text"><![CDATA[three.js-master 目录结构123456789101112131415161718192021three.js-master└───build——src目录下各个代码模块打包后的结果 │───three.js——开发的时候.html文件中要引入的threejs引擎库，和引入jquery一样，可以辅助浏览器调试 │───three.min.js——three.js压缩后的结构文件体积更小，可以部署项目的时候在.html中引入。 │└───docs——Three.js API文档文件 │───index.html——打开该文件可以实现离线查看threejs API文档 │└───editor——Three.js的可视化编辑器，可以编辑3D场景 │───index.html——打开应用程序 │└───docs——Three.js API文档文件 │───index.html——打开该文件可以实现离线查看threejs API文档 │└───examples——里面有大量的threejs案例，平时可以通过代码编辑全局查找某个API、方法或属性来定位到一个案例 │└───src——Three.js引擎的各个模块，可以通过阅读源码深度理解threejs引擎 │───index.html——打开该文件可以实现离线查看threejs API文档 │└───utils——一些辅助工具 │───\utils\exporters\blender——blender导出threejs文件的插件这就好比拍照，站在一个场景中，用相机拍照，咔嚓一下就是渲染操作，指定场景、相机作为参数。场景网格模型 Mesh几何体对象 Geometry材质对象 Material光照 Light平行光、环境光、点光源相机 Camera12// 设置相机指向(指向的场景对象)camera.lookAt(scene.position);渲染器 Renderer12// 设置背景颜色renderer.setClearColor(0xb9d3ff, 1);渲染器 render 方法three 动画程序一般选择 requestAnimationFrame 方法，而不是 setInterval()方法设置固定的刷新频率，也就是周期性执行时间。1234567891011graph LRA[设置材质效果] --&gt; C(材质类型)C --&gt; D(MeshBasicMaterial)D --&gt; D1(基础网格材质)D --&gt; D2(不受光照影响的材质)C --&gt; E(MeshLambertMaterial)E --&gt; E1(Lambert网格材质)E --&gt; E2(与光照有反应,漫反射)C --&gt; F(MeshPhongMaterial)F --&gt; F1(与光照有反应)F --&gt; F2(高光材质)going on]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + NexT 快速搭建博客]]></title>
    <url>%2Fposts%2Feba3f111.html</url>
    <content type="text"><![CDATA[安装安装 node.js如果你已经安装了 node.js，请忽略。访问node.js 官网，根据指引进行安装。安装 Git如果你已经安装了 Git，请忽略。访问Git 官网，根据指引进行安装。由于众所周知的原因，Windows 从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。安装 Hexo国内的朋友，因为众所周知的原因，从 npm 直接安装 hexo 会非常慢，所以你需要用到镜像源，参考上面的步骤，使用 cnpm 命令行工具代替默认的 npm: 在 windows 控制台（cmd）里输入并执行npm install -g cnpm --registry=https://registry.npm.taobao.org，然后安装 hexo: cnpm install -g hexo-cli国外的朋友，请直接打开 windows 控制台，输入npm install -g hexo-cli并执行。建站建立本地博客文件夹在命令行执行如下命令，其中&lt;folder&gt;为文件夹路径12hexo init &lt;folder&gt;cd &lt;folder&gt;所有有关hexo的命令 均要在&lt;folder&gt;路径下执行。建立好后文件夹目录如下123456789.├── _config.yml├── package.json├── .gitignore├── node_modules├── scaffolds├── source| ├── _posts└── themes其中_config.yml：站点的配置文件，可以在此配置大部分的参数。package.json：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。123456789101112131415161718&#123;"name": "hexo-site","version": "0.0.0","private": true,"hexo": &#123;"version": "3.9.0"&#125;,"dependencies": &#123;"version": "3.9.0""hexo-generator-archive": "^0.1.5","hexo-generator-category": "^0.1.3","hexo-generator-index": "^0.2.1","hexo-generator-tag": "^0.2.0","hexo-renderer-ejs": "^0.3.1","hexo-renderer-stylus": "^0.3.3","hexo-renderer-marked": "^1.0.1","hexo-server": "^0.3.3"&#125;scaffolds：模板文件夹，是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source：资源文件夹，存放用户资源的地方。除_posts文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes：主题文件夹。Hexo 会根据主题来生成静态页面。node_modules：node.js 模块，一些 插件 和 依赖 会被安装到这里。更加详细的解释请参考hexo 官方文档安装 NexT 主题进入本地博客文件夹并将 NexT 主题clone至themes文件夹下1git clone https://github.com/theme-next/hexo-theme-next themes/next你会看到，在next下也有一个_config.yml的文件，这是 NexT 主题的配置文件，为了区别它和 博客配置文件，下面会用带路径的文件名来描述它们：&lt;folder&gt;/_config.yml：站点配置文件next/_config.yml：主题配置文件启用 NexT 主题在&lt;folder&gt;/_config.yml里theme:选项填next，=&gt;theme: next，注意冒号后空一格。到这里，建站的任务就完成了。你现在可以打开控制台，输入并执行如下命令：1hexo g完成没有报错之后执行如下命令：1hexo s其中hexo g：新建public文件夹，并在其中生成网站静态文件（html，css，等文件）hexo s：启动 hexo 服务器，默认情况下，访问网址为：http://localhost:4000/更多有关 hexo 的命令，请参考hexo 官方文档的命令部分。你最后会看到控制台有如下输出：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.在浏览器地址栏输入http://localhost:4000/并访问，你应该会看到如下页面：&nbsp;**恭喜你！你已经完成了博客搭建的主要工作！接下来就是细节的配置了。请耐心阅读以下内容。**配置网站脚注12345678910111213141516171819202122footer: #建站时间 since: 2018 #作者头像并且是动画效果 icon: name: user animated: true color: "##66CDAA" #显示版权作者 copyright: aigisss 爱即是诗 #不显示Hexo powered: enable: false version: false #不显示主题和版本 theme: enable: false version: false #显示备案号 beian: enable: true icp: 赣ICP备18013338-1号版权声明1234creative_commons: license: by-nc-sa sidebar: false post: true代码块123456789codeblock: # 自定义边框半径，默认是1 # 值越大弧度越大 border_radius: 6 # 右上角显示复制按钮 copy_button: enable: true # 显示复制结果 show_result: true分享123456789101112131415161718needmoreshare2: enable: true postbottom: #文章底部 enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook #左下角悬浮按钮 float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook访问次数123456789101112# busuanzi统计busuanzi_count: enable: true # 总访客数 total_visitors: true total_visitors_icon: user # 总浏览量 total_views: true total_views_icon: eye # 文章浏览量 post_views: true post_views_icon: eye顶部阅读进度条1234reading_progress: enable: true color: "#37c6c0" height: 2px加载动画123456789101112131415161718192021222324motion: # 启用 enable: true # 异步加载 async: true transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut # 文章摘要动画 post_block: bounceIn # 加载各种页面动画（分类，关于，标签等等） post_header: fadeIn # 文章详情动画 post_body: fadeIn # coll_header: fadeIn # Only for Pisces | Gemini. # 侧边栏（人物头像的那部分） sidebar: fadeIn搜索功能NexT自带提供了两个搜索algolia_searchlocal_search其实这个local_search已经很好用了，配置algolia_search挺麻烦的，而且搜索功能也用的不多毕竟有万能的Ctrl + F123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false添加 RSS 订阅12345678910npm install hexo-generator-feed --save复制代码# Extensionsplugins: hexo-generate-feedfeed: # RSS订阅插件 type: atom path: atom.xml limit: 0 #0就是代表所有数学公式1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex还需要在文章的 Front-matter 里打开 mathjax 开关，比如：12345title: 使用hexo下next主题搭建博客的记录tags: 日常abbrlink: 326cb881date: 2019-09-09 09:58:21mathjax: true网上一大堆说会出现语义冲突—–类 Latex 格式书写的数学公式下划线_表示下标，有特殊的含义，如果被强制转换为&lt;em&gt;标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括*, {, }, \\等。但是！！在我试验下没有出现此类问题，只要在主题中打开，md 中申明 mathjax: true 就好了，可能在我使用的next6.7中解决了冲突。比如以下的公式能出来！1\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.$$12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$$$P = \frac{\sum_{i=1}^n (x_i- x)(y_i- y)}{\displaystyle \left[\sum_{i=1}^n (x_i-x)^2\sum_{i=1}^n (y_i-y)^2\right]^{1/2} }$$添加自定义菜单以新建「相册」菜单为例：在博客目录下的 source 文件夹下新建名为 photo 文件夹，然后在 photo 文件夹下新建一个 index.md 文件，然后在该文件填写：12345---title: 相册date: 2018-04-16 22:14:07type: "photo"---然后打开主题配置文件 _config.yml，在 menu 中添加：1234567menu: home: / || home archives: /archives || archive categories: /categories || th tags: /tags || tags #添加「相册」菜单 相册: /photo || camera这里的「相册」是博客中显示的菜单名称，紧跟的 photo 要和前面 index.md 文件的 type 值一致，|| 后面的菜单的图标，图标名称来自于 FontAwesome icon，若没有配置图标，默认会使用问号图标修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;参考Hexo+NexT 打造一个炫酷博客篇Ⅱ：NexT主题的配置和优化指南]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的操作记录]]></title>
    <url>%2Fposts%2Fd5d49586.html</url>
    <content type="text"><![CDATA[与服务器上的代码产生冲突如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:error: Your local changes to the following files would be overwritten by merge:protected/config/main.phpPlease, commit your changes or stash them before you can merge.如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:123git stashgit pullgit stash pop然后可以使用 git diff -w +文件名来确认代码自动合并的情况.反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:12git reset --hardgit pull其中 git reset 是针对版本,如果想针对文件回退本地修改,使用1git checkout HEAD file/to/restore辛辛苦苦加班一星期敲的代码没了过程是这样的，在终端输入 git log，列出所有的 commit 信息，如下图：commit 的信息很简单，就是做了 6 个功能，每个功能对应一个 commit 的提交，分别是 feature-1 到 feature-6。接下来执行了强制回滚，如下：1git reset --hard 2216d4e回滚到了 feature-1 上，并且回滚的时候加了–hard，导致之前 feature-2 到 feature-6 的所有代码全部弄丢了，现在 git log 的显示如下：现在 feature-2 到 feature-6 的代码没了。。。。。然鹅还没完，在这个基础上新添加了一个 commit 提交，信息叫 feature-7，如下图：现在 feature-2 到 feature-6 全没了，还多了一个 feature-7请问 如何把丢失的代码 feature-2 到 feature-6 全部恢复回来，并且 feature-7 的代码也要保留用git reflog和git cherry-pick就能解决在终端里输入：1git reflog然后就会展示出所有你之前git操作，你以前所有的操作都被git记录了下来，如下图：这时候要记好两个值：4c97ff3和cd52afc，他们分别是feature-7和feature-6的hash码。然后执行回滚，回到feature-6上：1git reset --hard cd52afc现在我们回到了feature-6上，如下图：我们回到了feature-6上，但是feature-7没了，如何加上来呢？这个时候就用上了git cherry-pick，刚刚我们知道了feature-7的hash码为4c97ff3，操作如下：1git cherry-pick 4c97ff3回车之后，你的feature-7的代码就回来了。期间可能会有一些冲突，按照提示解决就好。最后的结果如下图：feature-1 到 feature-7的代码就合并到了一起，以前的代码也都回来了。原文出自前端时光机]]></content>
      <categories>
        <category>编程</category>
        <category>更新中</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用coding-pages时出现静态文件丢失]]></title>
    <url>%2Fposts%2F372cd070.html</url>
    <content type="text"><![CDATA[出现这种情况，发现静态资源都加载不到，后来网上搜索了半天，才发现原来你要打算用 coding 的 pages 服务部署你的博客的话，你创建项目的名字必须和用户名保持一致，不能自己随便自定义。我重新创建了一个和用户名一致的项目，部署到他的 pages 服务，访问正常]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
