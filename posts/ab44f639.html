<!-- build time:Tue Oct 29 2019 00:15:15 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="AIGISSS" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="相机控制器Controls相机的基本内容我们已经了解。"><meta name="keywords" content="Threejs"><meta property="og:type" content="article"><meta property="og:title" content="Threejs学习和总结进阶篇"><meta property="og:url" content="https://blog.aigisss.com/posts/ab44f639.html"><meta property="og:site_name" content="AIGISSS"><meta property="og:description" content="相机控制器Controls相机的基本内容我们已经了解。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/sample-scene-threejs.jpg"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/c4b67350-8394-11e8-81ea-e357bbe10665"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/e7ead4e0-8396-11e8-a90b-215c3565b75a"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/f0138980-8398-11e8-81ea-e357bbe10665"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/88b97d60-839a-11e8-884a-35c5e2ab8361"><meta property="og:image" content="https://images.gitbook.cn/5411e080-8da8-11e8-b093-3f5eaa2cb071"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/316ee240-8e92-11e8-bfb3-8b3f110a427d"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/27172660-8e95-11e8-8ee0-a17ea463076e"><meta property="og:image" content="https://blog.aigisss.com/posts/ab44f639/d5f05ad0-9a20-11e8-8334-9bfa28241acd"><meta property="og:updated_time" content="2019-10-17T15:12:37.637Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Threejs学习和总结进阶篇"><meta name="twitter:description" content="相机控制器Controls相机的基本内容我们已经了解。"><meta name="twitter:image" content="https://blog.aigisss.com/posts/ab44f639/sample-scene-threejs.jpg"><link rel="canonical" href="https://blog.aigisss.com/posts/ab44f639"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>Threejs学习和总结进阶篇 | AIGISSS</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-147234769-1"></script><script>function gtag(){dataLayer.push(arguments)}var host=window.location.hostname;"localhost"!==host&&(window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-147234769-1"))</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">AIGISSS</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">爱即是诗</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-总部"><a href="http://www.aigisss.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>总部</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.aigisss.com/posts/ab44f639.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Gong"><meta itemprop="description" content="真正的伟大,即在于以脆弱的凡人之躯而具有神性的不可战胜。"><meta itemprop="image" content="/images/dog.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AIGISSS"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Threejs学习和总结进阶篇</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-09 22:53:35" itemprop="dateCreated datePublished" datetime="2019-10-09T22:53:35+08:00">2019-10-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-17 23:12:37" itemprop="dateModified" datetime="2019-10-17T23:12:37+08:00">2019-10-17</time> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/ab44f639.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/ab44f639.html" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="相机控制器Controls"><a href="#相机控制器Controls" class="headerlink" title="相机控制器Controls"></a>相机控制器Controls</h2><p>相机的基本内容我们已经了解。</p><p><img src="/posts/ab44f639/sample-scene-threejs.jpg" alt></p><a id="more"></a><p>正常的项目中，大家的需求都是不一样的，又通常会碰上需求中途改变的情况，我们之前做的简易版相机控制器很难满足此类项目对相机的操作需求。而且，造轮子的前提是当前的框架以及插件已经无法满足自身的需求时，才会考虑造轮子。要不然，项目的进度会被拖得很慢，甚至有可能因此而错过红利期。</p><p>好在 Three.js 官方和同道中的朋友们给我们提供了很多相关的插件，我们可以根据需求引入相关的插件来实现需求，本文我们就来看一下官方案例中提供的相机控制器。</p><p>从官网下载的代码包里可以发现有很多的相机控制器，文件夹地址为：<code>/examples/js/controls/</code>，里面的文件插件都是和控制相机和控制模型相关的插件，我们罗列一下相关插件：</p><ul><li>DeviceOrientationControls：陀螺仪相机控制器，实现移动端陀螺仪控制相机。</li><li>DragControls：控制鼠标拖拽移动物体的功能。</li><li>EditorControls：实现相机的旋转、缩放、平移功能，相对于 OrbitControls 的功能差不少，不建议使用。</li><li>FirstPersonControls：第一视角相机控制器。</li><li>FlyControls：飞行相机控制器。</li><li>OrbitControls：轨道控制器。</li><li>OrthographicTrackballControls：正交轨迹球控制器——正交相机使用的轨迹球控制器。</li><li>TrackballControls：轨迹球控制器——透视相机使用的轨迹球控制器。</li><li>PointerLockControls：鼠标锁定相机控制器。</li><li>TransformControls：控制模型位置、缩放、旋转的控制器。</li><li>VRControls：实现 VR 双屏相机控制器。</li></ul><p>由于篇幅有限，上面的控制器无法一一介绍，我们将重点介绍三种常用的相机控制器。</p><h3 id="OrbitControls"><a href="#OrbitControls" class="headerlink" title="OrbitControls"></a>OrbitControls</h3><p>OrbitControls 控制器是我们常用的相机控制器，它的功能丰富，使用简单，为大多数项目的使用插件。</p><h4 id="使用操作"><a href="#使用操作" class="headerlink" title="使用操作"></a>使用操作</h4><p>使用 OrbitControls 控制器我们可以实现旋转、缩放、平移等功能，下面简单列一下 OrbitControls 控制器的操作方法：</p><ul><li>围绕焦点旋转：使用鼠标左键拖拽；</li><li>放大和缩小：使用鼠标中键按住拖拽或者鼠标中键滑动滚轮；</li><li>平移相机：按住鼠标右键拖拽或者使用键盘的上下左右键。</li></ul><h4 id="控制器引入"><a href="#控制器引入" class="headerlink" title="控制器引入"></a>控制器引入</h4><p>在项目中使用 OrbitControls 控制器，可分为下面几步。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/OrbitControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机和渲染器的 Dom 对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.OrbitControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了一个最简单的 OrbitControls 控制器使用。</p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>OrbitControls 控制器最大的优势就是有丰富的配置项，供我们修改来实现项目中的需求，接下来我们看看有哪些属性配置。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">是否开启当前控制器，默认值是 True，如果设置为 False，将无法通过操作修改相机。</td></tr><tr><td align="left">target</td><td align="left">控制器的焦点位置，是一个 <code>THREE.Vector3</code> 对象，默认是 <code>(0, 0, 0)</code></td></tr><tr><td align="left">minDistance</td><td align="left">相机距离焦点的最近距离，默认值是0。 此属性适用于透视相机 PerspectiveCamera。</td></tr><tr><td align="left">maxDistance</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远）， 此属性适用于透视相机 PerspectiveCamera。</td></tr><tr><td align="left">minZoom</td><td align="left">相机距离焦点的最近距离，默认值是0，此属性适用于正交相机 OrthographicCamera。</td></tr><tr><td align="left">maxZoom</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远），此属性适用于正交相机 OrthographicCamera。</td></tr><tr><td align="left">minPolarAngle</td><td align="left">相机位置和焦点与焦点和最上方组成的最小夹角限制，默认值是0。</td></tr><tr><td align="left">maxPolarAngle</td><td align="left">相机位置和焦点与焦点和最上方组成的最大夹角限制，默认值是 Math.PI，也就是180度角。</td></tr><tr><td align="left">minAzimuthAngle</td><td align="left">当前相机沿水平方向顺时针旋转的弧度，默认值是 <code>- Infinity</code>。</td></tr><tr><td align="left">maxAzimuthAngle</td><td align="left">当前相机沿水平方向逆时针旋转的弧度，默认值是 <code>Infinity</code>。</td></tr><tr><td align="left">enableDamping</td><td align="left">是否开启拖拽惯性移动，即拖拽停止相机会有缓慢停止的距离移动，默认值是 False。</td></tr><tr><td align="left">dampingFactor</td><td align="left">拖拽惯性移动的阻力，默认值是 0.25。</td></tr><tr><td align="left">enableZoom</td><td align="left">是否开启缩放操作，默认值是 True。</td></tr><tr><td align="left">zoomSpeed</td><td align="left">缩放速度，默认值是 1.0。</td></tr><tr><td align="left">enableRotate</td><td align="left">是否开启相机绕焦点旋转操作，默认值是 True。</td></tr><tr><td align="left">rotateSpeed</td><td align="left">旋转速度，默认值是 1.0。</td></tr><tr><td align="left">enablePan</td><td align="left">是否开启相机平移操作，默认值是 True。</td></tr><tr><td align="left">panSpeed</td><td align="left">平移的速度，默认值是 1.0。</td></tr><tr><td align="left">screenSpacePanning</td><td align="left">修改相机平移的方向，默认值是 False，即沿 x 轴正负方向和 y 轴正负方向移动。可选值是 True，可以修改为沿 x 轴正负方向和 y 轴正负方向移动。</td></tr><tr><td align="left">keyPanSpeed</td><td align="left">键盘上下左右键移动相机的速度，默认值是 7.0。</td></tr><tr><td align="left">autoRotate</td><td align="left">当前相机是否自动旋转，默认值是 False，不自动旋转。</td></tr><tr><td align="left">autoRotateSpeed</td><td align="left">自动旋转的速度，默认值是 2.0，即渲染满60帧的情况下30秒旋转360度。</td></tr><tr><td align="left">enableKeys</td><td align="left">是否开启键盘控制先机平移，默认值是 True。</td></tr></tbody></table><p>OrbitControls 控制器的属性配置介绍完了，我们看看 OrbitControls 控制器还有那些方法。</p><h5 id="update"><a href="#update" class="headerlink" title="update()"></a><strong>update()</strong></h5><p>OrbitControls 控制器更新相机的方法，需要在每一帧里面调用。</p><h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a><strong>reset()</strong></h5><p>重置方法，相机回到初始位置。</p><h5 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a><strong>dispose()</strong></h5><p>销毁当前实例化的 OrbitControls 控制器。</p><h5 id="change-回调"><a href="#change-回调" class="headerlink" title="change 回调"></a><strong>change 回调</strong></h5><p>我们还可以监听相机改变回调，如果控制器修改了相机，将会产生一个回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    console.log(&quot;相机动了！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我附上 OrbitControls 控制器案例：</p><ul><li>[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/OrbitControls.html)</li></ul><p>也可以从这里获取案例源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/OrbitControls.html)</li></ul><h3 id="TrackballControls"><a href="#TrackballControls" class="headerlink" title="TrackballControls"></a>TrackballControls</h3><p>TrackballControls 控制器比 OrbitControls 控制器更自由，TrackballControls 控制器能够沿焦点进行球形旋转，没有死角，但比 OrbitControls 控制器少一些相关的功能配置。如何选择使用它们还是看项目需求，接下来还是先看如何操作。</p><p>注意，透视相机和正交相机使用的不是一个插件，此插件为透视相机使用，如果是正交相机请使用 OrthographicTrackballControls。</p><h4 id="使用操作-1"><a href="#使用操作-1" class="headerlink" title="使用操作"></a>使用操作</h4><p>使用 TrackballControls 控制器我们可以实现旋转、缩放、平移等功能，下面说一下如何使用 TrackballControls 控制器进行操作：</p><ul><li>围绕焦点旋转：使用鼠标左键拖拽；</li><li>放大和缩小：使用鼠标中键按住拖拽或者鼠标中键滑动滚轮；</li><li>平移相机：按住鼠标右键拖拽或者使用键盘的上下左右键。</li></ul><p>TrackballControls 控制器和 OrbitControls 控制器的操作相同，没什么可说的。</p><h4 id="控制器引入-1"><a href="#控制器引入-1" class="headerlink" title="控制器引入"></a>控制器引入</h4><p>在项目中使用 TrackballControls 控制器和 OrbitControls 控制器的方法雷同，分为下面几步。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/TrackballControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机和渲染器的 Dom 对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.TrackballControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h4><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">是否开启当前控制器，默认值是 True，如果设置为 False，将无法通过操作修改相机。</td></tr><tr><td align="left">rotateSpeed</td><td align="left">控制相机旋转速度，默认值是 3.0。</td></tr><tr><td align="left">zoomSpeed</td><td align="left">控制相机缩放速度，默认值是 1.2。</td></tr><tr><td align="left">panSpeed</td><td align="left">控制相机平移速度，默认值是 0.3。</td></tr><tr><td align="left">noRotate</td><td align="left">关闭相机旋转，默认 False，开启。</td></tr><tr><td align="left">noZoom</td><td align="left">关闭相机缩放，默认 False，开启。</td></tr><tr><td align="left">noPan</td><td align="left">关闭相机移动，默认 False 开启。</td></tr><tr><td align="left">staticMoving</td><td align="left">关闭拖拽惯性移动 默认值 False，开启。</td></tr><tr><td align="left">dynamicDampingFactor</td><td align="left">拖拽惯性移动阻力，默认值是 0.2。</td></tr><tr><td align="left">minDistance</td><td align="left">相机距离焦点的最近距离，默认值是 0。</td></tr><tr><td align="left">maxDistance</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远）。</td></tr></tbody></table><p>相对于 OrbitControls 控制器，TrackballControls 控制器的属性少一些，但是相关的功能还是比较全面的。TrackballControls 控制器的方法也和 OrbitControls 控制器的方法雷同。</p><h5 id="update-1"><a href="#update-1" class="headerlink" title="update()"></a><strong>update()</strong></h5><p>TrackballControls 控制器更新相机的方法，需要在每一帧里面调用。</p><h5 id="reset-1"><a href="#reset-1" class="headerlink" title="reset()"></a><strong>reset()</strong></h5><p>重置方法，相机回到初始位置。</p><h5 id="dispose-1"><a href="#dispose-1" class="headerlink" title="dispose()"></a><strong>dispose()</strong></h5><p>销毁当前实例化的 TrackballControls 控制器。</p><h5 id="change-回调-1"><a href="#change-回调-1" class="headerlink" title="change 回调"></a>change 回调</h5><p>我们还可以监听相机改变回调，如果控制器修改了相机，将会产生一个回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    console.log(&quot;相机动了！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，附上 TrackballControls 控制器案例：</p><ul><li>[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/TrackballControls.html)</li></ul><p>也可以从这里获取案例源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/TrackballControls.html)</li></ul><h3 id="DeviceOrientationControls"><a href="#DeviceOrientationControls" class="headerlink" title="DeviceOrientationControls"></a>DeviceOrientationControls</h3><p>最后，我们介绍的这个控制器只兼容含有陀螺仪的移动端。DeviceOrientationControls 控制器可以通过获取设备的陀螺仪状态来控制相机的朝向。</p><p>如果你还对陀螺仪不了解，<a href="https://blog.csdn.net/qq_30100043/article/details/73323617" target="_blank" rel="noopener">请点击查看这里</a>，在这里不多说。</p><p>DeviceOrientationControls 的内容配置较少，我们先看一下案例。</p><p>使用手机打开网址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/DeviceOrientationControls.html) ，然后手机朝下然后移动，你会发现能够通过手机的转向来控制相机的朝向，是不是很神奇。接下来我们看看如何引入到项目中。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/DeviceOrientationControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.DeviceOrientationControls(camera);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了对 DeviceOrientationControls 控制器的添加。</p><p>DeviceOrientationControls 控制器相关的配置也很少，只有一个 Enabled 属性，设置为 True，则控制器会更新相机的位置，反之，设置 False 将无法更新相机位置。</p><p>还有一个方法就是销毁当前控制器的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">controls.dispose(); //销毁当前控制器</span><br></pre></td></tr></table></figure><p>最后，附上源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/DeviceOrientationControls.html)</li></ul><h2 id="模型加载Loaders"><a href="#模型加载Loaders" class="headerlink" title="模型加载Loaders"></a>模型加载Loaders</h2><p>现在市面上的 3D 模型有上百种，每一种格式都有不同的用途，不同的功能和复杂程度。尽管 Three.js 提供了很多的加载器，但选择正确的格式和工作流程将为以后的工作节省大量时间和成本。而且某些格式难以使用，效率低下，甚至有些目前还未完全被支持。</p><h3 id="推荐使用的模型格式"><a href="#推荐使用的模型格式" class="headerlink" title="推荐使用的模型格式"></a>推荐使用的模型格式</h3><p>官方推荐我们使用的 3D 模型的格式为 glTF，由于 glTF 专注于传输，因此它的传输和解析的速度都很快。glTF 模型的功能包括网格、材质、纹理、蒙皮、骨骼、变形动画、骨骼动画、灯光以及相机。</p><p>如果当前的首选不是 glTF 格式，那么推荐使用 Three.js 定期维护并且流行的格式 FBX、OBJ 或者 COLLADA 格式，Three.js 也有自己独有的 JSON 格式。我们接下来将介绍这五种格式。</p><h3 id="Three-js-的-JSON-格式"><a href="#Three-js-的-JSON-格式" class="headerlink" title="Three.js 的 JSON 格式"></a>Three.js 的 JSON 格式</h3><p>这里的 JSON 格式指的是 Three.js 可以将其转换为场景 3D 对象的 JSON 格式模型。这种格式内部一般必有的四项为：</p><ul><li>metadata：当前模型的相关信息以及生成的工具信息；</li><li>geometries：存储当前模型所使用的几何体的数组；</li><li>materials：存储当前模型所使用的材质的数组；</li><li>object：当前模型的结构以及标示所应用到的材质和几何体标示。</li></ul><p>所有的模型网格，几何体和材质都有一个固定的 UUID 标识符，在 JSON 格式中均通过 UUID 引用。</p><h4 id="3D-对象转成-JSON"><a href="#3D-对象转成-JSON" class="headerlink" title="3D 对象转成 JSON"></a>3D 对象转成 JSON</h4><p>所有的 <code>THREE.Object3D</code> 对象都可以转成 JSON 字符串保存成为文件，但我们不能直接将对象转成 JSON，因为 JSON 无法保存函数。Three.js 给我们提供了一个 toJSON() 的方法来让我们将其转换为可存储的 JSON 格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = scene.toJSON(); //将整个场景的内容转换成为 JSON 对象</span><br><span class="line">var obj = group.toJSON(); //将一个模型组转成 JSON 对象</span><br><span class="line">var obj = mesh.toJSON(); //将一个模型网格转成 JSON 对象</span><br><span class="line">var JSONStr = JSON.stringify(obj); //将 JSON 对象转换成 JSON 字符串</span><br></pre></td></tr></table></figure><p>按照这种方式，我们就可以将生成的场景模型保存为文件。</p><h4 id="使用-ObjectLoader-加载-JSON-模型"><a href="#使用-ObjectLoader-加载-JSON-模型" class="headerlink" title="使用 ObjectLoader 加载 JSON 模型"></a>使用 ObjectLoader 加载 JSON 模型</h4><p>这里我们将使用到 Three.js 内置的对象 <code>THREE.ObjectLoader</code> 加载模型。</p><p>直接加载 Three.js 生成的 JSON 对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = scene.toJSON(); //将整个场景的内容转换成为json对象</span><br><span class="line"></span><br><span class="line">let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象</span><br><span class="line">let scene = loader.parse(obj); //将json对象再转换成3D对象</span><br></pre></td></tr></table></figure><p>加载外部的 JSON 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象</span><br><span class="line"></span><br><span class="line">//加载模型，并在回调中将生成的模型对象添加到场景中</span><br><span class="line">loader.load(&quot;../js/models/json/file.json&quot;, function (group) &#123;</span><br><span class="line">    scene.add(group);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/ObjectLoader.html)。</p><p>案例的右上角有四个点击事件：</p><ul><li>添加模型：将在场景内随机生成一组立方体，每次都不相同。</li><li>导出模型：将场景内这一组立方体导出到本地 JSON 文件。</li><li>导入模型：可以选择将符合 JSON 文件作解析并导入到场景内。</li><li>加载模型：将加载服务器上面的一个 JSON 文件。</li></ul><p>案例代码地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/ObjectLoader.html)。</p><h3 id="glTF-格式文件导入"><a href="#glTF-格式文件导入" class="headerlink" title="glTF 格式文件导入"></a>glTF 格式文件导入</h3><p>glTF 格式的 3D 格式文件是官方推荐的使用格式，这种格式的文件我们可以在 Sketchfab 官网下载，这是一个国外比较知名的模型网站。</p><ul><li>下载地址：<a href="https://sketchfab.com/models?date=week&features=downloadable&sort_by=-likeCount&type=models" target="_blank" rel="noopener">点击这里</a>。</li></ul><p>我们可以在这里下载一些免费的 glTF 格式的模型。</p><p>我在官网上找了个不错的模型做了一个案例，[点击这里查看](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/GLTFLoader.html)。</p><p><img src="/posts/ab44f639/c4b67350-8394-11e8-81ea-e357bbe10665" alt="gltf"></p><p>模型加载的速度会有些慢，大家可以等待下便能够看到这个小汽车。</p><p>接下来我们便讲解一下加载 glTF 模型的流程。</p><ul><li>首先，将 GLTFLoader 加载器插件引入到页面，插件在官方包的 <code>/examples/js/loaders/</code> 文件夹中，一些文件的导入插件都在这个文件夹内，大家有兴趣可以研究一下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/GLTFLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后创建一个加载器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.GLTFLoader();</span><br></pre></td></tr></table></figure><ul><li>使用加载器加载模型，并调节一下模型大小在场景内展示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/gltf/scene.gltf&apos;, function (gltf) &#123;</span><br><span class="line">    gltf.scene.scale.set(.1,.1,.1);</span><br><span class="line">    scene.add(gltf.scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有时候我们可能不明白，我加载了一个模型，哪一部分是需要导入场景的模型呢？</p><p>这里我们可以先将解析的出来的模型对象打印一下，然后通过查看对象属性来了解导入场景内的对象，就比如 glTF 模型转换出来的对象的 scene 属性就是需要导入场景的对象，而 JSON 格式的模型是直接可以导入的对象。</p><p>模型加载案例源码：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/GLTFLoader.html)。</p><h3 id="FBX-模型导入"><a href="#FBX-模型导入" class="headerlink" title="FBX 模型导入"></a>FBX 模型导入</h3><p>FBX 最大的用途是，在诸如 Max、Maya、Softimage 等软件间进行模型、材质、动作和摄影机信息的互导，这样就可以发挥 Max 和 Maya 等软件的优势。可以说，FBX 是最好的互导方案。</p><p><img src="/posts/ab44f639/e7ead4e0-8396-11e8-a90b-215c3565b75a" alt="fbx"></p><p>接下来我们看一个 FBX 模型导入的案例，是我在网上下载的一个 FBX 格式的模型，导入到场景内的效果：[请点击这里查看](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/FBXLoader.html)。</p><p>接下来，我们看下它的实现过程。</p><p>首先我们需要导入 FBXLoader 插件，并且还需要额外增加一个解析二进制文件的插件 <code>inflate.min.js</code> ，不导入该文件的话，除了一些字符串存储的 FBX 格式，别的格式都会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/inflate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/loaders/FBXLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>创建 FBX 加载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FBXLoader();</span><br></pre></td></tr></table></figure><p>修改模型大小，并设置每个模型网格可以投射阴影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/fbx/file.fbx&apos;, function (fbx) &#123;</span><br><span class="line">    fbx.scale.set(.1,.1,.1);</span><br><span class="line">    fbx.traverse(function (item) &#123;</span><br><span class="line">       if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">           item.castShadow = true;</span><br><span class="line">           item.receiveShadow = true;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    scene.add(fbx);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就实现了 FBX 模型的导入。</p><p>案例源码地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/FBXLoader.html)。</p><h3 id="OBJ-格式模型导入"><a href="#OBJ-格式模型导入" class="headerlink" title="OBJ 格式模型导入"></a>OBJ 格式模型导入</h3><p>OBJ 文件是 3D 模型文件格式。由 Alias|Wavefront 公司为 3D 建模和动画软件 Advanced Visualizer 开发的一种标准，适合用于 3D 软件模型之间的互导，也可以通过 Maya 读写。</p><p>OBJ 文件是一种文本文件，可以直接用写字板打开进行查看和编辑修改，但不包含动画、材质特性、贴图路径、动力学、粒子等信息。</p><p>OBJ 文件的导出通常会和 MTL 格式一同导出，MTL 作为 OBJ 文件的附属文件，却有着 OBJ 文件需要的贴图材质，所以，我们通常使用时，将它们两个文件一同导入。</p><p><img src="/posts/ab44f639/f0138980-8398-11e8-81ea-e357bbe10665" alt="obj"></p><p>这是我使用官网提供的一个模型制作的一个案例，查看地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/OBJLoader.html)。</p><p>我们看下实现导入的过程。</p><p>首先，我们需要将 OBJLoader 插件和 MTLLoader 插件引入页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/OBJLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/loaders/MTLLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>实例化 MTLLoader ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建MTL加载器</span><br><span class="line">var mtlLoader = new THREE.MTLLoader();</span><br><span class="line">//设置文件路径</span><br><span class="line">mtlLoader.setPath(&apos;../js/models/obj/&apos;);</span><br></pre></td></tr></table></figure><p>如果有需要，我们还可以设置纹理文件夹地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置纹理文件路径</span><br><span class="line">mtlLoader.setTexturePath(&apos;../js/models/obj/&apos;);</span><br></pre></td></tr></table></figure><p>加载 MTL 文件，并在文件加载成功后，创建 OBJLoader 并设置对象应用当前的材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//加载mtl文件</span><br><span class="line">mtlLoader.load(&apos;female02.mtl&apos;, function (material) &#123;</span><br><span class="line">    //创建OBJ加载器</span><br><span class="line">    var objLoader = new THREE.OBJLoader();</span><br><span class="line">    //设置当前加载的纹理</span><br><span class="line">    objLoader.setMaterials(material);</span><br><span class="line">    objLoader.setPath(&apos;../js/models/obj/&apos;);</span><br><span class="line">    objLoader.load(&apos;female02.obj&apos;, function (object) &#123;</span><br><span class="line">        //添加阴影</span><br><span class="line">        object.traverse(function (item) &#123;</span><br><span class="line">            if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">                item.castShadow = true;</span><br><span class="line">                item.receiveShadow = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //缩放</span><br><span class="line">        object.scale.set(.3,.3,.3);</span><br><span class="line">        scene.add(object);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们再去加载 OBJ 文件，加载成功的文件就是可以导入到场景内的 3D 对象。</p><p>案例源码查看地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/OBJLoader.html)。</p><h3 id="COLLADA-模型导入"><a href="#COLLADA-模型导入" class="headerlink" title="COLLADA 模型导入"></a>COLLADA 模型导入</h3><p>COLLADA 是一个开放的标准，最初用于 3D 软件数据交换，由 SCEA 发起，现在则被许多著名厂家（如 Autodesk、XSI 等）支持。COLLADA 不仅仅可以用于建模工具之间的数据交换，也可以作为场景描述语言用于小规模的实时渲染。</p><p>COLLADA DOM 拥有丰富的内容用于表现场景中的各种元素，从多边形几何体到摄像机无所不包。我们可以通过 COLLADA DOM 库来进行场景文件的读取与处理操作。</p><p><img src="/posts/ab44f639/88b97d60-839a-11e8-884a-35c5e2ab8361" alt="collada"></p><p>上面是我写的一个模型导入案例，案例地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/ColladaLoader.html)。</p><p>我们看下实现步骤。</p><p>首先引入 ColladaLoader 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/ColladaLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>接着实例化 ColladaLoader 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.ColladaLoader();</span><br></pre></td></tr></table></figure><p>最后加载文件并调整文件大小，添加到场景内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/collada/elf.dae&apos;, function (collada) &#123;</span><br><span class="line"></span><br><span class="line">    //添加阴影</span><br><span class="line">    collada.scene.traverse(function (item) &#123;</span><br><span class="line">        if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">            item.castShadow = true;</span><br><span class="line">            item.receiveShadow = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //缩放</span><br><span class="line">    collada.scene.scale.set(5,5,5);</span><br><span class="line">    scene.add(collada.scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例源码查看：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/ColladaLoader.html)。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1. 如何知道，加载完成的模型需要将哪部分导入到场景？</strong></p><p>一般情况下都是将自身导入，比如 FBX，OBJ，JSON 等，还有一种，会在里面生成一个可导入 scene 属性，如 glTF 和 COLLADA 文件。如果导入哪部分你无法确定，你可以把模型对象打印到控制台查看，然后尝试往场景内导入。</p><p><strong>2.导入到场景内的模型无法查看，而且也没有报错，为什么？</strong></p><p>这种情况可能由多种情况造成的，一般主要有下面两种情况：</p><ul><li>模型太小或者太大，这种情况可以尝试放大一千倍或者缩小一千倍来查看效果。</li><li>模型的位置太偏，根本不在相机照射范围内，这种问题我们可以将模型居中到相机照射的焦点位置查看，如何居中我们将在后面的课中讲解。</li></ul><h2 id="Three-js-动画"><a href="#Three-js-动画" class="headerlink" title="Three.js 动画"></a>Three.js 动画</h2><p>动画一般可以分为两种：一种是变形动画，另一种是骨骼动画。下面，我们先介绍一下变形动画。</p><h3 id="变形动画"><a href="#变形动画" class="headerlink" title="变形动画"></a>变形动画</h3><p>变形动画，通过修改当前模型的顶点位置来实现。比如，一个动画需要变动十次才可以实现，那么我们需要为当前模型的每一个顶点定义每一次所在的位置，Three.js 通过这一次次的修改实现了动画的整个流程。</p><p>为了帮助大家更好地理解变形动画的实现与使用，我创建了一个案例，查看地址为：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/morphTargets.html)。</p><p>在这个案例的右上角，我们能发现两个可切换的拖拽条。这两个拖拽条对应的是两个变形目标数组，拖拽范围是0-1，即当前的变形目标对本体的影响程度。拖拽它们，可发现界面中的立方体也会跟随之变动，从而影响当前的立方体。接下来我讲解一下，该案例的实现过程。</p><p>首先，创建模型的几何体，并为几何体 morphTargets 赋值两个变形目标。morphTargets 是一个数组，我们可以为其增加多个变形目标。在给 morphTargets 添加变形目标时，需要为其定义一个名称和相关的顶点，这个顶点数据必须和默认的模型的顶点数据保持一致，设置完后，我们需要调用 geometry 的 <code>computeMorphNormals()</code> 进行更新，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);</span><br><span class="line"></span><br><span class="line">// 创建两个影响立方体的变形目标</span><br><span class="line">var cubeTarget1 = new THREE.BoxGeometry(2, 10, 2);</span><br><span class="line">var cubeTarget2 = new THREE.BoxGeometry(8, 2, 8);</span><br><span class="line"></span><br><span class="line">// 将两个geometry的顶点放入到立方体的morphTargets里面</span><br><span class="line">cubeGeometry.morphTargets[0] = &#123;name: &apos;target1&apos;, vertices: cubeTarget1.vertices&#125;;</span><br><span class="line">cubeGeometry.morphTargets[1] = &#123;name: &apos;target2&apos;, vertices: cubeTarget2.vertices&#125;;</span><br><span class="line">cubeGeometry.computeMorphNormals();</span><br></pre></td></tr></table></figure><p>然后，为当前模型设置材质，变形目标作为参数之一，可以使其变形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cubeMaterial = new THREE.MeshLambertMaterial(&#123;morphTargets: true, color: 0x00ffff&#125;);</span><br></pre></td></tr></table></figure><p>接着，将创建好的网格模型添加到场景中。这时可以在 mesh 对象中找到 morphTargetInfluences 配置项，它也是一个数组，和 geometry 的 morphTargets 相对应，主要用来设置当前变形目标对本体的影响度，默认值为0-1，0为不影响本体，1为完全影响本体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gui = &#123;</span><br><span class="line">    influence1:0.01,</span><br><span class="line">    influence2:0.01,</span><br><span class="line">    update : function () &#123;</span><br><span class="line">        cube.morphTargetInfluences[0] = gui.influence1;</span><br><span class="line">        cube.morphTargetInfluences[1] = gui.influence2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们就手动实现了一个变形动画。在这个过程中，我们发现，变形动画是由于不断修改变形目标对本体的影响度而产生的。我们可以通过这个原理实现其他变形动画。</p><p>案例代码查看地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节</a> animation/morphTargets.html)。</p><h3 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h3><p>实现骨骼动画，我们需要生成一个与模型相关的骨架。骨架中的骨骼与骨骼之间存在关联，模型的每一个要动的顶点需要设置影响它的骨骼以及骨骼对顶点的影响度。</p><p>和变形动画相比，骨骼动画更复杂一些，但又有更多的灵活性。使用变形动画，我们需要把所有的每一次的变动都存在一个顶点数组中，而骨骼动画，只需要设置骨骼的相关信息，就可以实现更多的动画。</p><p>下面我们看一个骨骼动画的简单案例：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/skeleton.html)</p><p><img src="https://images.gitbook.cn/5411e080-8da8-11e8-b093-3f5eaa2cb071" alt="skeleton"></p><p>这是官方提供的一个案例。我对其做了些简单修改，以显示出当前一个柱形图形的骨骼。实现起来比较复杂，我们需要先理解它是怎么实现的。</p><p>首先， 我们创建了一个圆柱几何体，通过圆柱的几何体每个顶点的 y 轴坐标位置来设置绑定的骨骼的下标和影响的程度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//遍历几何体所有的顶点</span><br><span class="line">for (var i = 0; i &lt; geometry.vertices.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    //根据顶点的位置计算出骨骼影响下标和权重</span><br><span class="line"></span><br><span class="line">    var vertex = geometry.vertices[i];</span><br><span class="line">    var y = (vertex.y + sizing.halfHeight);</span><br><span class="line"></span><br><span class="line">    var skinIndex = Math.floor(y / sizing.segmentHeight);</span><br><span class="line">    var skinWeight = (y % sizing.segmentHeight) / sizing.segmentHeight;</span><br><span class="line"></span><br><span class="line">    geometry.skinIndices.push(new THREE.Vector4(skinIndex, skinIndex + 1, 0, 0));</span><br><span class="line">    geometry.skinWeights.push(new THREE.Vector4(1 - skinWeight, skinWeight, 0, 0));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何体的 skinIndices 属性和 skinWeights 属性分别用来设置绑定的骨骼下标和权重（骨骼影响程度）。</p><p>相应的，我们需要一组相关联的骨骼。骨骼具有嵌套关系，才得以实现一个骨架。圆柱体比较简单，我们直接创建一条骨骼垂直嵌套的骨骼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bones = [];</span><br><span class="line"></span><br><span class="line">var prevBone = new THREE.Bone();</span><br><span class="line">bones.push(prevBone);</span><br><span class="line">prevBone.position.y = -sizing.halfHeight;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; sizing.segmentCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    var bone = new THREE.Bone();</span><br><span class="line">    bone.position.y = sizing.segmentHeight;</span><br><span class="line">    bones.push(bone); //添加到骨骼数组</span><br><span class="line">    prevBone.add(bone); //上一个骨骼定义为父级</span><br><span class="line">    prevBone = bone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建纹理时，我们还需要设置当前材质属性，并开启骨骼动画对其的修改权限，将材质的 skinning 属性设置为 true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lineMaterial = new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    skinning: true,</span><br><span class="line">    wireframe: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我们需要创建骨骼材质，并将模型绑定骨骼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mesh = new THREE.SkinnedMesh(geometry, [material, lineMaterial]);</span><br><span class="line">var skeleton = new THREE.Skeleton(bones); //创建骨架</span><br><span class="line">mesh.add(bones[0]); //将骨骼添加到模型里面</span><br><span class="line">mesh.bind(skeleton); //模型绑定骨架</span><br></pre></td></tr></table></figure><p>这样，我们就使用 Three.js 创建了一个简单的骨骼动画。使用 <code>dat.gui</code>，便于我们修改每一个骨骼的 poisition、rotation 和 scale 并查看对当前模型的影响。</p><p>案例的源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节</a> animation/skeleton.html)。</p><h3 id="两种动画的区别"><a href="#两种动画的区别" class="headerlink" title="两种动画的区别"></a>两种动画的区别</h3><p>变形动画主要用于精度要求高的动画，比如人物的面部表情。其优点是动画的展现效果很到位，缺点就是扩展性不强，只能执行设置好的相关动画。</p><p>骨骼动画主要用于精度要求相对低一些，但需要丰富多样的动画的场合，就比如人物的走动，攻击防御等动画，我们可以通过一套骨骼，修改相应骨骼的位置信息直接实现相应的效果。它没有变形动画的精度高，但可以实现多种多样的效果。</p><blockquote><p><strong>总结：</strong> 我们可以根据项目的需求来设置不同的动画，就比如一个人物模型，说话我们使用变形动画去实现，而肢体动作使用骨骼动画去实现。</p></blockquote><h3 id="导入模型动画"><a href="#导入模型动画" class="headerlink" title="导入模型动画"></a>导入模型动画</h3><p>在 Three.js 动画系统中，你可以为模型的各种属性设置动画，如骨骼动画，变形动画，以及材质的相关属性（颜色，透明度， 是否可见）。动画属性可以设置淡入淡出效果以及各种扭曲特效，也可以单独改变一个或多个对象上的动画影响程度和动画时间。</p><p>为了实现这些，Three.js 动画系统在2015年修改为了类似于 Unity 和虚幻引擎4的架构。接下来我们了解下这套动画系统的主要组件以及它们是如何协同工作的。</p><h4 id="动画片段（Animation-Clips）"><a href="#动画片段（Animation-Clips）" class="headerlink" title="动画片段（Animation Clips）"></a>动画片段（Animation Clips）</h4><p>在我们成功导入模型以后，如果模型拥有相关的动画属性，会在返回的模型数据中产生一个名为 animations 的数组，数组的每一个子项都是一个 AnimationClips 对象。</p><p>每一个单独 AnimationClips 对象相应的保存着模型的一个动画的数据，假如，如果模型网格是一个人物角色，第一个 AnimationClips 对象有可能保存的是人物走动的动画，第二个 AnimationClips 对象用于跳跃，第三个用于攻击动画等等。</p><h4 id="关键帧轨迹（Keyframe-Tracks）"><a href="#关键帧轨迹（Keyframe-Tracks）" class="headerlink" title="关键帧轨迹（Keyframe Tracks）"></a>关键帧轨迹（Keyframe Tracks）</h4><p>在 AnimationClips 对象内部，一般有四个属性：</p><ul><li>name：当前动画的名称；</li><li>uuid：一个不会重复的 uuid；</li><li>duration：当前动画一个循环所需要的时间；</li><li>tracks：轨迹，即当前动画每一次切换动作所需要的数据。</li></ul><p>假设当前的动画是骨骼动画，在关键帧轨迹中存储的数据是每一帧骨骼随着时间变动的数据（位置，旋转和缩放等）。</p><p>如果当前动画是一个变形动画，在关键帧轨迹中将会把顶点数据的变动存储在其中（比如实现人脸的笑以及哭等动作）。</p><h4 id="动画混合器（Animation-Mixer）"><a href="#动画混合器（Animation-Mixer）" class="headerlink" title="动画混合器（Animation Mixer）"></a>动画混合器（Animation Mixer）</h4><p>在动画片段中存储的数据仅仅构成了动画实现的基础，实际的播放权力在动画混合器的手中。你可以想象动画混合器其实不仅仅只是作为动画的播放器，它还可以同时控制几个动画，混合它们或者合并它们。</p><h4 id="动画播放器（Animation-Actions）"><a href="#动画播放器（Animation-Actions）" class="headerlink" title="动画播放器（Animation Actions）"></a>动画播放器（Animation Actions）</h4><p>这个英文我更乐意将它翻译成动画播放器，因为我们最终需要将数据生成一个动画播放器来操作当前的动画执行，暂停或者停止，是否使用淡入淡出效果或者将动画加快或减慢。</p><h4 id="动画对象组（Animation-Object-Groups）"><a href="#动画对象组（Animation-Object-Groups）" class="headerlink" title="动画对象组（Animation Object Groups）"></a>动画对象组（Animation Object Groups）</h4><p>如果你希望一组模型对象共享当前的动画，我们可以使用动画对象组来实现。</p><h3 id="通过导入模型显示动画"><a href="#通过导入模型显示动画" class="headerlink" title="通过导入模型显示动画"></a>通过导入模型显示动画</h3><p><img src="/posts/ab44f639/316ee240-8e92-11e8-bfb3-8b3f110a427d" alt="变形动画"></p><h4 id="变形动画-1"><a href="#变形动画-1" class="headerlink" title="变形动画"></a>变形动画</h4><p>我们首先查看一个官方的模型案例，这个案例是一匹马奔跑的动画，我们也可以通过下面地址查看：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/morphAnimation.html)。</p><p>接下来我们看一下这匹马是如何实现的。</p><ul><li>在模型加载成功以后，我们首先将模型创建出来，并将材质的 morphTargets 设置为 ture，使顶点数据信息可以受变形动画影响：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    vertexColors: THREE.FaceColors,</span><br><span class="line">    morphTargets: true</span><br><span class="line">&#125;));</span><br><span class="line">mesh.castShadow = true;</span><br><span class="line">mesh.scale.set(0.1, 0.1, 0.1);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><ul><li>然后我们创建了一个针对于该模型的混合器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixer = new THREE.AnimationMixer(mesh);</span><br></pre></td></tr></table></figure><ul><li>接着使用变形目标数据创建一个动画片段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clip = THREE.AnimationClip.CreateFromMorphTargetSequence(&apos;gallop&apos;, geometry.morphTargets, 30);</span><br></pre></td></tr></table></figure><ul><li>使用混合器和动画片段创建一个动画播放器来播放：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var action = mixer.clipAction(clip); //创建动画播放器</span><br><span class="line">action.setDuration(1); //设置当前动画一秒为一个周期</span><br><span class="line">action.play(); //设置当前动画播放</span><br></pre></td></tr></table></figure><ul><li>最后，我们还需要在重新绘制循环中更新混合器，进行动作更新：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line"></span><br><span class="line">    control.update();</span><br><span class="line"></span><br><span class="line">    var time = clock.getDelta();</span><br><span class="line">    //由于模型导入是异步的，所以我们再模型没有加载完之前是获取不到混合器的</span><br><span class="line">    if (mixer) &#123;</span><br><span class="line">        mixer.update(time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ab44f639/27172660-8e95-11e8-8ee0-a17ea463076e" alt="骨骼动画"></p><h4 id="骨骼动画-1"><a href="#骨骼动画-1" class="headerlink" title="骨骼动画"></a>骨骼动画</h4><p>骨骼动画模型，我们使用的是 gltf 格式，这个模型是在 Sketchfab 网站下载的，案例是一个小姐姐跳舞的片段，查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/skeletonAnimation.html)。</p><p>gltf 格式的模型导入进来后，我们可以直接通过 animations 数组创建播放器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixer = new THREE.AnimationMixer(obj); //通过当前模型创建混合器</span><br><span class="line">action = mixer.clipAction(gltf.animations[0]); //通过动画数据创建播放器</span><br></pre></td></tr></table></figure><p>直接调用播放器的播放事件让动画播放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.play();</span><br></pre></td></tr></table></figure><p>最后，我们还需要在循环渲染中更新混合器，并将每一帧渲染的间隔时间传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    var time = clock.getDelta();</span><br><span class="line">    if (mixer) &#123;</span><br><span class="line">        mixer.update(time);</span><br><span class="line">    &#125;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tween-js-补间动画"><a href="#Tween-js-补间动画" class="headerlink" title="Tween.js 补间动画"></a>Tween.js 补间动画</h2><h3 id="Tween-是什么"><a href="#Tween-是什么" class="headerlink" title="Tween 是什么"></a>Tween 是什么</h3><p>Tween.js 是 JavaScript 中一个简单的补间动画库，包含各种经典动画算法。Tween.js 支持数字对象的属性和 CSS 样式属性赋值，API 简单且强大，支持链式调用。</p><p>补间（动画）（来自 In-Between）是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这个过程需要多长时间，补间引擎将负责计算从起始点到结束点的值。</p><p>在 Three.js 中，我们有一些修改模型位置，旋转和缩放的需求，却无法直接在 WebGL 中使用 CSS3 动画来实现，而 Tween.js 恰好给我们提供了一个很好的解决方案。</p><p>比如我们要实现一个模型从 A 点到 B 点的位置移动，常规的实现方法，是使用 setInterval、requestAnimationFrame 手动计算出特定时间的位置点，很不易于管理与查看。而 Tween.js 可以自动根据起始点位置和动画时长计算出所有的位置点，可以很方便地对其进行获取和管理。</p><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>接下来，我们通过一个案例，带大家了解如何在 Three.js 应用中使用 Tween.js。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/simple.html)。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/simple.html)。</p></blockquote><p>本案例的开发思路是：首先获取目标模型的初始位置，然后实例化 Tween，接着设置目标位置，启动 Tween，在 TWEEN.onUpdate() 回调中改变目标模型的位置，从而实现目标模型从初始位置平滑移动到目标位置的动画。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//设置tween</span><br><span class="line">       var position = &#123;x:-40, y:0, z:-30&#125;;</span><br><span class="line">       tween = new TWEEN.Tween(position);</span><br><span class="line">       //设置移动的目标和移动时间</span><br><span class="line">       tween.to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br><span class="line">       //设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">       tween.onUpdate(function (pos) &#123;</span><br><span class="line">           cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>上面代码，首先创建一个 position 对象，存储了当前立方体的位置数据。然后，通过当前的对象创建了一个补间 tween。紧接着，设置每一个属性的目标位置，并告诉 Tween 在 2000 毫秒（动画时长）内移动到目标位置。最后，设置 Tween 对象每次更新的回调，即在每次数据更新以后，将立方体位置更新。</p><p>Tween 对象不会直接执行，需要我们调用 <code>start()</code> 方法激活，即 <code>tween.start()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个保存需求修改的数据对象。</span><br><span class="line">gui = &#123;</span><br><span class="line">    start:function () &#123;</span><br><span class="line">        tween.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>想要完成整个过程，我们还需要在每帧里面调用 <code>TWEEN.update</code>，来触发 Tween 对象更新位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line"></span><br><span class="line">    //更新Tween</span><br><span class="line">    TWEEN.update();</span><br><span class="line"></span><br><span class="line">    control.update();</span><br><span class="line"></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>链式调用可以简化大量代码，逻辑清晰集中，便于查看和修改。</p><p>Tween 插件也支持链式调用的方法，并且还会修改实例化时传入的对象，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//设置tween</span><br><span class="line">var position = &#123;x:-40, y:0, z:-30&#125;;</span><br><span class="line">tween = new TWEEN.Tween(position);</span><br><span class="line"></span><br><span class="line">//设置移动的目标和移动时间</span><br><span class="line">tween.to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br><span class="line"></span><br><span class="line">//设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">tween.onUpdate(function (pos) &#123;</span><br><span class="line">    cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以简化为链式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接链式实现tween</span><br><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br></pre></td></tr></table></figure><h3 id="Tween-对象方法"><a href="#Tween-对象方法" class="headerlink" title="Tween 对象方法"></a>Tween 对象方法</h3><h4 id="控制动画方法"><a href="#控制动画方法" class="headerlink" title="控制动画方法"></a>控制动画方法</h4><p>Tween 对象控制动画的方法主要包括开始、取消、重复等方法。</p><ul><li><code>.start()</code></li></ul><p>如果你想激活一个补间，请使用这个方法，调用方式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween.start();</span><br></pre></td></tr></table></figure><p><code>start()</code> 方法还接受一个时间参数，添加该参数后，补间不会立即被激活，Tween 动画将在延时该时间数后才开始动画。否则它将立刻开始动画，且在第一次调用 <code>TWEEN.update</code> 时开始计时。如果设置的时间已经小于计时的总时间，那计算出来的位置数据将是参数设置时间开始后，运行到的所在位置。</p><ul><li><code>.stop()</code></li></ul><p>这个方法刚好和 <code>start()</code> 方法对应，如果你想取消一个补间，直接调用这个方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween.stop();</span><br></pre></td></tr></table></figure><ul><li><code>.update()</code></li></ul><p>其实每个补间都有一个更新方法，只不过我们多会使用 <code>TWEEN.update</code> ，而不会单独调用它（见下方全局函数）。</p><ul><li><code>.chain()</code></li></ul><p>当你按顺序排列不同的补间时，例如当上一个补间结束时立即启动另外一个补间，我们称它为链式补间。关于链式补间的案例请见下面两个链接。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/chain.html)</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/chain.html)</p></blockquote><p>调用方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB);</span><br></pre></td></tr></table></figure><p>或者，采用一个无限的链式，即 tweenA 与 tweenB 无限循环，便可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB);</span><br><span class="line">tweenB.chain(tweenA);</span><br></pre></td></tr></table></figure><p>在其他情况下，您可能需要将多个补间链接到另一个补间，以使它们（链接的补间）同时开始动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB,tweenC);</span><br></pre></td></tr></table></figure><blockquote><p>警告：调用 <code>tweenA.chain（tweenB）</code> 实际上修改的是 tweenA，tweenB 总在 tweenA 完成时启动。<code>chain()</code> 的返回值只是 tweenA，不是一个新的 Tween。</p><p>链接多个补间时，比如 <code>tweenA.chain(tweenB, tweenC)</code> 表示 tweenA 动画结束后，tweenB 和 tweenC 动画同时开始，如果因 tweenB 和 tweenC 修改的属性相同，而存在冲突时，经测试写在后面的属性将是最终动画位置。</p><p>注意，一般不要让两个同时开始的补间存在属性冲突。</p></blockquote><ul><li><code>.repeat()</code></li></ul><p>如果想让一个补间永远重复，可以无限链接自己，但更好的方法是使用 <code>repeat()</code> 方法。它接受一个参数，描述第一个补间完成后需要重复多少次，如下代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.repeat(10); // 循环10次</span><br><span class="line">tween.repeat(Infinity); // 无限循环</span><br></pre></td></tr></table></figure><p>我们可以将案例中 <code>simple.html</code> 文件里面的调用改成无限循环，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000).repeat(Infinity);</span><br></pre></td></tr></table></figure><ul><li><code>.yoyo()</code></li></ul><p>该方法只有在补间使用 <code>repeat()</code> 方法时才会被调用。我们调用 <code>yoyo()</code> 以后，位置的切换就变成了从头到尾，从尾到头这样的循环过程。</p><p>单个补间无限从头到尾的循环，可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000).repeat(Infinity).yoyo(true);</span><br></pre></td></tr></table></figure><p>进一步了解 <code>yoyo()</code>方法的使用，可查看下面案例。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/repeat.html)。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/repeat.html)。</p></blockquote><ul><li><code>.delay()</code></li></ul><p>这个方法用于控制激活前的延时，即触发 <code>start()</code> 事件后，需要延时到设置的 delay 时间，才会真正激活，使用方法见下面代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.delay(1000);</span><br><span class="line">tween.start();</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>Tween 每次的位置更新后，都会触发 onUpdate 回调函数，我们可以在此回调中修改模型位置。</p><p>在之前案例的 <code>simple.html</code> 中，我们在每次更新回调中获取更新后的位置信息并修改模型几何体的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">tween.onUpdate(function (pos) &#123;</span><br><span class="line">    cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>目前，补间支持的回调函数主要有以下几种。</p><ul><li>onStart</li></ul><p>在补间计算开始前的回调，每个补间只能触发一下，即使使用 <code>repeat()</code> 方法循环，这个回调也只被触发一次。</p><ul><li>onStop</li></ul><p>通过调用 <code>stop()</code> 方法停止的补间会触发当前回调，如果是正常完成的补间将不会触发此回调。</p><ul><li>onUpdate</li></ul><p>每次补间更新后，我们可以在此回调中获取更新后的值。</p><ul><li>onComplete</li></ul><p>当补间正常完成时，将会触发此回调。通过使用 <code>stop()</code> 停止的补间将不会触发此回调。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 Three.js 中使用 Tween.js，能够很方便地改变模型的位置，不需要手动计算，便能获取到具体的位置数据，以实现我们的需求。</p><h2 id="Three-js-场景交互"><a href="#Three-js-场景交互" class="headerlink" title="Three.js 场景交互"></a>Three.js 场景交互</h2><p>浏览器是一个 2D 视口，而 Three.js 展示的是 3D 场景。场景交互时，需要在二维平面中控制三维场景的模型，那如何将 2D 视口的 x 和 y 坐标转换成 Three.js 场景中的 3D 坐标呢？</p><p>好在 Three.js 已经有了解决相关问题的方案，那就是 <code>THREE.Raycaster</code> 射线，用于鼠标拾取（计算出鼠标移过的三维空间中的对象）等。我们看下面这张图片：</p><p><img src="/posts/ab44f639/d5f05ad0-9a20-11e8-8334-9bfa28241acd" alt="raycaster"></p><p>我们一般都会设置三维场景的显示区域，如果指明当前显示的 2D 坐标给 <code>THREE.Raycaster</code>，它将生成一条从显示起点到终点的射线，也就是射线与近视面交点和射线与远视面交点连成的这一条直线。在相机视角下查看，只是一个点，射线会穿过整个显示场景，并按从近到远的顺序返回与模型相交的数据。</p><h3 id="THREE-Raycaster-构造函数和对象方法"><a href="#THREE-Raycaster-构造函数和对象方法" class="headerlink" title="THREE.Raycaster 构造函数和对象方法"></a>THREE.Raycaster 构造函数和对象方法</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.Raycaster( origin, direction, near, far );</span><br></pre></td></tr></table></figure><p>该实例化函数 Raycaster 包含了四个参数。</p><ul><li>origin：光线投射的原点矢量；</li><li>direction：光线投射的方向矢量，应该是被归一化的；</li><li>near：投射近点，用来限定返回比 near 要远的结果。near 不能为负数，缺省为 0；</li><li>far：投射远点，用来限定返回比 far 要近的结果。far 不能比 near 小，缺省为无穷大。</li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>THREE.Raycaster</code> 的属性可以在实例化对象后有修改需求时再修改。除了上面提到的 origin、direction、near、far 四个属性外，我们还有可能用到另一个属性：</p><ul><li>linePrecision：射线和线相交的精度，浮点数类型的值。</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>THREE.Raycaster</code> 给我们提供了一系列的方法，比如修改射线的位置，判断与某些模型是否相交等，接下来我们列举一些经常使用的方法。</p><ul><li><code>.set()</code>：此方法可以重新设置射线的原点和方向，从而更新射线位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.set（origin，direction）</span><br></pre></td></tr></table></figure><p>其中，参数 origin 用来设置射线新的原点矢量位置，direction 用来设置基于原点位置的射线的方向矢量。</p><ul><li><code>.setFromCamera()</code>：使用当前相机和界面的 2D 坐标设置射线的位置和方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setFromCamera ( coords, camera )</span><br></pre></td></tr></table></figure><p>参数 coords 表示鼠标的二维坐标，在归一化的设备坐标（NDC）中，也就是 X 和 Y 分量，应该介于 -1 和 1 之间。camera 表示射线起点处的相机，即把射线起点设置在该相机位置处。</p><p>点击事件大多通过鼠标触发，我们用鼠标点击显示区域的位置和当前场景使用的相机对象调用此对象，Three.js 会为我们计算出当前射线的位置。</p><ul><li><code>.intersectObject ()</code> 和 <code>.intersectObjects ()</code></li></ul><p>两个方法用来检查射线和物体之间的所有交叉点数据。</p><p>如果检测射线和一个对象是否相交，推荐使用 <code>intersectObject()</code>，如果判断的是这个对象的子对象，那推荐使用 <code>intersectObjects()</code>，将 3D 对象的 children 属性传入。</p><p>返回值是一个交叉点对象数组，且按距离排序，最接近的排在首位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.intersectObject ( object, recursive, optionalTarget)</span><br></pre></td></tr></table></figure><p>参数 object，用来检测和射线相交的物体。如果 recursive 设置为 true，还会向下继续检查所有后代，否则只检查该对象本身，缺省值为 false。optionalTarget 为可选参数，用于设置放置结果的数组，如果缺省，则将会实例化一个新数组，并将获取到的数据放入其中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.intersectObjects ( array, recursive, optionalTarget)</span><br></pre></td></tr></table></figure><p><code>intersectObject()</code> 和 <code>intersectObjects()</code> 的区别在于第一个参数。intersectObject 的第一个参数为 3D 对象，而 intersectObjects 需要传入一个由 3D 对象组成的数组。</p><p><strong>我们知道两个方法的返回值均为对象数组。接下来，我们再进一步了解下这个返回值。</strong></p><p>如果射线与场景内的模型没有相交，将返回一个空数组，否则，将返回一个按从近到远顺序排列的对象数组，数组中每个对象的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; distance, point, face, faceIndex, indices, object &#125;, ... ]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>distance：射线的起点到相交点的距离；</li><li>point：在世界坐标中的交叉点；</li><li>face：相交的面；</li><li>faceIndex：相交的面的索引；</li><li>indices：组成相交面的顶点索引；</li><li>object：相交的对象。</li></ul><p>当一个网孔（Mesh）对象和一个缓存几何模型（BufferGeometry）相交时，faceIndex 将是 undefined，并且 indices 将被设置；而当一个网孔（Mesh）对象和一个几何模型（Geometry）相交时，indices 将是 undefined。</p><p>当计算这个对象是否和射线相交时，Raycaster 把传递的对象委托给检测 3D 对象的 raycast 方法，该方法通过计算，检测出当前模型与射线是否相交。</p><p>这允许 Mesh 对光线投射的反应可以不同于 lines 和 pointclouds。Mesh、lines、pointclouds 是三种不同的计算相交的方法。Mesh 对射线与网格对象的每一个面进行相交判断。lines，则是判断两条线之间的距离，至于 pointclouds，则是通过 distanceSqToPoint 判断当前是否相交。</p><p><strong>注意</strong>，对于网格，面（faces）必须朝向射线原点，这样才能被检测到。背面射线的交叉点将无法被检测到。</p><p>为了使光线能投射到一个对象的正反两面，你需要设置 material 的 side 属性为 THREE.DoubleSide。</p><h3 id="模型点击事件的实现"><a href="#模型点击事件的实现" class="headerlink" title="模型点击事件的实现"></a>模型点击事件的实现</h3><p>上面讲解了射线的相关内容，接下来，我们来看一下，如何使用射线实现一个普通的点击事件。</p><p>首先，我们通过点击事件回调的 event 获取点击的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;</span><br><span class="line">mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;</span><br></pre></td></tr></table></figure><p>默认没有经过矩阵转换过的显示区域的宽和高分别是 2，即中心点也是 WebGL 场景的坐标原点，左上角的坐标是 <code>(-1.0, 1.0, 0.0)</code>，右下角的坐标是 <code>(1.0, -1.0, 0.0)</code>。我们通过单击点的位置计算出当前该点在场景中，没有被矩阵转换过的平面坐标。如果 WebGL 的渲染区域没有占满窗口，我们还需获取显示区域距离窗口左上角的偏移量，再计算位置，计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过 dom 的 getBoundingClientRect 方法获得当前显示区域距离左上角的偏移量</span><br><span class="line">var left = renderer.domElement.getBoundingClientRect().left;</span><br><span class="line">var top = renderer.domElement.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">//根据浏览器的设备类型来获取到当前点击的位置</span><br><span class="line">var clientX = dop.browserRedirect() === &quot;pc&quot; ? event.clientX - left : event.touches[0].clientX - left;</span><br><span class="line">var clientY = dop.browserRedirect() === &quot;pc&quot; ? event.clientY - top : event.touches[0].clientY - top;</span><br><span class="line"></span><br><span class="line">//计算出场景内的原始坐标</span><br><span class="line">mouse.x = (clientX / renderer.domElement.offsetWidth) * 2 - 1;</span><br><span class="line">mouse.y = -(clientY / renderer.domElement.offsetHeight) * 2 + 1;</span><br></pre></td></tr></table></figure><p>获取到坐标以后，我们需要使用射线的 <code>setFromCamera()</code> 方法配合场景坐标和相机更新射线的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raycaster.setFromCamera( mouse, camera );</span><br></pre></td></tr></table></figure><p>接着，使用 <code>intersectObjects()</code> 方法获取射线和所有模型相交的数组集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var intersects = raycaster.intersectObjects( scene.children );</span><br></pre></td></tr></table></figure><p>这里再提醒一句，很多读者可能发现，有时点击后射线并未获取到相交的物体。这是因为我们一般使用 <code>intersectObject()</code> 和 <code>intersectObjects()</code> 时，只会传入对象，而有的模型由多个模型组成，也就是它的子类，这时我们需要传入第二个值，设置为 true，来提示 Three.js 遍历它的子类。</p><p>最后，如果有与射线相交的模型，返回的 intersects 数组的长度将不为零：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(intersects.length &gt; 0)&#123;</span><br><span class="line">    alert(&quot;有相交的模型&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提供一个点击案例，点中物体后，模型颜色将会变色：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/13第十三节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/13第十三节</a> 场景交互/raycaster.html) 。</p><p>案例源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节</a> 场景交互/raycaster.html)。</p><h3 id="简单框选案例的实现"><a href="#简单框选案例的实现" class="headerlink" title="简单框选案例的实现"></a>简单框选案例的实现</h3><p>最近有些小伙伴想实现一个简单的框选案例，在这一篇中我来带大家完成。</p><p>本案例通过判断模型的位置实现框选，即框选前先获取所有模型在二维平面上的位置，然后再判断这些二维平面上的点是否处于框内。</p><p>相对于其它实现方式，这种实现节约性能，简单易懂，能够应付大部分场景。</p><p>接下来，我讲解一下这个框选的实现思路。</p><p>首先，编写以下代码，当鼠标按下时，记录鼠标按下时的场景坐标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取到显示区域距离窗口左上角的偏移量</span><br><span class="line">domClient.x = renderer.domElement.getBoundingClientRect().left;</span><br><span class="line">domClient.y = renderer.domElement.getBoundingClientRect().top;</span><br><span class="line">//计算出当前鼠标距离显示区域左上角的距离</span><br><span class="line">down.x = e.clientX - domClient.x;</span><br><span class="line">down.y = e.clientY - domClient.y;</span><br></pre></td></tr></table></figure><p>前两行代码求出了当前显示区域距离窗口左上角的偏移量，后两行则计算出来了当前鼠标点击位置距离显示区域左上角的偏移。</p><p>接着，使用 box 对象方法计算出模型的包围盒中心位置，适用于多个复杂模型场景。如果只是简单几何体，可以直接使用 Mesh 的位置来计算。通过相机将世界坐标的位置转换为平面坐标，并将模型放到一个数组内以便后期使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; group.children.length; i++) &#123;</span><br><span class="line">    let box = new THREE.Box3();</span><br><span class="line">    box.expandByObject(group.children[i]);</span><br><span class="line"></span><br><span class="line">    //获取到平面的坐标</span><br><span class="line">    let vec3 = new THREE.Vector3();</span><br><span class="line">    box.getCenter(vec3);</span><br><span class="line">    let vec = vec3.project(camera);</span><br><span class="line"></span><br><span class="line">    modelsList.push(</span><br><span class="line">        &#123;</span><br><span class="line">            component: group.children[i],</span><br><span class="line">            position: &#123;</span><br><span class="line">                x: vec.x * half.width + half.width,</span><br><span class="line">                y: -vec.y * half.height + half.height</span><br><span class="line">            &#125;,</span><br><span class="line">            normalMaterial: group.children[i].material</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先通过一个循环，计算出了每一模型在二维平面中的位置。</p><p>接下来，绑定 Document 的 mousemove 事件和 mouseup 事件。鼠标移动事件用来判断每个模型是否处于框内，鼠标抬起事件则将绑定的事件清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//绑定鼠标按下移动事件和抬起事件</span><br><span class="line">document.addEventListener(&quot;mousemove&quot;, movefun, false);</span><br><span class="line">document.addEventListener(&quot;mouseup&quot;, upfun, false);</span><br></pre></td></tr></table></figure><p>在鼠标移动事件中，我们计算出当前四个边的位置，并且循环判断哪些模型的位置处于框内，处于框内的模型的材质将被修改为框选材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; modelsList.length; i++) &#123;</span><br><span class="line">    let position = modelsList[i].position;</span><br><span class="line">    //判断当前位置是否处于框内</span><br><span class="line">    if (position.x &gt; min.x &amp;&amp; position.x &lt; max.x &amp;&amp; position.y &gt; min.y &amp;&amp; position.y &lt; max.y) &#123;</span><br><span class="line">        modelsList[i].component.material = material;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        modelsList[i].component.material = modelsList[i].normalMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后的鼠标抬起事件内，将框选框隐藏，并将所有材质修改为默认材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function upfun(e) &#123;</span><br><span class="line"></span><br><span class="line">    //清除事件</span><br><span class="line">    document.body.removeChild(div);</span><br><span class="line">    document.removeEventListener(&quot;mousemove&quot;, movefun, false);</span><br><span class="line">    document.removeEventListener(&quot;mouseup&quot;, upfun, false);</span><br><span class="line"></span><br><span class="line">    //将所有的模型修改为当前默认的材质</span><br><span class="line">    for (let i = 0; i &lt; modelsList.length; i++) &#123;</span><br><span class="line">        modelsList[i].component.material = modelsList[i].normalMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，附上可以查看的案例地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/13第十三节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/13第十三节</a> 场景交互/boxselection.html)。</p><p>案例源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节</a> 场景交互/boxselection.html)</p><h2 id="Three-js-性能优化"><a href="#Three-js-性能优化" class="headerlink" title="Three.js 性能优化"></a>Three.js 性能优化</h2><p>在接触 Three.js 一段时间后，或多或少都会遇到性能问题。此类问题将直接导致页面帧率过低，严重时会导致页面崩溃。</p><p>导致性能问题的原因有很多，比如模型文件太大或顶点数太多导致加载时间过长，甚至失败，又或者代码书写逻辑有问题导致场景帧数太低。面对不同原因，我们需采取不同的应对方案，比如面对模型问题可对模型进行减面、减体积等处理；针对代码问题，则需尽量减少代码的运算。在平时的开发中，我们还要尽可能避免导致这些性能问题的根由。</p><p>下面，我将分享几种简单的有助于提升性能的方法。</p><h3 id="尽量共用几何体和材质"><a href="#尽量共用几何体和材质" class="headerlink" title="尽量共用几何体和材质"></a>尽量共用几何体和材质</h3><p>当大批量进行模型渲染时，不可避免地会有大量重复几何体的创建，这时共用相同的几何体和材质可以减少内存和 GPU 的数据传输。</p><p>我们具体来看一个实例，比如你需要创建三百个简单的相同颜色的立方体模型，普通的实现方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">    let geometry = new THREE.BoxGeometry(10, 10, 10);</span><br><span class="line">    let material = new THREE.MeshLambertMaterial(&#123;color: 0x00ffff&#125;);</span><br><span class="line">    let mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">    //随机位置</span><br><span class="line">    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));</span><br><span class="line">    group.add(mesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码创建了三百个相同的几何体和材质，该方法中有很多不必要的创建过程，增加运算的同时，还浪费了内存。</p><p>要解决这些性能问题，创建时我们可以共用相同的几何体和材质，改良后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let geometry = new THREE.BoxGeometry(10, 10, 10);</span><br><span class="line">let material = new THREE.MeshLambertMaterial(&#123;color: 0x00ffff&#125;);</span><br><span class="line">for (let i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">    let mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">    //随机位置</span><br><span class="line">    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));</span><br><span class="line">    group.add(mesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面代码，我们只需创建一套相同的几何体的顶点数据，不仅降低了内存消耗，还提高了添加运算效率。</p><h3 id="模型删除时，材质和几何体也需从内存中清除"><a href="#模型删除时，材质和几何体也需从内存中清除" class="headerlink" title="模型删除时，材质和几何体也需从内存中清除"></a>模型删除时，材质和几何体也需从内存中清除</h3><p>我们使用 <code>remove()</code> 将模型从场景内删除后，发现内存占用并没有太大变化。这是因为几何体和材质还保存在内存当中，这时需要手动调用 <code>dispose()</code> 方法将其从内存中删除。</p><p>下面为删除整个场景组的案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//删除group</span><br><span class="line">function deleteGroup(name) &#123;</span><br><span class="line">    let group = scene.getObjectByName(name);</span><br><span class="line">    if (!group) return;</span><br><span class="line">    //删除掉所有的模型组内的mesh</span><br><span class="line">    group.traverse(function (item) &#123;</span><br><span class="line">        if (item instanceof THREE.Mesh) &#123;</span><br><span class="line">            item.geometry.dispose(); //删除几何体</span><br><span class="line">            item.material.dispose(); //删除材质</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    scene.remove(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-merge-方法合并不需要单独操作的模型"><a href="#使用-merge-方法合并不需要单独操作的模型" class="headerlink" title="使用 merge 方法合并不需要单独操作的模型"></a>使用 merge 方法合并不需要单独操作的模型</h3><p>在 Three.js 新版本中，将 merge 方法整合在了几何体上，主要应用于拥有大量几何体且材质相同的模型上。我们可以将多个几何体拼接成单个整体的几何体，从而达到节约性能的目的，但该做法的缺点则是失去了对单个模型的控制。</p><p>通过下面代码，我们了解下 merge 的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//合并模型，则使用merge方法合并</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line">//merge方法将两个几何体对象或者Object3D里面的几何体对象合并，(使用对象的变换)将几何体的顶点、面、UV 分别合并。</span><br><span class="line">//THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead. 如果新版本用老版本的会报这个错</span><br><span class="line">for(var i=0; i&lt;20000; i++)&#123;</span><br><span class="line">    var cube = addCube(); //创建了一个随机位置的几何体模型</span><br><span class="line">    cube.updateMatrix(); //手动更新模型的矩阵</span><br><span class="line">    geometry.merge(cube.geometry, cube.matrix); //将几何体合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scene.add(new THREE.Mesh(geometry, cubeMaterial));</span><br></pre></td></tr></table></figure><p>我们再看一个案例：<a href="http://www.wjceo.com/blog/threejs/2018-03-14/123.html" target="_blank" rel="noopener">点击这里</a>。</p><p>在上面案例中，在不选中 combined 的前提下 ，选择 redraw 20000 个模型的话，一般只有十几帧的帧率。但如果选中了 combined，会发现渲染的帧率可达到满帧（60帧），性能得到了巨大提升。</p><h3 id="在循环渲染中避免使用更新"><a href="#在循环渲染中避免使用更新" class="headerlink" title="在循环渲染中避免使用更新"></a>在循环渲染中避免使用更新</h3><p>几何体、材质、纹理等相关数据的更新尽量不要放到循环渲染中进行。循环渲染时，每一帧都会对 GPU 数据进行更新，这将引发很多不必要的数据更新过程。</p><p>接下来，我们了解下几何体、材质、纹理数据更新的相关属性。</p><ul><li>几何体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geometry.verticesNeedUpdate = true; //顶点发生了修改</span><br><span class="line">geometry.elementsNeedUpdate = true; //面发生了修改</span><br><span class="line">geometry.morphTargetsNeedUpdate = true; //变形目标发生了修改</span><br><span class="line">geometry.uvsNeedUpdate = true; //uv映射发生了修改</span><br><span class="line">geometry.normalsNeedUpdate = true; //法向发生了修改</span><br><span class="line">geometry.colorsNeedUpdate = true; //顶点颜色发生的修改</span><br></pre></td></tr></table></figure><ul><li>材质</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">material.needsUpdate = true；</span><br></pre></td></tr></table></figure><ul><li>纹理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture.needsUpdate = true;</span><br></pre></td></tr></table></figure><p>如果它们发生更新，则将其设置为 true，Three.js 会通过判断，将数据重新传输到显存当中，并将配置项重新修改为 false。这是一个十分影响运行效率的过程，我们尽量只在需要的时候修改，且不要放到 <code>render()</code> 方法当中循环设置。</p><h3 id="只在需要的时候渲染"><a href="#只在需要的时候渲染" class="headerlink" title="只在需要的时候渲染"></a>只在需要的时候渲染</h3><p>在没有操作的时候，一直循环渲染属于浪费资源。接下来我带给大家一个只在需要时渲染的方法。</p><p>首先在循环渲染中加入一个判断，如果判断值为 true 时，才可以循环渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var renderEnabled;</span><br><span class="line">function animate() &#123;</span><br><span class="line"></span><br><span class="line">    if (renderEnabled) &#123;</span><br><span class="line">        renderer.render(scene, camera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animate();</span><br></pre></td></tr></table></figure><p>然后设置一个延迟器函数，每次调用后，可以将 renderEnabled 设置为 true，并延迟三秒将其设置为 false，这个延迟时间大家可以根据需求来修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//调用一次可以渲染三秒</span><br><span class="line">let timeOut = null;</span><br><span class="line">function timeRender() &#123;</span><br><span class="line">    //设置为可渲染状态</span><br><span class="line">    renderEnabled = true;</span><br><span class="line">    //清除上次的延迟器</span><br><span class="line">    if (timeOut) &#123;</span><br><span class="line">        clearTimeout(timeOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeOut = setTimeout(function () &#123;</span><br><span class="line">        renderEnabled = false;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在需要的时候调用这个 <code>timeRender()</code> 方法即可，比如在相机控制器更新后的回调中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    timeRender();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果相机位置发生变化，就会触发回调，开启循环渲染，更新页面显示。</p><p>如果我们添加了一个模型到场景中，直接调用重新渲染即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh);</span><br><span class="line">timeRender();</span><br></pre></td></tr></table></figure><p>最后一个重点问题，就是材质的纹理为异步渲染，需要在图片添加完成后，触发回调。好在 Three.js 已经考虑到了这一点，Three.js 的静态对象 <code>THREE.DefaultLoadingManager</code> 的 onLoad 回调会在每一个纹理图片加载完成后触发回调。依靠它，我们可以在 Three.js 的每一个内容发生变更后触发重新渲染，且闲置状态下停止渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//每次材质和纹理更新，触发重新渲染</span><br><span class="line">THREE.DefaultLoadingManager.onLoad = function () &#123;</span><br><span class="line">    timeRender();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Three-js-核心对象"><a href="#Three-js-核心对象" class="headerlink" title="Three.js 核心对象"></a>Three.js 核心对象</h2><p>本文是介绍 Three.js 核心技术知识的最后一节，带大家了解经常接触到的对象。第16课，也是课程的最后一节，我们就开始实战演练。</p><h3 id="THREE-Clock"><a href="#THREE-Clock" class="headerlink" title="THREE.Clock"></a>THREE.Clock</h3><p>时间对象用于跟踪时间，用于计算每一帧的渲染时间或者从开始渲染到结束的时间。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数的使用，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clock = new THREE.Clock();</span><br></pre></td></tr></table></figure><p>实例化时间对象，还可以接收一个布尔类型的参数，用于设置实例化完成后，是否启动时间对象计时，默认为开启。</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>该类主要有以下几种方法。</p><ul><li><strong>.start()：</strong>此方法用于启动时间对象开始计时，将所有的信息重置；</li><li><strong>.stop()：</strong>停止时间对象的计时；</li><li><strong>.getElapsedTime()：</strong>此方法返回自时间对象开启以后到现在的时间；</li><li><strong>.getDelta()：</strong>此方法返回上次调用到这次调用此方法的间隔时间，用于计算渲染间隔。</li></ul><h3 id="THREE-Color"><a href="#THREE-Color" class="headerlink" title="THREE.Color"></a>THREE.Color</h3><p>THREE.Color 为颜色类，用到颜色的地方，都可以实例化此类，如设置材质颜色、场景背景颜色等。</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们可以通过 <code>new THREE.Color()</code> 传入一个值来初始化一个颜色对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//不传参数将默认渲染成白色</span><br><span class="line">var color = new THREE.Color();</span><br><span class="line"></span><br><span class="line">//十六进制颜色（推荐）</span><br><span class="line">var color = new THREE.Color( 0xff0000 );</span><br><span class="line"></span><br><span class="line">//RGB 字符串</span><br><span class="line">var color = new THREE.Color(&quot;rgb(255, 0, 0)&quot;);</span><br><span class="line">var color = new THREE.Color(&quot;rgb(100%, 0%, 0%)&quot;);</span><br><span class="line"></span><br><span class="line">//支持所有140个颜色名称</span><br><span class="line">var color = new THREE.Color( &apos;skyblue&apos; );</span><br><span class="line"></span><br><span class="line">//HSL 字符串</span><br><span class="line">var color = new THREE.Color(&quot;hsl(0, 100%, 50%)&quot;);</span><br><span class="line"></span><br><span class="line">//支持区间为从0到1的RGB数值</span><br><span class="line">var color = new THREE.Color( 1, 0, 0 );</span><br></pre></td></tr></table></figure><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>该类主要有以下几种方法。</p><ul><li><strong>.clone()：</strong>返回一个相同颜色的颜色对象；</li><li><strong>.add()：</strong>将一个颜色对象的颜色值和此颜色对象的颜色相加；</li><li><strong>.multiply()：</strong>将一个颜色对象的颜色值和此颜色对象的颜色相乘；</li><li><strong>.set()：</strong>重新设置颜色对象的颜色，支持实例化时的所有方式。</li></ul><h3 id="矢量对象"><a href="#矢量对象" class="headerlink" title="矢量对象"></a>矢量对象</h3><p>矢量是 GLSL ES 语言内的标准数据类型，也是 WebGL 原生着色器语言的数据类型。而 Three.js 为了方便和原生融合，内置了 <code>THREE.Vector2</code>、<code>THREE.Vector3</code> 和 <code>THREE.Vector4</code> 三种矢量，分别代表二维向量、三维向量和四维向量。</p><h4 id="二维矢量"><a href="#二维矢量" class="headerlink" title="二维矢量"></a>二维矢量</h4><p>二维矢量一般表示二维平面上点的位置和方向。</p><p>下面代码生成了一个普通的二维矢量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = new THREE.Vector2( 0, 1 );</span><br></pre></td></tr></table></figure><p>我们也可以通过 <code>set()</code> 方法，重新修改二维矢量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.set(2, 3);</span><br></pre></td></tr></table></figure><h4 id="三维矢量"><a href="#三维矢量" class="headerlink" title="三维矢量"></a>三维矢量</h4><p>在项目当中，我们经常会用到三维矢量，比如模型的位置属性、缩放属性，都是一个三维矢量。它由三个有序的数字组成的。</p><p>使用三维矢量，我们可以表示：</p><ol><li>三维空间中一个点的位置；</li><li>三维空间中两点连线的方向和长度；</li><li>任意有序的三个数字。</li></ol><p>我们看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建一个普通的三维矢量</span><br><span class="line">var a = new THREE.Vector3( 0, 1, 0 );</span><br><span class="line"></span><br><span class="line">//默认空值，将会重置为(0, 0, 0)</span><br><span class="line">var b = new THREE.Vector3( );</span><br><span class="line"></span><br><span class="line">//d矢量是从a点到b点的方向和长度</span><br><span class="line">var d = a.distanceTo( b );</span><br></pre></td></tr></table></figure><p>我们经常进行的模型位置改变以及缩放操作，其实都是通过修改三维矢量的值来实现的，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建一个三维矢量</span><br><span class="line">var vec = new THREE.Vector3(0, 1, 0);</span><br><span class="line"></span><br><span class="line">//修改模型的位置</span><br><span class="line">mesh.position = vec;</span><br><span class="line"></span><br><span class="line">//修改三维矢量的值</span><br><span class="line">vec.set(1, 2, 1);</span><br><span class="line"></span><br><span class="line">//修改模型的缩放值</span><br><span class="line">mesh.scale.set(2, 2, 2);</span><br></pre></td></tr></table></figure><p>我们还可以修改三维向量的单个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec.setComponent(0, 20); //将三维向量的第一值修改为20</span><br><span class="line"></span><br><span class="line">.setComponent(index, value); </span><br><span class="line">//index 修改的单个值的下标，可选值为 0 1 2 对应 vec.x vec.y vec.z</span><br><span class="line">//value 修改成的数字</span><br></pre></td></tr></table></figure><h4 id="四维矢量"><a href="#四维矢量" class="headerlink" title="四维矢量"></a>四维矢量</h4><p>四维矢量是由四个数字组成的数据类型，四个值分别代表 x、y、z、w。</p><p>四维矢量可以表示的内容有：</p><ol><li>思维空间内的一个点；</li><li>思维空间里的方向和长度；</li><li>任意有序的四个数字。</li></ol><p>我们再看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个普通的四维矢量</span><br><span class="line">var a = new THREE.Vector4( 0, 1, 0, 0 );</span><br><span class="line"></span><br><span class="line">//如果不设置参数，默认值为 (0, 0, 0, 1)</span><br><span class="line">var b = new THREE.Vector4( );</span><br></pre></td></tr></table></figure><h3 id="四维矩阵"><a href="#四维矩阵" class="headerlink" title="四维矩阵"></a>四维矩阵</h3><p>矩阵是高等代数中的常见工具，也常见于统计分析等应用数学学科中。Three.js 为我们封装了三维矩阵（3x3）四维矩阵（4x4）。</p><p>篇幅有限，这里就不介绍三维矩阵了，我们主要看下四维矩阵。</p><p>在 3D 计算机图形中，最常见的四维矩阵主要用于转换矩阵。这代表三维空间中的点 Vector3 通过乘以转换矩阵，可以实现如平移、旋转、剪切、缩放、发射、正交或透视投影等变化。</p><p>在每个 3D 对象中都有三个四维矩阵。</p><ul><li>Object3D.matrix：存储 3D 对象的局部变换，这是 3D 对象相对于父对象的转换；</li><li>Object3D.matrixWorld：3D 对象的全局或世界变换，如果 3D 对象没有父对象，则当前矩阵和其局部变换矩阵相同。</li><li>Object3D.modelViewMatrix：表示 3D 对象相对于摄像机的坐标转换，对象的 modelViewMatrix 是对象的 matrixWorld 再乘以相机的 matrixWorldInverse 获得的结果。</li></ul><p>相机对象不但含有 3D 对象的四维矩阵，还额外拥有以下两个四维矩阵。</p><ul><li>Camera.matrixWorldInverse：视图矩阵（相机的 matrixWorld 反转后的四维矩阵）；</li><li>Camera.projectionMatrix：表示场景内的模型如何转换到二维显示区域的变换矩阵。</li></ul><p>如果你对矩阵的实现原理感兴趣的话，可<a href="https://blog.csdn.net/qq_30100043/article/details/72783071" target="_blank" rel="noopener">点击这里</a>查看，这里不再过多解释原理。</p><p>接下来我们查看一下 Three.js 封装的四维变换矩阵为我们提供了哪些方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">//我们可以通过手动设置每一项的数值来生成变换矩阵</span><br><span class="line">m.set( 11, 12, 13, 14,</span><br><span class="line">       21, 22, 23, 24,</span><br><span class="line">       31, 32, 33, 34,</span><br><span class="line">       41, 42, 43, 44 );</span><br><span class="line"></span><br><span class="line">//创建一个矢量，并应用此变换矩阵</span><br><span class="line">var v = new THREE.Vector3();</span><br><span class="line"></span><br><span class="line">v.applyMatrix4(m); //应用变换矩阵</span><br></pre></td></tr></table></figure><p>上面代码创建了一个默认的四维矩阵，三维矢量乘以默认的四维矩阵将不会产生变化。</p><p>我们可以使用 <code>.identity()</code> 方法来重置变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">m.identity(); //重置矩阵恢复默认</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>.lookAt()</code> 传入一个三个矢量生成一个旋转矩阵。这三个矢量分别代表眼的位置、查看的物体位置和向上的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">m.lookAt(eye, center, up); //生成旋转变换矩阵</span><br></pre></td></tr></table></figure><p>我们也可以通过旋转弧度来生成旋转变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">//通过绕x轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationX(Math.PI/2); //绕x轴旋转90度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2); //效果同上</span><br><span class="line"></span><br><span class="line">//通过绕y轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationY(Math.PI); //绕y轴旋转180度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI); //效果同上</span><br><span class="line"></span><br><span class="line">//通过绕z轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationZ(Math.PI/4); //绕z轴旋转45度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI/4); //效果同上</span><br></pre></td></tr></table></figure><p>通过设置缩放来生成缩放变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">m.makeScale(1, 2, 5); //生成沿x轴不变，y轴放大两倍，z轴放大五倍的缩放变换矩阵</span><br></pre></td></tr></table></figure><p>通过设置位置平移来生成变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">m.makeTranslation(10, -20, 100); //生成沿x正轴偏移10，y负轴偏移20，z正轴偏移100的平移变换矩阵</span><br></pre></td></tr></table></figure><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角通过在每个轴指定旋转的弧度和指定旋转轴的先后顺序来进行旋转变换。之前介绍场景时已做介绍，不再赘述。这里想说明的是，每个 3D 对象的 rotation 属性都是一个欧拉角对象。</p><p>创建欧拉角定义方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var e = new THREE.Euler( 0, 1, 1.57, &apos;XYZ&apos; );</span><br></pre></td></tr></table></figure><p>前三个值分别代表每个轴上旋转的弧度，第四个值是应用旋转的顺序。默认为“XYZ”，这意味着对象将首先围绕其 X 轴旋转，然后围绕其 Y 轴旋转，最后围绕其 Z 轴旋转。其他可能性有 YZX、ZXY、XZY、YXZ、ZYX，都必须大写。</p><p>修改欧拉角的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过set方法重新设置</span><br><span class="line">var e = new THREE.Euler();</span><br><span class="line">e.set(Math.PI, 0, - Math.PI / 2, &quot;YZX&quot;); //先沿y轴旋转180度，再沿z轴旋转0度，最后沿x轴逆时针旋转90度，第四个值可以不填，默认是&quot;XYZ&quot;</span><br></pre></td></tr></table></figure><p>我们也可以通过变换矩阵来修改当前的欧拉角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var e = new THREE.Euler( 0, 1, 1.57, &apos;XYZ&apos; );</span><br><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">e.setFromRotationMatrix(m); //在当前的旋转角度，再进行矩阵变换</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Three.js 知识讲解部分，到这里基本就结束了。第一次写正式的教程，难免有一些瑕疵。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="\posts\456b6ccc.html" rel="bookmark">Threejs学习和总结前传</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="\posts\89cc5dea.html" rel="bookmark">Threejs学习和总结基础篇</a></div></li></ul><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Gong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Gong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Gong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.aigisss.com/posts/ab44f639.html" title="Threejs学习和总结进阶篇">https://blog.aigisss.com/posts/ab44f639.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Threejs/" rel="tag"># Threejs</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/89cc5dea.html" rel="next" title="Threejs学习和总结基础篇"><i class="fa fa-chevron-left"></i> Threejs学习和总结基础篇</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/e1a3a842.html" rel="prev" title="Mapbox加载空白地图">Mapbox加载空白地图 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#相机控制器Controls"><span class="nav-number">1.</span> <span class="nav-text">相机控制器Controls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OrbitControls"><span class="nav-number">1.1.</span> <span class="nav-text">OrbitControls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用操作"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制器引入"><span class="nav-number">1.1.2.</span> <span class="nav-text">控制器引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性和方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#update"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">update()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reset"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">reset()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispose"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">dispose()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#change-回调"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">change 回调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TrackballControls"><span class="nav-number">1.2.</span> <span class="nav-text">TrackballControls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用操作-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制器引入-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">控制器引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性和方法-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#update-1"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">update()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reset-1"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">reset()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispose-1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">dispose()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#change-回调-1"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">change 回调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeviceOrientationControls"><span class="nav-number">1.3.</span> <span class="nav-text">DeviceOrientationControls</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型加载Loaders"><span class="nav-number">2.</span> <span class="nav-text">模型加载Loaders</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐使用的模型格式"><span class="nav-number">2.1.</span> <span class="nav-text">推荐使用的模型格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Three-js-的-JSON-格式"><span class="nav-number">2.2.</span> <span class="nav-text">Three.js 的 JSON 格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3D-对象转成-JSON"><span class="nav-number">2.2.1.</span> <span class="nav-text">3D 对象转成 JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-ObjectLoader-加载-JSON-模型"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用 ObjectLoader 加载 JSON 模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glTF-格式文件导入"><span class="nav-number">2.3.</span> <span class="nav-text">glTF 格式文件导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FBX-模型导入"><span class="nav-number">2.4.</span> <span class="nav-text">FBX 模型导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OBJ-格式模型导入"><span class="nav-number">2.5.</span> <span class="nav-text">OBJ 格式模型导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COLLADA-模型导入"><span class="nav-number">2.6.</span> <span class="nav-text">COLLADA 模型导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">2.7.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Three-js-动画"><span class="nav-number">3.</span> <span class="nav-text">Three.js 动画</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变形动画"><span class="nav-number">3.1.</span> <span class="nav-text">变形动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#骨骼动画"><span class="nav-number">3.2.</span> <span class="nav-text">骨骼动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种动画的区别"><span class="nav-number">3.3.</span> <span class="nav-text">两种动画的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入模型动画"><span class="nav-number">3.4.</span> <span class="nav-text">导入模型动画</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动画片段（Animation-Clips）"><span class="nav-number">3.4.1.</span> <span class="nav-text">动画片段（Animation Clips）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键帧轨迹（Keyframe-Tracks）"><span class="nav-number">3.4.2.</span> <span class="nav-text">关键帧轨迹（Keyframe Tracks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动画混合器（Animation-Mixer）"><span class="nav-number">3.4.3.</span> <span class="nav-text">动画混合器（Animation Mixer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动画播放器（Animation-Actions）"><span class="nav-number">3.4.4.</span> <span class="nav-text">动画播放器（Animation Actions）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动画对象组（Animation-Object-Groups）"><span class="nav-number">3.4.5.</span> <span class="nav-text">动画对象组（Animation Object Groups）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过导入模型显示动画"><span class="nav-number">3.5.</span> <span class="nav-text">通过导入模型显示动画</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变形动画-1"><span class="nav-number">3.5.1.</span> <span class="nav-text">变形动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#骨骼动画-1"><span class="nav-number">3.5.2.</span> <span class="nav-text">骨骼动画</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tween-js-补间动画"><span class="nav-number">4.</span> <span class="nav-text">Tween.js 补间动画</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tween-是什么"><span class="nav-number">4.1.</span> <span class="nav-text">Tween 是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单应用"><span class="nav-number">4.1.1.</span> <span class="nav-text">简单应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链式调用"><span class="nav-number">4.1.2.</span> <span class="nav-text">链式调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tween-对象方法"><span class="nav-number">4.2.</span> <span class="nav-text">Tween 对象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制动画方法"><span class="nav-number">4.2.1.</span> <span class="nav-text">控制动画方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调函数"><span class="nav-number">4.3.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Three-js-场景交互"><span class="nav-number">5.</span> <span class="nav-text">Three.js 场景交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#THREE-Raycaster-构造函数和对象方法"><span class="nav-number">5.1.</span> <span class="nav-text">THREE.Raycaster 构造函数和对象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例化"><span class="nav-number">5.1.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">5.1.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">5.1.3.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型点击事件的实现"><span class="nav-number">5.2.</span> <span class="nav-text">模型点击事件的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单框选案例的实现"><span class="nav-number">5.3.</span> <span class="nav-text">简单框选案例的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Three-js-性能优化"><span class="nav-number">6.</span> <span class="nav-text">Three.js 性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量共用几何体和材质"><span class="nav-number">6.1.</span> <span class="nav-text">尽量共用几何体和材质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型删除时，材质和几何体也需从内存中清除"><span class="nav-number">6.2.</span> <span class="nav-text">模型删除时，材质和几何体也需从内存中清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-merge-方法合并不需要单独操作的模型"><span class="nav-number">6.3.</span> <span class="nav-text">使用 merge 方法合并不需要单独操作的模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在循环渲染中避免使用更新"><span class="nav-number">6.4.</span> <span class="nav-text">在循环渲染中避免使用更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只在需要的时候渲染"><span class="nav-number">6.5.</span> <span class="nav-text">只在需要的时候渲染</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Three-js-核心对象"><span class="nav-number">7.</span> <span class="nav-text">Three.js 核心对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#THREE-Clock"><span class="nav-number">7.1.</span> <span class="nav-text">THREE.Clock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">7.1.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-1"><span class="nav-number">7.1.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#THREE-Color"><span class="nav-number">7.2.</span> <span class="nav-text">THREE.Color</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-2"><span class="nav-number">7.2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矢量对象"><span class="nav-number">7.3.</span> <span class="nav-text">矢量对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二维矢量"><span class="nav-number">7.3.1.</span> <span class="nav-text">二维矢量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三维矢量"><span class="nav-number">7.3.2.</span> <span class="nav-text">三维矢量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四维矢量"><span class="nav-number">7.3.3.</span> <span class="nav-text">四维矢量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四维矩阵"><span class="nav-number">7.4.</span> <span class="nav-text">四维矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#欧拉角"><span class="nav-number">7.5.</span> <span class="nav-text">欧拉角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结语"><span class="nav-number">7.6.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/dog.jpg" alt="Gong"><p class="site-author-name" itemprop="name">Gong</p><div class="site-description" itemprop="description">真正的伟大,即在于以脆弱的凡人之躯而具有神性的不可战胜。</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Cenergy" title="GitHub &rarr; https://github.com/Cenergy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_36264495" title="CSDN &rarr; https://blog.csdn.net/qq_36264495" rel="noopener" target="_blank"><i class="fa fa-fw fa-codiepie"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://ouyangresume.github.io/" title="https://ouyangresume.github.io/" rel="noopener" target="_blank">小小的诗</a></li><li class="links-of-blogroll-item"><a href="https://gis.3nice.cc" title="https://gis.3nice.cc" rel="noopener" target="_blank">地理信息导航网站</a></li><li class="links-of-blogroll-item"><a href="https://www.xpshuai.cn" title="https://www.xpshuai.cn" rel="noopener" target="_blank">偷得浮生半日闲</a></li><li class="links-of-blogroll-item"><a href="https://www.xbeichen.cn" title="https://www.xbeichen.cn" rel="noopener" target="_blank">X北辰北的个人博客</a></li><li class="links-of-blogroll-item"><a href="https://www.3nice.cc/" title="https://www.3nice.cc/" rel="noopener" target="_blank">3nice.cc</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">赣ICP备18013338-1号 </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=" rel="noopener" target="_blank"></a>&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">AIGISSS 爱即是诗</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script><script src="/js/schemes/pisces.js?v=7.4.1"></script><script src="/js/next-boot.js?v=7.4.1"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('/lib/mermaid/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>NexT.utils.getScript('/lib/valine/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'diTi74ah5rpPDNa6bjS0VjqN-gzGzoHsz',
    appKey: 'nHbjOKICQKYQtsVVJjeHYl0O',
    placeholder: '写评论...',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);</script><script type="text/javascript" src="/lib/others/love.js"></script><script type="text/javascript" src="/lib/others/crash_cheat.js"></script></body></html><!-- rebuild by neat -->