<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AIGISSS</title>
  
  <subtitle>爱即是诗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.aigisss.com/"/>
  <updated>2019-09-26T15:40:22.349Z</updated>
  <id>https://blog.aigisss.com/</id>
  
  <author>
    <name>Gong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack学习与总结</title>
    <link href="https://blog.aigisss.com/posts/6e7939e6.html"/>
    <id>https://blog.aigisss.com/posts/6e7939e6.html</id>
    <published>2019-09-24T12:37:14.000Z</published>
    <updated>2019-09-26T15:40:22.349Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><p><img src="/posts/6e7939e6/webpack.png" alt></p><a id="more"></a><h2 id="初识-Webpack"><a href="#初识-Webpack" class="headerlink" title="初识 Webpack"></a>初识 Webpack</h2><p>webpack 是模块打包工具，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。</p><p>历史上先后出现一系列构建工具，它们各有其优缺点。由于前端工程师很熟悉 JavaScript ，Node.js 又可以胜任所有构建需求，所以大多数构建工具都是用 Node.js 开发的。下面来一一介绍它们。</p><h3 id="Npm-Script"><a href="#Npm-Script" class="headerlink" title="Npm Script"></a>Npm Script</h3><p><a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="noopener">Npm Script</a> 是一个任务执行者。Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 <code>package.json</code> 文件里面使用 <code>scripts</code> 字段定义任务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"node dev.js"</span>,</span><br><span class="line">    <span class="attr">"pub"</span>: <span class="string">"node build.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的 <code>scripts</code> 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 <code>dev</code> 和 <code>pub</code>。 其底层实现原理是通过调用 Shell 去运行脚本命令，例如执行 <code>npm run pub</code> 命令等同于执行命令 <code>node build.js</code>。</p><p>Npm Script的优点是内置，无须安装其他依赖。其缺点是功能太简单，虽然提供了 <code>pre</code> 和 <code>post</code> 两个钩子，但不能方便地管理多个任务之间的依赖。</p><h3 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h3><p><a href="https://gruntjs.com/" target="_blank" rel="noopener">Grunt</a> 和 Npm Script 类似，也是一个任务执行者。Grunt 有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 <code>Gruntfile.js</code> 里，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有插件的配置信息</span></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="comment">// uglify 插件的配置信息</span></span><br><span class="line">    uglify: &#123;</span><br><span class="line">      app_task: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          <span class="string">'build/app.min.js'</span>: [<span class="string">'lib/index.js'</span>, <span class="string">'lib/test.js'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// watch 插件的配置信息</span></span><br><span class="line">    watch: &#123;</span><br><span class="line">      another: &#123;</span><br><span class="line">          files: [<span class="string">'lib/*.js'</span>],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉 grunt 我们将使用这些插件</span></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务</span></span><br><span class="line">  grunt.registerTask(<span class="string">'dev'</span>, [<span class="string">'uglify'</span>,<span class="string">'watch'</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在项目根目录下执行命令 <code>grunt dev</code> 就会启动 JavaScript 文件压缩和自动刷新功能。</p><p>Grunt的优点是：</p><ul><li>灵活，它只负责执行你定义的任务；</li><li>大量的可复用插件封装好了常见的构建任务。</li></ul><p>Grunt的缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。</p><p>Grunt 相当于进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><a href="http://gulpjs.com/" target="_blank" rel="noopener">Gulp</a> 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5个方法就可以胜任几乎所有构建场景：</p><ul><li>通过 <code>gulp.task</code> 注册一个任务；</li><li>通过 <code>gulp.run</code> 执行任务；</li><li>通过 <code>gulp.watch</code> 监听文件变化；</li><li>通过 <code>gulp.src</code> 读取文件；</li><li>通过 <code>gulp.dest</code> 写文件。</li></ul><p>Gulp 的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Gulp</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>); </span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">var</span> jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>);</span><br><span class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 SCSS 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件通过管道喂给插件</span></span><br><span class="line">  gulp.src(<span class="string">'./scss/*.scss'</span>)</span><br><span class="line">    <span class="comment">// SCSS 插件把 scss 文件编译成 CSS 文件</span></span><br><span class="line">    .pipe(sass())</span><br><span class="line">    <span class="comment">// 输出文件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并压缩 JS</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.src(<span class="string">'./js/*.js'</span>)</span><br><span class="line">    .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 当 scss 文件被编辑时执行 SCSS 任务</span></span><br><span class="line">  gulp.watch(<span class="string">'./scss/*.scss'</span>, [<span class="string">'sass'</span>]);</span><br><span class="line">  gulp.watch(<span class="string">'./js/*.js'</span>, [<span class="string">'scripts'</span>]);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。</p><p>可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。</p><p>其官网的首页图很形象的画出了 Webpack 是什么，如下：</p><p><img src="/posts/6e7939e6/1569474242621.png" alt="1569474242621"></p><p>一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。</p><p>Webpack 具有很大的灵活性，能配置如何处理文件，大致使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块</span></span><br><span class="line">  entry: <span class="string">'./app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 </span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webpack的优点是：</p><ul><li>专注于处理模块化的项目，能做到开箱即用一步到位；</li><li>通过 Plugin 扩展，完整好用又不失灵活；</li><li>使用场景不仅限于 Web 开发；</li><li>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</li><li>良好的开发体验。</li></ul><p>Webpack的缺点是只能用于采用模块化开发的项目。</p><h3 id="为什么选择-Webpack"><a href="#为什么选择-Webpack" class="headerlink" title="为什么选择 Webpack"></a>为什么选择 Webpack</h3><p>上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物，侧面反映出 Web 开发的发展趋势如下：</p><ol><li>在 Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入，用于简化流程；</li><li>在 Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想的出现是为了简化文件转换的流程，例如将 ES6 转换成 ES5。</li><li>在 Webpack 时代由于单页应用的流行，一个网页的功能和实现代码变得庞大，Web 开发向模块化改进。</li></ol><p>这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务，也可以相互搭配起来弥补各自的不足。 在了解这些常见的构建工具后，你需要根据自己的需求去判断应该如何选择和搭配它们才能更好地完成自己的需求。</p><p>经过多年的发展， Webpack 已经成为构建工具中的首选，这是有原因的：</p><ul><li>大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；</li><li>Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；</li><li>Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。</li></ul><h2 id="使用Webpack"><a href="#使用Webpack" class="headerlink" title="使用Webpack"></a>使用Webpack</h2><h3 id="安装-Webpack-到本项目"><a href="#安装-Webpack-到本项目" class="headerlink" title="安装 Webpack 到本项目"></a>安装 Webpack 到本项目</h3><p>在开始给项目加入构建前， 在安装 Webpack 前请确保你的系统安装了5.0.0及以上版本的 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>。你还需要先新建一个 Web 项目，进入项目根目录执行 <code>npm init</code> 来初始化最简单的采用了模块化开发的项目；</p><p>要安装 Webpack 到本项目，可按照你的需要选择以下任意命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies</span></span><br><span class="line"><span class="comment"># 安装最新稳定版</span></span><br><span class="line">npm i -D webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">npm i -D webpack@&lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最新体验版本</span></span><br><span class="line">npm i -D webpack@beta</span><br></pre></td></tr></table></figure><p>安装完后你可以通过这些途径运行安装到本项目的 Webpack：</p><ul><li><p>在项目根目录下对应的命令行里通过 <code>node_modules/.bin/webpack</code> 运行 Webpack 可执行文件。</p></li><li><p>在 <a href="http://webpack.wuhaolin.cn/1入门/常见的构建工具及对比/npm_script.md" target="_blank" rel="noopener">Npm Script</a> 里定义的任务会优先使用本项目下的 Webpack，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "webpack --config webpack.config.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>npx webpack</code></p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npx</span><br></pre></td></tr></table></figure><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 webpack 而且全局没有安装 webpack。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D webpack</span><br></pre></td></tr></table></figure><p>一般来说，调用 webpack，只能在项目脚本和 package.json 的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener"><code>scripts</code></a>字段里面， 如果想在命令行下调用，必须像下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line"><span class="built_in">cd</span> node_modules\.bin</span><br><span class="line">webpack --version   <span class="comment"># 输出 4.41.0</span></span><br></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line">npx webpack --version</span><br></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx create-react-app my-react-app</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码运行时，npx 将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载<code>create-react-app</code>。</p><p>下载全局模块时，npx 允许指定版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码指定使用 3.1.0 版本的<code>uglify-js</code>压缩脚本。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装<code>http-server</code>模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx http-server</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">npx 使用教程</a></p></blockquote></li></ul><h3 id="安装-Webpack-到全局"><a href="#安装-Webpack-到全局" class="headerlink" title="安装 Webpack 到全局"></a>安装 Webpack 到全局</h3><p>安装到全局后你可以在任何地方共用一个 Webpack 可执行文件，而不用各个项目重复安装，安装方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g webpack</span><br></pre></td></tr></table></figure><div class="note danger">虽然介绍了以上两种安装方式，但是我们推荐安装到本项目，原因是可防止不同项目依赖不同版本的 Webpack 而导致冲突。</div>### 使用 Webpack<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>Webpack 在执行构建时默认会从项目根目录下的 <code>webpack.config.js</code> 文件读取配置，所以你还需要新建它，其内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JavaScript 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把所有依赖的模块合并输出到一个 bundle.js 文件</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 Webpack 构建运行在 Node.js 环境下，所以该文件最后需要通过 CommonJS 规范导出一个描述如何构建的 <code>Object</code> 对象。</p><h4 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h4><p>Webpack 把一切文件看作模块，CSS 文件也不例外，Webpack 不原生支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制。Webpack的配置修改使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JavaScript 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把所有依赖的模块合并输出到一个 bundle.js 文件</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用正则去匹配要用该 loader 转换的 CSS 文件</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader?minimize'</span>],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Loader 可以看作具有文件转换功能的翻译员，配置里的 <code>module.rules</code> 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 <code>.css</code> 结尾的文件时先使用 <code>css-loader</code> 读取 CSS 文件，再交给 <code>style-loader</code> 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：</p><ul><li><code>use</code> 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；</li><li>每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 <code>css-loader?minimize</code> 中的 <code>minimize</code> 告诉 <code>css-loader</code> 要开启 CSS 压缩。</li></ul><p>Webpack 构建前要先安装新引入的 Loader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D style-loader css-loader</span><br></pre></td></tr></table></figure><p>给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入，以上的 Loader 配置可以修改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  <span class="string">'style-loader'</span>, </span><br><span class="line">  &#123;</span><br><span class="line">    loader:<span class="string">'css-loader'</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      minimize:<span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>除了在 <code>webpack.config.js</code> 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 <code>main.js</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'style-loader!css-loader?minimize!./main.css'</span>);</span><br></pre></td></tr></table></figure><p>这样就能指定对 <code>./main.css</code> 这个文件先采用 css-loader 再采用 style-loader 转换。</p><h4 id="使用-Plugin"><a href="#使用-Plugin" class="headerlink" title="使用 Plugin"></a>使用 Plugin</h4><p>plugin 可以在 webpack 运行到某一时刻的时候，帮你做一些事情。</p><p>htmlWepackPluginnn 会在打包结束后，自动生成一个 html 文件，并把打包的生成的 js 自动引入到这个 html 文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>); <span class="comment">//通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>); <span class="comment">//访问内置的插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: <span class="string">"file-loader"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">"./src/index.html"</span> &#125;)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h4 id="使用-DevServer"><a href="#使用-DevServer" class="headerlink" title="使用 DevServer"></a>使用 DevServer</h4><p>DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。</p><p>首先需要安装 DevServer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>安装成功后执行 <code>webpack-dev-server</code> 命令， DevServer 就启动了，这时你会看到控制台有一串日志输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project is running at http://localhost:8080/</span><br><span class="line">webpack output is served from /</span><br></pre></td></tr></table></figure><p>这意味着 DevServer 启动的 HTTP 服务器监听在 <code>http://localhost:8080/</code> ，DevServer 启动后会一直驻留在后台保持运行，访问这个网址你就能获取项目根目录下的 <code>index.html</code>。 用浏览器打开这个地址你会发现页面空白错误原因是 <code>./dist/bundle.js</code> 加载404了。 同时你会发现并没有文件输出到 <code>dist</code> 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。 由于 DevServer 不会理会 <code>webpack.config.js</code> 里配置的 <code>output.path</code> 属性，所以要获取 <code>bundle.js</code>的正确 URL 是 <code>http://localhost:8080/bundle.js</code>，对应的 <code>index.html</code> 应该修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入 DevServer 输出的 JavaScript 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Webpack 可以在启动 Webpack 时通过 <code>webpack --watch</code> 来开启监听模式，实时预览。Webpack 支持生成 Source Map，只需在启动时带上 <code>--devtool source-map</code> 参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。</p><p>DevServer 还有一种被称作模块热替换的刷新技术。 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上 <code>--hot</code> 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>Webpack 有以下几个核心概念。</p><ul><li><strong>Entry</strong>：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</li><li><strong>Module</strong>：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li><strong>Chunk</strong>：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li><strong>Loader</strong>：模块转换器，用于把模块原内容按照需求转换成新内容。</li><li><strong>Plugin</strong>：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li><li><strong>Output</strong>：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</li></ul><p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。</p><h2 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h2><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>就会拷贝到打包文件夹内</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./src/index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"file-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"[name].[ext]"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>会变成 base64，在 js 文件中直接加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./src/index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"url-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"[name].[ext]"</span>,</span><br><span class="line">            outputPath: <span class="string">"images/"</span>,</span><br><span class="line">            limit: <span class="number">1024</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader style-loader"></a>css-loader style-loader</h3><h2 id="Webpack-进阶"><a href="#Webpack-进阶" class="headerlink" title="Webpack 进阶"></a>Webpack 进阶</h2><h2 id="Webpack-配置及案例"><a href="#Webpack-配置及案例" class="headerlink" title="Webpack 配置及案例"></a>Webpack 配置及案例</h2><h2 id="Webpack-原理及脚手架"><a href="#Webpack-原理及脚手架" class="headerlink" title="Webpack 原理及脚手架"></a>Webpack 原理及脚手架</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/6e7939e6/webpack.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="webpack" scheme="https://blog.aigisss.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程总结</title>
    <link href="https://blog.aigisss.com/posts/9364fbab.html"/>
    <id>https://blog.aigisss.com/posts/9364fbab.html</id>
    <published>2019-09-19T04:35:34.000Z</published>
    <updated>2019-09-25T15:23:47.304Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><h2 id="What-is-Object-oriented-Programming"><a href="#What-is-Object-oriented-Programming" class="headerlink" title="What is Object-oriented Programming"></a>What is Object-oriented Programming</h2><p><img src="/posts/9364fbab/1569242664504.png" alt="1569242664504"></p><a id="more"></a><div class="note info">OOP是一种编程范例，或者编程风格，这是围绕对象而不是函数</div>面向对象编程中的四个核心概念<p><code>Encapsulation</code>—封装 <code>Abstraction</code>—抽象 <code>Inheritance</code>—继承 <code>Polymorphism</code>—多态</p><p>区别与面向过程编程</p><p><img src="/posts/9364fbab/1568869135169.png" alt="1568869135169"></p><p><img src="/posts/9364fbab/1568868905016.png" alt="1568868905016"></p><div class="note danger">改变了其中一个函数，然后其他几个函数可能就奔溃了，这就是我们说的意大利面条代码。 函数之间深层次的关联变成了各种问题的来源，OOP就应运而生。</div><p><img src="/posts/9364fbab/1568869159417.png" alt="1568869159417"></p><p>OOP 就一组相关的变量和函数组成合成一个单元，我们称之为对象(object)。把里面的函数称为方法，里面的变量称之为属性。</p><p><img src="/posts/9364fbab/1568869302595.png" alt="1568869302595"></p><div class="note info">最好的函数是那些没有参数的函数，参数个数越少，使用和维护就越简单。这就是封装！</div>![1568869634914](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568869634914.png)<p><img src="/posts/9364fbab/1568869889043.png" alt="1568869889043"></p><div class="note info">多态意味着多种形态</div>![1568873343511](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568873343511.png)<p><img src="/posts/9364fbab/1568873363029.png" alt="1568873363029"></p><div class="note success">使用封装重新组合的相关的变量和函数，这样可以减少复杂性，可以在程序的不同部分重用这些对象 或者在不同程序中，通过抽象，隐藏细节和复杂性，只显示必要性，这种技术降低了复杂性，也隔离了代码更改的影响。 继承让我们消除多余的代码 多态性可以避免写出复杂丑陋的选择性代码</div><p><img src="/posts/9364fbab/1568873756718.png" alt="1568873756718"></p><h2 id="原型与原型继承"><a href="#原型与原型继承" class="headerlink" title="原型与原型继承"></a>原型与原型继承</h2><p>原型<code>Prototypes</code> 和 原型继承<code>Prototyical Inheritance</code></p><p>JavaScript 中的类并不同于 Java 或者 c#中的类，因为 Javascript 是动态语言，所以类的本质上是更像是为了配合原型和原型继承所采取的必要的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字面量创建对象</span></span><br><span class="line"><span class="keyword">const</span> circle = &#123;&#125;;</span><br><span class="line"><span class="comment">//一个Javascript的对象实际上是一组键值对的集合</span></span><br><span class="line"><span class="comment">//使用字面量语法来创建多个对象是有问题的，那就是对象的行为性，就像人一样可以做很多事就叫做行为性。</span></span><br><span class="line"><span class="comment">//解决方法就是用工厂函数（factory）或者构造函数（constructor）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    radius,</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle2 = createCircle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = raius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle3 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//当我们使用new操作符调用一个函数时，3件事发生了</span></span><br><span class="line"><span class="comment">//首先new操作符创建了一个空对象，然后设置this指向这个对象，最后返回这个对象</span></span><br></pre></td></tr></table></figure><p>补充：</p><p><a href="https://www.baidu.com/s?wd=字面量&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">字面量</a>是变量的字符串表示形式。它不是一种值，而是一种变量记法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">//1是字面量</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">"hello world"</span>; <span class="comment">//hello world是字面量</span></span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//[1,2,3]是字面量</span></span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;; <span class="comment">//&#123;"foo":"bar"&#125;是字面量</span></span><br></pre></td></tr></table></figure><p>每个对象都有构造函数属性</p><p>这个属性引用了用来创建这个对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(); <span class="comment">// ''," ",``</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(); <span class="comment">// true ,false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(); <span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/9364fbab/1568897883740.png" alt="1568897883740"></p><div class="note info"><p>值类型复制值</p><p>对象或者引用类型复制他们的引用</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    number++;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number) <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> object=&#123;<span class="attr">value</span>:<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">object.value++;</span><br><span class="line">&#125;</span><br><span class="line">increase(object);</span><br><span class="line"><span class="built_in">console</span>.log(object) <span class="comment">//&#123;value:11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>不知道要访问的对象名称属性，是在运行时产生的，可以使用方括号的语法,或者属性名不符合命名规则时。</p><p>抽象意味着我们应该隐藏细节和复杂部分，只显示或者暴露必要的部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.defaultLocaltion=&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>&#125; <span class="comment">// ====&gt; let defaultLocaltion=&#123;x:0,y:1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'defaultLocaltion'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultLocaltion</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        defaultLocaltion=value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div class="note info">Javascript 中没有类，只有对象，那只有对象的时候如何引入继承？答案是原型。 原型可以理解为一个对象的父母，原型就是一般的对象。</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">writable: <span class="literal">false</span>,</span><br><span class="line">enumerable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: 'hello' &#125;</span></span><br></pre></td></tr></table></figure><p>获得对象原型的方法是调用 Object 对象的 getPrototypeOf 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">Circle.prototype; <span class="comment">//这是构造函数创建的对象的父母真身</span></span><br><span class="line">circle.__proto__ === Circle.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object.keys 只返回实例的成员</p><p>for-in 循环返回所有的成员，对象实例本身的和它的原型的</p><p><img src="/posts/9364fbab/1568956155416.png" alt="1568956155416"></p><p><img src="/posts/9364fbab/1568982071111.png" alt="1568982071111"></p><p>在 Javascript 中，有个函数可以从给定的原型创建对象，就是 Object.create(第一个参数是用作创建的原型)</p><p>Javascript 里每个对象都有一个构造函数属性，能返回用以创建这个对象的构造函数</p><p>避免创建层级式继承关系，因为这十分脆弱。如果要用继承特性，最好维持在一级。好的组合胜过继承。</p><p><img src="/posts/9364fbab/1568984473440.png" alt="1568984473440"></p><p><img src="/posts/9364fbab/1568984534425.png" alt="1568984534425"></p><div class="note info">Object.assign()可以用这个方法从一个对象拷贝所有成员到另外一个对象</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> canEat = &#123;</span><br><span class="line">      eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eating"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> canWalk = &#123;</span><br><span class="line">      walk: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eating"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> canSwin = &#123;</span><br><span class="line">      swin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"swining"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//   const person = Object.assign(&#123;&#125;, canEat, canWalk);</span></span><br><span class="line"><span class="comment">// 空对象实际上变成了2个对象的组合</span></span><br><span class="line">    <span class="comment">//   console.log(person);</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">target, ...sources</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(target.prototype, ...sources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   function Person() &#123;&#125;</span></span><br><span class="line">    <span class="comment">//   Object.assign(Person.prototype, canEat, canWalk);</span></span><br><span class="line">    <span class="comment">//   console.log(new Person());</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    mixins(Dog, canEat, canWalk);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> Dog());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">GoldFish</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    mixins(GoldFish, canEat, canSwin);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> GoldFish());</span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>函数声明 <code>funciton sayHello(){}</code> 结尾不需要加分号，函数声明是置顶的。</p><p>函数表达式<code>const sayGoodbye=function(){}</code> 结尾需要加分号，不会被置顶。</p><p>不同于函数，类声明和类表达式都不会被置顶</p><p>实例方法和静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Instance Method</span></span><br><span class="line">  draw() &#123;&#125;</span><br><span class="line">  <span class="comment">// Static Mthod</span></span><br><span class="line">  <span class="keyword">static</span> parse(str) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; radius &#125; = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = Circle.parse(<span class="string">'&#123;"radius":1&#125;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Go: circle"</span>, circle); <span class="comment">// Go: circle Circle &#123; radius: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>所以我们用静态方法的方式创建不属于具体实例的工具函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// Method call</span></span><br><span class="line">c.draw(); <span class="comment">// Circle &#123; radius: 2 &#125;</span></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line"><span class="comment">// Function call</span></span><br><span class="line">draw(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ES6 私有</p><p>第一种是用在命名的时候加下划线</p><p>第二种是使用 Symbol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _draw = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// Symbol() 是一个函数，能创建一个Symbol，这个不是构造函数，不能在前面加new修饰符，这样会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>[_radius] = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  [_draw]() &#123;</span><br><span class="line">    <span class="comment">// 计算生成属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> key = <span class="built_in">Object</span>.getOwnPropertySymbols(c)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c[key]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>第三种是使用 WeakMap</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _move = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">    _move.set(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 箭头函数将从调用它的构造器继承过来，在这个构造器里。this是circle对象实例的引用。</span></span><br><span class="line">      <span class="comment">// 当我们在构造器函数里使用箭头函数时，this不会重新绑定，也不会重设，直接从构造器继承</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"moving"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    _move.get(<span class="keyword">this</span>)();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"drawing..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line">c.draw();</span><br></pre></td></tr></table></figure><p>getter&amp;&amp;setter</p><p>方法重写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"moving...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">super</span>.move();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"circle move"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p><img src="/posts/9364fbab/1569201901993.png" alt="1569201901993"></p><p>AMD，也就是异步模块定义，主要是在浏览器程序中使用。</p><p><img src="/posts/9364fbab/1569202170920.png" alt="1569202170920"></p><p><img src="/posts/9364fbab/1569202287766.png" alt="1569202287766"></p><p>CommonJS</p><blockquote><p>class Circle{</p><p>}</p><p>module.exports.Circle=Circle</p><p>只需要引入一个模块时，可以简化代码<code>module.exports=Circle</code></p><p>引入时，使用 require 函数。</p><p>所以时 CommonJS 定义了 require 函数和 module 函数，这是 CommonJS 当中的语法。</p></blockquote><p>ES6</p><blockquote><p>export &amp;&amp; import</p><script type="module" src="../"></script></blockquote><p>在模块化之前，要记住一个首要原则，高度关联的东西应该放在一起。就好比在厨房放置了杯子盘子勺子等餐具，不应该把衣服存放在厨房，这就是高度关联。这就是编程中说的 Cohesion(内聚)。</p><p><img src="/posts/9364fbab/1569203914069.png" alt="1569203914069"></p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>npm i -g webpack-cli</li><li>webpack-cli init</li><li>npm init –yes</li></ul><p><a href="https://www.bilibili.com/video/av35179218/?p=1" target="_blank" rel="noopener">完结</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;What-is-Object-oriented-Programming&quot;&gt;&lt;a href=&quot;#What-is-Object-oriented-Programming&quot; class=&quot;headerlink&quot; title=&quot;What is Object-oriented Programming&quot;&gt;&lt;/a&gt;What is Object-oriented Programming&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/9364fbab/1569242664504.png&quot; alt=&quot;1569242664504&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://blog.aigisss.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>mapboxgl实现marker的聚类</title>
    <link href="https://blog.aigisss.com/posts/a2d9d205.html"/>
    <id>https://blog.aigisss.com/posts/a2d9d205.html</id>
    <published>2019-09-17T05:08:43.000Z</published>
    <updated>2019-09-17T14:24:39.049Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><p><img src="/posts/a2d9d205/1568697066499.png" alt="1568697066499"></p><p><img src="/posts/a2d9d205/1568697307582.png" alt="1568697307582"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/a2d9d205/1568697066499.png&quot; alt=&quot;1568697066499&quot;&gt;&lt;/p&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="mapbox" scheme="https://blog.aigisss.com/tags/mapbox/"/>
    
  </entry>
  
  <entry>
    <title>vue学习与总结</title>
    <link href="https://blog.aigisss.com/posts/3d0c447.html"/>
    <id>https://blog.aigisss.com/posts/3d0c447.html</id>
    <published>2019-09-16T01:29:36.000Z</published>
    <updated>2019-09-25T14:02:20.474Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><a id="more"></a><ul><li><p>v-cloak</p></li><li><p>v-text</p></li><li><p>v-html</p></li><li><p>v-bind(缩写:)</p></li><li><p>v-on(缩写@)</p></li><li><p>v-model 只能用于表单元素</p></li><li><p>v-for</p></li><li><p>v-if</p></li><li><p>v-show</p><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换，v-show 较好，如果运行时条件不太可能改变 v-if 较好</p></blockquote></li></ul><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ul><li>.stop 阻止冒泡</li><li>.prevent 阻止默认事件</li><li>.capture 添加事件侦听器时使用事件捕获模式</li><li>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</li><li>.once 事件只触发一次</li></ul><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li>数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>数组中使用三元表达式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>数组中嵌套对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>直接使用对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</li></ol><ul><li>在data上定义样式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</li></ol><ul><li>在data上定义样式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;,</span><br><span class="line">        h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class="line"></span><br><span class="line">    dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错</span><br><span class="line"></span><br><span class="line">      var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">      // 获取年月日</span><br><span class="line"></span><br><span class="line">      var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">      var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">      var d = dt.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">      // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">      if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 获取时分秒</span><br><span class="line"></span><br><span class="line">        var hh = dt.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">        var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">        var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局过滤器</span><br><span class="line"></span><br><span class="line">Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123;</span><br><span class="line"></span><br><span class="line">  var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">  // 获取年月日</span><br><span class="line"></span><br><span class="line">  var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">  var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">  var d = dt.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">  // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">  if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 获取时分秒</span><br><span class="line"></span><br><span class="line">    var hh = dt.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">    var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">    var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用自定义的按键修饰符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><ul><li><p>使用 Vue.directive()定义全局的指令，比如 v-focus</p></li><li><p>其中 参数 1：指令的名称，定义时不需要加 v-的前缀</p></li><li><p>使用的时候必须在指令名称前面加上 v-前缀来调用</p></li><li><p>参数 2：是一个对象，这个对象上有一些指令相关的函数，这些函数可以在特定的阶段执行相关的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.dirctive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">bind:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line"><span class="comment">//每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次</span></span><br><span class="line">    <span class="comment">//每个函数中的第一个参数永远是el表示被绑定的指令的那个元素，是原生的js对象</span></span><br><span class="line">    <span class="comment">//每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次</span></span><br><span class="line">    <span class="comment">// 和样式相关的操作，一般都可以在bind执行</span></span><br><span class="line">&#125;,</span><br><span class="line">    inserted(el)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">      <span class="comment">// 和js行为相关的操作，最好在inserted中执行，防止js行为不生效</span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated(el)&#123;</span><br><span class="line">       <span class="comment">//当Vnode更新时，会执行updated，可能会触发多次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>私有指令的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dirctives:&#123;</span><br><span class="line">     <span class="comment">//自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span></span><br><span class="line"> <span class="string">'fontsize'</span>:<span class="function"><span class="keyword">function</span> (<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">         el.style.fontSize=binding.value</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义指令的使用方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现筛选的方式显示过滤-排序结果："><a href="#实现筛选的方式显示过滤-排序结果：" class="headerlink" title="实现筛选的方式显示过滤-排序结果："></a>实现筛选的方式显示过滤-排序结果：</h3><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr&gt; 输入筛选名称：</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line"></span><br><span class="line">      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;</span><br><span class="line"></span><br><span class="line">          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/tbody&gt;</span><br></pre></td></tr></table></figure><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">search(name) &#123;</span><br><span class="line"></span><br><span class="line">  return this.list.filter(x =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return x.name.indexOf(name) != -1;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP的实现原理"><a href="#JSONP的实现原理" class="headerlink" title="JSONP的实现原理"></a>JSONP的实现原理</h2><ul><li><p>由于浏览器安全限制，不允许AXAJ访问协议不同、域名不同、端口号不同——不符合同源策略的。</p></li><li><p>可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址。因为script标签不存在跨域限制，这种数据获取方式称之为JSONP</p></li><li><p>具体实现过程</p><ul><li><p>先在客户端定义一个回调方法，预定义对数据的操作；</p></li><li><p>再把这个回调方法的名称通过URL传参的形式提交到服务器的数据接口；</p></li><li><p>服务器数据接口组织好要发送给客户端的数据，再拿客户端传递过来的回调方法名称拼接出一个调用这个方法的字符串，发送给客户端解析执行；</p></li><li><p>客户端拿到服务器的返回的字符串之后，当作script脚本执行。</p></li><li><p>Node.js 实现一个JSONP的请求例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">    // 导入解析 URL 地址的核心模块</span><br><span class="line">    const urlModule = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">    const server = http.createServer();</span><br><span class="line">    // 监听 服务器的 request 请求事件，处理每个请求</span><br><span class="line">    server.on(&apos;request&apos;, (req, res) =&gt; &#123;</span><br><span class="line">      const url = req.url;</span><br><span class="line"></span><br><span class="line">      // 解析客户端请求的URL地址</span><br><span class="line">      var info = urlModule.parse(url, true);</span><br><span class="line"></span><br><span class="line">      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据</span><br><span class="line">      if (info.pathname === &apos;/getjsonp&apos;) &#123;</span><br><span class="line">        // 获取客户端指定的回调函数的名称</span><br><span class="line">        var cbName = info.query.callback;</span><br><span class="line">        // 手动拼接要返回给客户端的数据对象</span><br><span class="line">        var data = &#123;</span><br><span class="line">          name: &apos;zs&apos;,</span><br><span class="line">          age: 22,</span><br><span class="line">          gender: &apos;男&apos;,</span><br><span class="line">          hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：</span><br><span class="line">        var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`;</span><br><span class="line">        // 将拼接好的方法的调用，返回给客户端去解析执行</span><br><span class="line">        res.end(result);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.end(&apos;404&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.listen(3000, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;server running at =http://127.0.0.1:3000&apos;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><ol><li>HTML结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt;</span><br><span class="line">    &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span><br><span class="line">    &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">      &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>VM 实例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Vue 实例，得到 ViewModel</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isshow: false</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      this.isshow = !this.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>定义两组类样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 定义进入和离开时候的过渡状态 */</span><br><span class="line">    .fade-enter-active,</span><br><span class="line">    .fade-leave-active &#123;</span><br><span class="line">      transition: all 0.2s ease;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span><br><span class="line">    .fade-enter,</span><br><span class="line">    .fade-leave-to &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      transform: translateX(100px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h3><ol><li>导入动画类库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义 transition 及属性：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">enter-active-class=&quot;fadeInRight&quot;</span><br><span class="line">    leave-active-class=&quot;fadeOutRight&quot;</span><br><span class="line">    :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol><li>定义 transition 组件以及三个钩子函数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt;</span><br><span class="line">    &lt;transition</span><br><span class="line">    @before-enter=&quot;beforeEnter&quot;</span><br><span class="line">    @enter=&quot;enter&quot;</span><br><span class="line">    @after-enter=&quot;afterEnter&quot;&gt;</span><br><span class="line">      &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义三个 methods 钩子方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; // 动画进入之前的回调</span><br><span class="line">          el.style.transform = &apos;translateX(500px)&apos;;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; // 动画进入完成时候的回调</span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = &apos;translateX(0px)&apos;;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; // 动画进入完成之后的回调</span><br><span class="line">          this.isshow = !this.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义动画过渡时长和样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.show&#123;</span><br><span class="line">      transition: all 0.4s ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h3><ol><li>定义过渡样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .list-enter,</span><br><span class="line">    .list-leave-to &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      transform: translateY(10px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .list-enter-active,</span><br><span class="line">    .list-leave-active &#123;</span><br><span class="line">      transition: all 0.3s ease;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义 VM中的结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Vue 实例，得到 ViewModel</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    txt: &apos;&apos;,</span><br><span class="line">    list: [1, 2, 3, 4]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.list.push(this.txt);</span><br><span class="line">      this.txt = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.v-move&#123;</span><br><span class="line">  transition: all 0.8s ease;</span><br><span class="line">&#125;</span><br><span class="line">.v-leave-active&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；</li></ul><h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><ol><li>使用 Vue.extend 配合 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var login = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.component(&apos;login&apos;, login);</span><br></pre></td></tr></table></figure><ol start="2"><li>直接使用 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;register&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>将模板字符串，定义到script标签种：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同时，需要使用 Vue.component 来定义组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;, &#123;</span><br><span class="line">      template: &apos;#tmpl&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol><li>在组件中，<code>data</code>需要被定义为一个方法，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;, &#123;</span><br><span class="line">      template: &apos;#tmpl&apos;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &apos;大家好！&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(&apos;点击了登录按钮&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li></ol><h2 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h2><p>vue 提供了 component，来展示对应的名称组件<br>component 是一个占位符,:is 属性，可以用来指定展示的组件的名称</p><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;这是父组件中的消息&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">          props: [&apos;finfo&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func=<span class="string">"getMsg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type=<span class="string">"x-template"</span> id=<span class="string">"son"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"向父组件传值"</span> @click=<span class="string">"sendMsg"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 子组件的定义方式</span></span><br><span class="line"><span class="regexp">    Vue.component('son', &#123;</span></span><br><span class="line"><span class="regexp">      template: '#son', /</span><span class="regexp">/ 组件模板Id</span></span><br><span class="line"><span class="regexp">      methods: &#123;</span></span><br><span class="line"><span class="regexp">        sendMsg() &#123; /</span><span class="regexp">/ 按钮的点击事件</span></span><br><span class="line"><span class="regexp">          this.$emit('func', 'OK'); /</span><span class="regexp">/ 调用父组件传递过来的方法，同时把数据传递出去</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="regexp">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">      el: '#app',</span></span><br><span class="line"><span class="regexp">      data: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">      methods: &#123;</span></span><br><span class="line"><span class="regexp">        getMsg(val)&#123; /</span><span class="regexp">/ 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span></span><br><span class="line"><span class="regexp">          alert(val);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;插值表达式&quot;&gt;&lt;a href=&quot;#插值表达式&quot; class=&quot;headerlink&quot; title=&quot;插值表达式&quot;&gt;&lt;/a&gt;插值表达式&lt;/h2&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="vue" scheme="https://blog.aigisss.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>重构2——改善既有代码的设计</title>
    <link href="https://blog.aigisss.com/posts/b189f81a.html"/>
    <id>https://blog.aigisss.com/posts/b189f81a.html</id>
    <published>2019-09-14T15:05:54.000Z</published>
    <updated>2019-09-18T15:20:01.984Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><p><img src="/posts/b189f81a/005Ouxuxgy1g1omsp9johj33281j4u0x.jpg" alt></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note info">都能写出计算机可以理解代码，唯有写出人类容易理解的代码的，才是优秀的程序员。<p>好代码的标准就是人们能否轻而易举地修改它</p></div><h1 id="重构的原则"><a href="#重构的原则" class="headerlink" title="重构的原则"></a>重构的原则</h1><h2 id="何谓重构"><a href="#何谓重构" class="headerlink" title="何谓重构"></a>何谓重构</h2><p>重构这个词既可以是名词也可以是动词，名词形式的定义的是：</p><div class="note info">对软件内部结构的调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</div>动词形式的定义的是：<div class="note success">使用一系列的重构手法，在不改变可观察行为的前提下，调整其结构</div><h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><ul><li>重构改进软件的设计</li><li>重构时软件更容易理解</li><li>重构帮助找到bug</li><li>重构提高编程速度</li></ul><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><ul><li>预备性重构：让添加的新功能更容易</li><li>帮助理解的重构：使代码更容易理解</li><li>捡垃圾式重构</li><li>有计划的重构和见机行事的重构</li><li>长期重构</li><li>复审代码时重构</li></ul><h2 id="何时不重构"><a href="#何时不重构" class="headerlink" title="何时不重构"></a>何时不重构</h2><ul><li>重写比重构还容易</li></ul><p>只有需要理解其工作原理时，对其重构才有价值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/b189f81a/005Ouxuxgy1g1omsp9johj33281j4u0x.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="摘抄" scheme="https://blog.aigisss.com/tags/%E6%91%98%E6%8A%84/"/>
    
      <category term="总结" scheme="https://blog.aigisss.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中python代码输出中文乱码解决方法</title>
    <link href="https://blog.aigisss.com/posts/87ed0839.html"/>
    <id>https://blog.aigisss.com/posts/87ed0839.html</id>
    <published>2019-09-12T02:10:35.000Z</published>
    <updated>2019-09-13T13:15:19.446Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><h2 id="在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法："><a href="#在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：" class="headerlink" title="在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法："></a>在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：</h2><p><img src="/posts/87ed0839/1568254353802.png" alt="1568254353802"></p><a id="more"></a><h3 id="先检查右下角编码集设置是否正确"><a href="#先检查右下角编码集设置是否正确" class="headerlink" title="先检查右下角编码集设置是否正确"></a>先检查右下角编码集设置是否正确</h3><p><img src="/posts/87ed0839/1568254487426.png" alt="1568254487426"></p><h3 id="修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索-code-runner-executorMap-选项，提示需要在-setting-json-中修改"><a href="#修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索-code-runner-executorMap-选项，提示需要在-setting-json-中修改" class="headerlink" title="修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改"></a>修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改</h3><p><img src="/posts/87ed0839/1568254594172.png" alt="1568254594172"></p><p>在 json 中添加下列属性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"code-runner.executorMap": &#123;</span><br><span class="line">"python": "set PYTHONIOENCODING=utf8 &amp;&amp; python -u"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default">https://mp.weixin.qq.com/s/QIJ-QHkxZUyKyQAPG49vPg</div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：&quot;&gt;&lt;a href=&quot;#在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：&quot; class=&quot;headerlink&quot; title=&quot;在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：&quot;&gt;&lt;/a&gt;在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/87ed0839/1568254353802.png&quot; alt=&quot;1568254353802&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://blog.aigisss.com/tags/python/"/>
    
      <category term="vscode" scheme="https://blog.aigisss.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo下next主题时出错</title>
    <link href="https://blog.aigisss.com/posts/326cb881.html"/>
    <id>https://blog.aigisss.com/posts/326cb881.html</id>
    <published>2019-09-09T01:58:21.000Z</published>
    <updated>2019-09-13T13:16:29.267Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><div class="note danger"><h4 id="next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin-时会不起作用"><a href="#next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin-时会不起作用" class="headerlink" title="next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用"></a>next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用</h4><p>在主题下的<code>_config.yml</code>文件中设置：</p><h4 id="使用了-hexo-asset-image-和-hexo-abbrlink-后，图片显示不出来。"><a href="#使用了-hexo-asset-image-和-hexo-abbrlink-后，图片显示不出来。" class="headerlink" title="使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。"></a>使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。</h4><p>issue：<a href="https://github.com/rozbo/hexo-abbrlink/issues/19" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink/issues/19</a></p><p>解决方法：<a href="https://github.com/foreveryang321/hexo-asset-image" target="_blank" rel="noopener">https://github.com/foreveryang321/hexo-asset-image</a></p></div><p><img src="/posts/326cb881/QQ%E5%9B%BE%E7%89%8720190911114226.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;h4 id=&quot;next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo + NexT 快速搭建博客</title>
    <link href="https://blog.aigisss.com/posts/eba3f111.html"/>
    <id>https://blog.aigisss.com/posts/eba3f111.html</id>
    <published>2019-09-07T07:34:54.000Z</published>
    <updated>2019-09-15T15:26:12.570Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><img src="/posts/eba3f111/pic1.png"><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h2><div class="note success"><p>如果你已经安装了 node.js，请忽略。</p></div><p>访问<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js 官网</a>，根据指引进行安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><div class="note success"><p>如果你已经安装了 Git，请忽略。</p></div><p>访问<a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a>，根据指引进行安装。</p><div class="note warning"><p>由于众所周知的原因，Windows 从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></div><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ul><li><p><strong>国内的朋友</strong>，因为众所周知的原因，从 npm 直接安装 hexo 会非常慢，所以你需要用到<a href="https://npm.taobao.org/" target="_blank" rel="noopener"><strong>镜像源</strong></a>，参考上面的步骤，使用 cnpm 命令行工具代替默认的 npm: 在 windows 控制台（cmd）里输入并执行<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>，然后安装 hexo: <code>cnpm install -g hexo-cli</code></p></li><li><p><strong>国外的朋友</strong>，请直接打开 windows 控制台，输入<code>npm install -g hexo-cli</code>并执行。</p></li></ul><hr><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="建立本地博客文件夹"><a href="#建立本地博客文件夹" class="headerlink" title="建立本地博客文件夹"></a>建立本地博客文件夹</h2><p>在命令行执行如下命令，其中<code>&lt;folder&gt;</code>为文件夹路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br></pre></td></tr></table></figure><div class="note warning"><p><strong>所有有关<code>hexo</code>的命令</strong> 均要在<code>&lt;folder&gt;</code>路径下执行。</p></div><p>建立好后文件夹目录如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── node_modules</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><p><code>_config.yml</code>：站点的配置文件，可以在此配置大部分的参数。</p></li><li><p><code>package.json</code>：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line"><span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"hexo"</span>: &#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"3.9.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"dependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"3.9.0"</span></span><br><span class="line"><span class="string">"hexo-generator-archive"</span>: <span class="string">"^0.1.5"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.3"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^1.0.1"</span>,</span><br><span class="line"><span class="attr">"hexo-server"</span>: <span class="string">"^0.3.3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>scaffolds：模板文件夹，是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p></li><li><p>source：资源文件夹，存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></li><li><p>themes：主题文件夹。Hexo 会根据主题来生成静态页面。</p></li><li><p>node_modules：node.js 模块，一些 <strong>插件</strong> 和 <strong>依赖</strong> 会被安装到这里。</p></li></ul><div class="note info"><p>更加详细的解释请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a></p></div><h3 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h3><p>进入本地博客文件夹并将 NexT 主题<code>clone</code>至<code>themes</code>文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>你会看到，在<code>next</code>下也有一个<code>_config.yml</code>的文件，这是 <strong>NexT 主题的配置文件</strong>，为了区别它和 <strong>博客配置文件</strong>，下面会用带路径的文件名来描述它们：</p><ul><li><code>&lt;folder&gt;/_config.yml</code>：站点配置文件</li><li><code>next/_config.yml</code>：主题配置文件</li></ul><h2 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a>启用 NexT 主题</h2><p>在<code>&lt;folder&gt;/_config.yml</code>里<code>theme:</code>选项填<code>next</code>，=&gt;<code>theme: next</code>，注意冒号后空一格。</p><p>到这里，建站的任务就完成了。你现在可以打开控制台，输入并执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>完成没有报错之后执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>hexo g</code>：新建<code>public</code>文件夹，并在其中生成网站静态文件（html，css，等文件）</li><li><code>hexo s</code>：启动 hexo 服务器，默认情况下，访问网址为：<code>http://localhost:4000/</code></li></ul><div class="note info"><p>更多有关 hexo 的命令，请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a>的<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">命令</a>部分。</p></div><p>你最后会看到控制台有如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在浏览器地址栏输入<code>http://localhost:4000/</code>并访问，你应该会看到如下页面：</p><img src="/posts/eba3f111/pic2.png"><div class="note success"><i class="fa fa-thumbs-o-up" aria-hidden="true"></i>&nbsp;**恭喜你！你已经完成了博客搭建的主要工作！接下来就是细节的配置了。请耐心阅读以下内容。**</div><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="网站脚注"><a href="#网站脚注" class="headerlink" title="网站脚注"></a>网站脚注</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment">#建站时间</span></span><br><span class="line"><span class="attr">  since:</span> <span class="number">2018</span></span><br><span class="line">  <span class="comment">#作者头像并且是动画效果</span></span><br><span class="line"><span class="attr">  icon:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">    animated:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">"##66CDAA"</span></span><br><span class="line">  <span class="comment">#显示版权作者</span></span><br><span class="line"><span class="attr">  copyright:</span> <span class="string">aigisss</span> <span class="string">爱即是诗</span></span><br><span class="line">  <span class="comment">#不显示Hexo</span></span><br><span class="line"><span class="attr">  powered:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#不显示主题和版本</span></span><br><span class="line"><span class="attr">  theme:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#显示备案号</span></span><br><span class="line"><span class="attr">  beian:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    icp:</span> <span class="string">赣ICP备18013338-1号</span></span><br></pre></td></tr></table></figure><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># 自定义边框半径，默认是1</span></span><br><span class="line">  <span class="comment"># 值越大弧度越大</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">6</span></span><br><span class="line">  <span class="comment"># 右上角显示复制按钮</span></span><br><span class="line"><span class="attr">  copy_button:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 显示复制结果</span></span><br><span class="line"><span class="attr">    show_result:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  postbottom:</span></span><br><span class="line">    <span class="comment">#文章底部</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">bottomCenter</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">      <span class="comment">#左下角悬浮按钮</span></span><br><span class="line"><span class="attr">  float:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">middleRight</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br></pre></td></tr></table></figure><h2 id="访问次数"><a href="#访问次数" class="headerlink" title="访问次数"></a>访问次数</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># busuanzi统计</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 总访客数</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="comment"># 总浏览量</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="comment"># 文章浏览量</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><h2 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">"#37c6c0"</span></span><br><span class="line"><span class="attr">  height:</span> <span class="number">2</span><span class="string">px</span></span><br></pre></td></tr></table></figure><h2 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="comment"># 启用</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 异步加载</span></span><br><span class="line"><span class="attr">  async:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line">    <span class="comment"># 文章摘要动画</span></span><br><span class="line"><span class="attr">    post_block:</span> <span class="string">bounceIn</span></span><br><span class="line">    <span class="comment"># 加载各种页面动画（分类，关于，标签等等）</span></span><br><span class="line"><span class="attr">    post_header:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment"># 文章详情动画</span></span><br><span class="line"><span class="attr">    post_body:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="attr">    coll_header:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="comment"># 侧边栏（人物头像的那部分）</span></span><br><span class="line"><span class="attr">    sidebar:</span> <span class="string">fadeIn</span></span><br></pre></td></tr></table></figure><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p><code>NexT</code>自带提供了两个搜索</p><ul><li><code>algolia_search</code></li><li><code>local_search</code></li></ul><p>其实这个<code>local_search</code>已经很好用了，配置<code>algolia_search</code>挺麻烦的，而且搜索功能也用的不多</p><p>毕竟有万能的<code>Ctrl + F</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line"><span class="attr">  unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="添加-RSS-订阅"><a href="#添加-RSS-订阅" class="headerlink" title="添加 RSS 订阅"></a>添加 RSS 订阅</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span> <span class="bullet">--save</span></span><br><span class="line"></span><br><span class="line"><span class="string">复制代码</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">   <span class="string">hexo-generate-feed</span></span><br><span class="line"><span class="attr">feed:</span> <span class="comment"># RSS订阅插件</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">0</span> <span class="comment">#0就是代表所有</span></span><br></pre></td></tr></table></figure><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default(true) will load mathjax/katex script on demand</span></span><br><span class="line">  <span class="comment"># That is it only render those page who has 'mathjax: true' in Front Matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="comment">#engine: katex</span></span><br></pre></td></tr></table></figure><p>还需要在文章的 Front-matter 里打开 mathjax 开关，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">使用hexo下next主题搭建博客的记录</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">日常</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="number">326</span><span class="string">cb881</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-09</span><span class="bullet">-09</span> <span class="number">09</span><span class="string">:58:21</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>网上一大堆说会出现语义冲突—–类 Latex 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括<code>*</code>, <code>{</code>, <code>}</code>, <code>\\</code>等。但是！！</p></blockquote><div class="note danger"><p>在我试验下没有出现此类问题，只要在主题中打开，md 中申明 mathjax: true 就好了，可能在我使用的<code>next6.7</code>中解决了冲突。比如以下的公式能出来！</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span><br></pre></td></tr></table></figure><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">P = \frac</span><br><span class="line">&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;</span><br><span class="line">&#123;\displaystyle \left[</span><br><span class="line">\sum_&#123;i=1&#125;^n (x_i-x)^2</span><br><span class="line">\sum_&#123;i=1&#125;^n (y_i-y)^2</span><br><span class="line">\right]^&#123;1/2&#125; &#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>P = \frac<br>{\sum_{i=1}^n (x_i- x)(y_i- y)}<br>{\displaystyle \left[<br>\sum_{i=1}^n (x_i-x)^2<br>\sum_{i=1}^n (y_i-y)^2<br>\right]^{1/2} }<br>$$</p><h2 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h2><p>以新建「相册」菜单为例：在博客目录下的 source 文件夹下新建名为 photo 文件夹，然后在 photo 文件夹下新建一个 index.md 文件，然后在该文件填写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">相册</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-04</span><span class="bullet">-16</span> <span class="number">22</span><span class="string">:14:07</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"photo"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>然后打开主题配置文件 <code>_config.yml</code>，在 menu 中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment">#添加「相册」菜单</span></span><br><span class="line">  <span class="string">相册:</span> <span class="string">/photo</span> <span class="string">||</span> <span class="string">camera</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的「相册」是博客中显示的菜单名称，紧跟的 photo 要和前面 index.md 文件的 type 值一致，|| 后面的菜单的图标，图标名称来自于 FontAwesome icon，若没有配置图标，默认会使用问号图标</p></blockquote><h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ol><li><strong><em><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db" target="_blank" rel="noopener">Hexo+NexT 打造一个炫酷博客</a></em></strong></li><li><strong><em><a href="https://juejin.im/post/5a71ab9f518825735300ee6c" target="_blank" rel="noopener">篇Ⅱ：NexT主题的配置和优化指南</a></em></strong></li></ol></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;img src=&quot;/posts/eba3f111/pic1.png&quot;&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>git的操作记录</title>
    <link href="https://blog.aigisss.com/posts/d5d49586.html"/>
    <id>https://blog.aigisss.com/posts/d5d49586.html</id>
    <published>2019-09-07T00:41:08.000Z</published>
    <updated>2019-09-18T15:22:28.368Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><h3 id="与服务器上的代码产生冲突"><a href="#与服务器上的代码产生冲突" class="headerlink" title="与服务器上的代码产生冲突"></a>与服务器上的代码产生冲突</h3><p>如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:</p><div class="note danger"><p>error: Your local changes to the following files would be overwritten by merge:<br>protected/config/main.php<br>Please, commit your changes or stash them before you can merge.</p></div><p>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>git diff -w +文件名</code>来确认代码自动合并的情况.</p><p>反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>其中 <code>git reset</code> 是针对版本,如果想针对文件回退本地修改,使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD file/to/restore</span><br></pre></td></tr></table></figure><h3 id="辛辛苦苦加班一星期敲的代码没了"><a href="#辛辛苦苦加班一星期敲的代码没了" class="headerlink" title="辛辛苦苦加班一星期敲的代码没了"></a>辛辛苦苦加班一星期敲的代码没了</h3><p>过程是这样的，在终端输入 git log，列出所有的 commit 信息，如下图：</p><p><img src="/posts/d5d49586/1568253175476.png" alt="1568253175476"></p><p>commit 的信息很简单，就是做了 6 个功能，每个功能对应一个 commit 的提交，分别是 feature-1 到 feature-6。</p><p>接下来执行了强制回滚，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 2216d4e</span><br></pre></td></tr></table></figure><p>回滚到了 feature-1 上，并且回滚的时候加了–hard，导致之前 feature-2 到 feature-6 的所有代码全部弄丢了，现在 git log 的显示如下：</p><p><img src="/posts/d5d49586/1568253317626.png" alt="1568253317626"></p><p>现在 feature-2 到 feature-6 的代码没了。。。。。</p><p>然鹅还没完，在这个基础上新添加了一个 commit 提交，信息叫 feature-7，如下图：</p><p><img src="/posts/d5d49586/1568253390009.png" alt="1568253390009"></p><p>现在 feature-2 到 feature-6 全没了，还多了一个 feature-7</p><div class="note info"><p>请问 如何把丢失的代码 feature-2 到 feature-6 全部恢复回来，并且 feature-7 的代码也要保留</p></div><p><strong>用git reflog和git cherry-pick就能解决</strong></p><p>在终端里输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>然后就会展示出所有你之前git操作，你以前所有的操作都被git记录了下来，如下图：</p><p><img src="/posts/d5d49586/1568296363901.png" alt="1568296363901"></p><p>这时候要记好两个值：4c97ff3和cd52afc，他们分别是feature-7和feature-6的hash码。然后执行回滚，回到feature-6上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard cd52afc</span><br></pre></td></tr></table></figure><p>现在我们回到了feature-6上，如下图：</p><p><img src="/posts/d5d49586/1568296459828.png" alt="1568296459828"></p><p>我们回到了feature-6上，但是feature-7没了，如何加上来呢？</p><p>这个时候就用上了git cherry-pick，刚刚我们知道了feature-7的hash码为4c97ff3，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 4c97ff3</span><br></pre></td></tr></table></figure><p>回车之后，你的feature-7的代码就回来了。</p><p>期间可能会有一些冲突，按照提示解决就好。最后的结果如下图：</p><p><img src="/posts/d5d49586/169d3f52baa26b7e.png" alt></p><p>feature-1 到 feature-7的代码就合并到了一起，以前的代码也都回来了。</p><p><a href="https://juejin.im/post/5cbd82165188250a926108bd?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文出自前端时光机</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;与服务器上的代码产生冲突&quot;&gt;&lt;a href=&quot;#与服务器上的代码产生冲突&quot; class=&quot;headerlink&quot; title=&quot;与服务器上的代码产生冲突&quot;&gt;&lt;/a&gt;与服务器上的代码产生冲突&lt;/h3&gt;&lt;p&gt;如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:&lt;/p&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;error: Your local changes to the following files would be overwritten by merge:&lt;br&gt;protected/config/main.php&lt;br&gt;Please, commit your changes or stash them before you can merge.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="git" scheme="https://blog.aigisss.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用coding-pages时出现静态文件丢失</title>
    <link href="https://blog.aigisss.com/posts/372cd070.html"/>
    <id>https://blog.aigisss.com/posts/372cd070.html</id>
    <published>2019-09-05T01:32:57.000Z</published>
    <updated>2019-09-12T14:22:59.547Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --><p><img src="/posts/372cd070/1567646753123.png" alt></p><a id="more"></a><p>出现这种情况，发现静态资源都加载不到，后来网上搜索了半天，才发现原来你要打算用 coding 的 pages 服务部署你的博客的话，你创建项目的名字必须和用户名保持一致，不能自己随便自定义。我重新创建了一个和用户名一致的项目，部署到他的 pages 服务，访问正常</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 26 2019 23:40:39 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/372cd070/1567646753123.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
</feed>
