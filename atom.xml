<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AIGISSS</title>
  
  <subtitle>爱即是诗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.aigisss.com/"/>
  <updated>2019-10-08T15:34:43.109Z</updated>
  <id>https://blog.aigisss.com/</id>
  
  <author>
    <name>Gong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Threejs学习与总结基础篇</title>
    <link href="https://blog.aigisss.com/posts/fdb123cb.html"/>
    <id>https://blog.aigisss.com/posts/fdb123cb.html</id>
    <published>2019-10-08T15:01:36.000Z</published>
    <updated>2019-10-08T15:34:43.109Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="基础功能之-Camera-相机"><a href="#基础功能之-Camera-相机" class="headerlink" title="基础功能之 Camera 相机"></a>基础功能之 Camera 相机</h2><p>相机是 Three.js 抽象出来的一个对象，使用此对象，我们可以定义显示的内容，并且可以通过移动相机位置来显示不同的内容。</p><p>下面讲解一下 Three.js 中相机的通用属性和常用的相机对象。</p><h3 id="相机通用属性和方法"><a href="#相机通用属性和方法" class="headerlink" title="相机通用属性和方法"></a>相机通用属性和方法</h3><a id="more"></a><p>我们常用的相机有正交相机（OrthographicCamera）和透视相机（PerspectiveCamera）两种，用于来捕获场景内显示的物体模型。它们有一些通用的属性和方法。</p><h4 id="Object3D-的所有属性和方法"><a href="#Object3D-的所有属性和方法" class="headerlink" title="Object3D 的所有属性和方法"></a>Object3D 的所有属性和方法</h4><p>由于相机都继承自 THREE.Object3D 对象，所以像设置位置的 position 属性、rotation 旋转和 scale 缩放属性，可以直接对相机对象设置。我们甚至还可以使用 <code>add()</code> 方法，给相机对象添加子类，移动相机它的子类也会跟随着一块移动，我们可以使用这个特性制作一些比如 HUD 类型的显示界面。</p><h4 id="target-焦点属性和-lookAt-方法"><a href="#target-焦点属性和-lookAt-方法" class="headerlink" title="target 焦点属性和 lookAt() 方法"></a>target 焦点属性和 lookAt() 方法</h4><p>这两个方法的效果一定，都是调整相机的朝向，可以设置一个 <code>THREE.Vector3</code>（三维向量）点的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">camera.target = new THREE.Vector3(0, 0, 0);</span><br><span class="line">camera.lookAt(new THREE.Vector3(0, 0, 0));</span><br></pre></td></tr></table></figure><p>上面两个都是朝向了原点，我们也可以将相机的朝向改为模型网格的 position，如果物体的位置发生了变化，相机的焦点方向也会跟随变动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">camera.target = mesh.position;</span><br><span class="line">//或者</span><br><span class="line">camera.lookAt(mesh.position);</span><br></pre></td></tr></table></figure><h4 id="getWorldDirection"><a href="#getWorldDirection" class="headerlink" title="getWorldDirection()"></a>getWorldDirection()</h4><p>getWorldDirection() 方法可以获取当前位置到 target 位置的世界中的方向。方向也可以使用 <code>THREE.Vector3</code> 对象表示，所以该方法返回一个三维向量。</p><h3 id="OrthographicCamera-正交相机"><a href="#OrthographicCamera-正交相机" class="headerlink" title="OrthographicCamera 正交相机"></a>OrthographicCamera 正交相机</h3><p>使用正交相机 OrthographicCamera 渲染出来的场景，所有的物体和模型都按照它固有的尺寸和精度显示，一般使用在工业要求精度或者 2D 平面中，因为它能完整的显示物体应有的尺寸。</p><h4 id="创建正交相机"><a href="#创建正交相机" class="headerlink" title="创建正交相机"></a>创建正交相机</h4><p><img src="/posts/fdb123cb/54accde0-7573-11e8-ae69-7f0c27c81098" alt="OrthographicCamera"></p><p>上面的图片可以清晰的显示出正交相机显示的范围，它显示的内容是一个立方体结构，通过图片我们发现，只要确定 top、left、right、bottom、near 和 far 六个值，我们就能确定当前相机捕获场景的区域，在这个区域外面的内容不会被渲染，所以，我们创建相机的方法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.OrthographicCamera( left, right, top, bottom, near, far );</span><br></pre></td></tr></table></figure><p>下面我们创建了一个显示场景中相机位置前方长宽高都为4的盒子内的物体的正交相机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var orthographicCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0, 4);</span><br><span class="line">scene.add(orthographicCamera); //一般不需要将相机放置到场景当中，如果需要添加子元素等一些特殊操作，还是需要add到场景内</span><br></pre></td></tr></table></figure><p>正常情况相机显示的内容需要和窗口显示的内容为同样的比例才能够显示没有被拉伸变形的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var frustumSize = 1000; //设置显示相机前方1000高的内容</span><br><span class="line">var aspect = window.innerWidth / window.innerHeight; //计算场景的宽高比</span><br><span class="line">var orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 2000 ); //根据比例计算出left，top，right，bottom的值</span><br></pre></td></tr></table></figure><h4 id="动态修改正交相机属性"><a href="#动态修改正交相机属性" class="headerlink" title="动态修改正交相机属性"></a>动态修改正交相机属性</h4><p>我们也可以动态的修改正交相机的一些属性，注意修改完以后需要调用相机 updateProjectionMatrix() 方法来更新相机显存里面的内容，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var frustumSize = 1000; //设置显示相机前方1000高的内容</span><br><span class="line">var aspect = window.innerWidth / window.innerHeight; //计算场景的宽高比</span><br><span class="line">var orthographicCamera = new THREE.OrthographicCamera(); //实例化一个空的正交相机</span><br><span class="line">orthographicCamera.left = frustumSize * aspect / - 2; //设置left的值</span><br><span class="line">orthographicCamera.right = frustumSize * aspect / 2; //设置right的值</span><br><span class="line">orthographicCamera.top = frustumSize / 2; //设置top的值</span><br><span class="line">orthographicCamera.bottom = frustumSize / - 2; //设置bottom的值</span><br><span class="line">orthographicCamera.near = 1; //设置near的值</span><br><span class="line">orthographicCamera.far = 2000; //设置far的值</span><br><span class="line"></span><br><span class="line">//注意，最后一定要调用updateProjectionMatrix()方法更新</span><br><span class="line">orthographicCamera.updateProjectionMatrix();</span><br></pre></td></tr></table></figure><h4 id="窗口变动后的更新"><a href="#窗口变动后的更新" class="headerlink" title="窗口变动后的更新"></a>窗口变动后的更新</h4><p>由于浏览器的窗口可以随意修改，我们有时候需要监听浏览器窗口的变化，然后获取到最新的宽高比，再重新设置相关属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var aspect = window.innerWidth / window.innerHeight; //重新获取场景的宽高比</span><br><span class="line"></span><br><span class="line">//重新设置left right top bottom 四个值</span><br><span class="line">orthographicCamera.left = frustumSize * aspect / - 2; //设置left的值</span><br><span class="line">orthographicCamera.right = frustumSize * aspect / 2; //设置right的值</span><br><span class="line">orthographicCamera.top = frustumSize / 2; //设置top的值</span><br><span class="line">orthographicCamera.bottom = frustumSize / - 2; //设置bottom的值</span><br><span class="line"></span><br><span class="line">//最后，记得一定要更新数据</span><br><span class="line">orthographicCamera.updateProjectionMatrix();</span><br><span class="line"></span><br><span class="line">//显示区域尺寸变了，我们也需要修改渲染器的比例</span><br><span class="line">renderer.setSize(window.innerWidth, window.innerHeight);</span><br></pre></td></tr></table></figure><h3 id="PerspectiveCamera-透视相机"><a href="#PerspectiveCamera-透视相机" class="headerlink" title="PerspectiveCamera 透视相机"></a>PerspectiveCamera 透视相机</h3><p>透视相机是最常用的也是模拟人眼视角的一种相机，它所渲染生成的页面是一种近大远小的效果。</p><h4 id="创建透视相机"><a href="#创建透视相机" class="headerlink" title="创建透视相机"></a>创建透视相机</h4><p><img src="/posts/fdb123cb/e27d7170-7577-11e8-a337-9bdf53091bce" alt="PerspectiveCamera"></p><p>上面的图片就是一个透视相机的生成原理，我们先看看渲染的范围是如何生成的：</p><ul><li>首先，我们需要确定一个 fov 值，这个值是用来确定相机前方的垂直视角，角度越大，我们能够查看的内容就越多。</li><li>然后，我们又确定了一个渲染的宽高比，这个宽高比最好设置成页面显示区域的宽高比，这样我们查看生成画面才不会出现拉伸变形的效果，这时，我们可以确定前面生成内容的范围是一个四棱锥的区域。</li><li>最后，我们需要确定的就是相机渲染范围的最小值 near 和最大值 far，注意，这两个值都是距离相机的距离，确定完数值后，相机会显示的范围就是一个近小远大的四棱柱的范围，我们能够看到的内容都是在这个范围内的。</li></ul><p>通过上面的原理，我们需要设置 fov 垂直角度，aspect 视角宽高比例和 near 最近渲染距离 far 最远渲染距离，就能确定当前透视相机的渲染范围。</p><p>下面代码展示了一个透视相机的创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var perspectiveCamera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );</span><br><span class="line">scene.add( perspectiveCamera );</span><br></pre></td></tr></table></figure><p>我们设置了前方的视角为45度，宽度和高度设置成显示窗口的宽度除以高度的比例即可，显示距离为1到1000距离以内的物体。</p><h4 id="动态修改透视相机的属性"><a href="#动态修改透视相机的属性" class="headerlink" title="动态修改透视相机的属性"></a>动态修改透视相机的属性</h4><p>透视相机的属性创建完成后我们也可以根据个人需求随意修改，但是注意，相机的属性修改完成后，以后要调用 <code>updateProjectionMatrix()</code> 方法来更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var perspectiveCamera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );</span><br><span class="line">scene.add( perspectiveCamera );</span><br><span class="line"></span><br><span class="line">//下面为修改当前相机属性</span><br><span class="line">perspectiveCamera.fov = 75; //修改相机的fov</span><br><span class="line">perspectiveCamera.aspect = window.innerWidth/window.innerHeight; //修改相机的宽高比</span><br><span class="line">perspectiveCamera.near = 100; //修改near</span><br><span class="line">perspectiveCamera.far = 500; //修改far</span><br><span class="line"></span><br><span class="line">//最后更新</span><br><span class="line">perspectiveCamera.updateProjectionMatrix();</span><br></pre></td></tr></table></figure><h4 id="显示窗口变动后的回调"><a href="#显示窗口变动后的回调" class="headerlink" title="显示窗口变动后的回调"></a>显示窗口变动后的回调</h4><p>如果当前场景浏览器的显示窗口变动了，比如修改了浏览器的宽高后，我们需要设置场景自动更新，下面是一个常用的案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function onWindowResize() &#123;</span><br><span class="line">    camera.aspect = window.innerWidth / window.innerHeight; //重新设置宽高比</span><br><span class="line">    camera.updateProjectionMatrix(); //更新相机</span><br><span class="line">    renderer.setSize(window.innerWidth, window.innerHeight); //更新渲染页面大小</span><br><span class="line">&#125;</span><br><span class="line">window.onresize = onWindowResize;</span><br></pre></td></tr></table></figure><p>最后，我写了一个案例来查看透视相机和正交相机的显示区别：[点击这里案例 Demo](<a href="https://johnson2heng.github.io/GitChat-Three.js/07第七节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/07第七节</a> camera/index.html)。</p><p>左侧是透视相机显示的效果，这种更符合人眼看到的效果，场景更加的立体。而右侧则是正交相机实现的效果，渲染出来的数值更加准确，但是却不符合人眼查看的效果。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/07第七节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/07第七节</a> camera/index.html)。</p><h4 id="制作相机控制器"><a href="#制作相机控制器" class="headerlink" title="制作相机控制器"></a>制作相机控制器</h4><p>在实际生产当中，很多时候我们需要切换相机的位置，以达到项目需求。 Three.js 也有很多相机控制插件，这个我们会在后面的课程当中讲解。</p><p>下面是我书写的一个小案例，能够通过鼠标左键拖拽界面让相机围绕模型周围查看模型。</p><p>首先，先上案例地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/07第七节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/07第七节</a> camera/control.html)。</p><p>代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/07第七节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/07第七节</a> camera/control.html)。</p><p>其实和以前的代码相比，我们也只是多出来了一个 initControl 方法，在这个方法里面绑定鼠标事件。实现的思路也很简单：</p><ul><li>首先绑定鼠标按下事件，获取到按下时的相机位置和距离原点的距离，计算出来相对于 Z 轴正方向的偏移。绑定鼠标移动事件。</li><li>然后，在鼠标移动事件里面获取到距离鼠标按下的偏移，通过鼠标偏移数值计算出现在相机位置，并赋值。</li></ul><p>思路就这么简单，虽然实现起来会麻烦，我也尽量写的简单，大家尽量能够自己也写出来。</p><h2 id="基础功能之-Points-粒子"><a href="#基础功能之-Points-粒子" class="headerlink" title="基础功能之 Points 粒子"></a>基础功能之 Points 粒子</h2><p>我们将学习到 Sprite 精灵和 Points 粒子，这两种对象共同点就是我们通过相机查看它们时，始终看到的是它们的正面，它们总朝向相机。通过它们的这种特性，我们可以实现广告牌的效果，或实现更多的比如雨雪、烟雾等更加绚丽的特效。</p><h3 id="Sprite-精灵"><a href="#Sprite-精灵" class="headerlink" title="Sprite 精灵"></a>Sprite 精灵</h3><p>精灵由于一直正对着相机的特性，一般使用在模型的提示信息当中。通过 <code>THREE.Sprite</code> 创建生成，由于 <code>THREE.Sprite</code> 和 <code>THREE.Mesh</code> 都属于 <code>THREE.Object3D</code> 的子类，所以，我们操作模型网格的相关属性和方法大部分对于精灵都适用。和精灵一起使用的还有一个 <code>THREE.SpriteMaterial</code> 对象，它专门配合精灵的材质。注意，精灵没有阴影效果。</p><p>下面首先创建一个最简单的精灵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var spriteMaterial = new THREE.SpriteMaterial( &#123; color: 0xffffff &#125; );</span><br><span class="line">var sprite = new THREE.Sprite( spriteMaterial );</span><br><span class="line">scene.add( sprite );</span><br></pre></td></tr></table></figure><p>创建一个带有纹理图片的精灵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var spriteMap = new THREE.TextureLoader().load( &quot;sprite.png&quot; );</span><br><span class="line">var spriteMaterial = new THREE.SpriteMaterial( &#123; map: spriteMap, color: 0xffffff &#125; );</span><br><span class="line">var sprite = new THREE.Sprite( spriteMaterial );</span><br><span class="line">scene.add( sprite );</span><br></pre></td></tr></table></figure><p>直接使用 canvas 创建精灵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var spriteMap = new THREE.Texture(canvas);</span><br><span class="line">var spriteMaterial = new THREE.SpriteMaterial( &#123; map: spriteMap, color: 0xffffff &#125; );</span><br><span class="line">var sprite = new THREE.Sprite( spriteMaterial );</span><br><span class="line">scene.add( sprite );</span><br></pre></td></tr></table></figure><h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><p>精灵特有的属性就一个，即 center 属性，值是一个二维向量 <code>THREE.Vector2</code>，这个属性意义就是当前设置的精灵位置点的位置处于精灵图中的位置。如果 center 的值是 <code>0,0</code>旋转的位置就在左下角，如果值为 <code>1,1</code> 的话，那旋转的位置则在精灵图的右上角，默认值是 <code>0.5,0.5</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprite.center.set(0.5, 0); //设置位置点处于精灵的最下方中间位置</span><br></pre></td></tr></table></figure><p>接下来，我们查看一下精灵的案例：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/08第八节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/08第八节</a> points/sprite.html)。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/08第八节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/08第八节</a> points/sprite.html)。</p><p>案例效果从左到右依次是，普通的精灵，贴图纹理的精灵和 <code>canvas</code> 创建的精灵。</p><h3 id="points-粒子"><a href="#points-粒子" class="headerlink" title="points 粒子"></a>points 粒子</h3><p>粒子和精灵的效果是一样的，它们之间的区别是，如果当前场景内的精灵过多的话，就会出现性能问题。粒子的作用就是为解决很多精灵而出现的，我们可以使用粒子去模型数量很多的效果，比如下雨，下雪等，数量很多的时候就适合使用粒子来创建，相应的，提高性能的损失就是失去了对单个精灵的操作，所有的粒子的效果都是一样。总的来说，粒子就是提高性能减少的一些自由度，而精灵就是为了自由度而损失了一些性能。</p><h4 id="粒子的创建"><a href="#粒子的创建" class="headerlink" title="粒子的创建"></a>粒子的创建</h4><p>粒子 <code>THREE.Points</code> 和精灵 <code>THREE.Sprite</code> 还有网格 <code>THREE.Mesh</code> 都属于 <code>THREE.Object3D</code> 的一个扩展，但是粒子有一些特殊的情况就是 <code>THREE.Points</code> 是它们粒子个体的父元素，它的位置设置也是基于 <code>THREE.Points</code> 位置而定位，而修改 <code>THREE.Points</code> 的 scale 属性只会修改掉粒子个体的位置。下面我们看下一个粒子的创建方法。创建一个粒子，需要一个含有顶点的几何体，和粒子纹理 <code>THREE.PointsMaterial</code> 的创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//球体</span><br><span class="line">var sphereGeometry = new THREE.SphereGeometry(5, 24, 16);</span><br><span class="line">var sphereMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff&#125;);</span><br><span class="line">var sphere = new THREE.Points(sphereGeometry, sphereMaterial);</span><br><span class="line">scene.add(sphere);</span><br></pre></td></tr></table></figure><p>上面是通过球体几何体创建的一个最简单的粒子特效。</p><p>使用任何几何体都可以，甚至自己生成的几何体都可以，比如创建星空的案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var starsGeometry = new THREE.Geometry();</span><br><span class="line">//生成一万个点的位置</span><br><span class="line">for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    var star = new THREE.Vector3();</span><br><span class="line">    //THREE.Math.randFloatSpread 在区间内随机浮动* - 范围 / 2 *到* 范围 / 2 *内随机取值。</span><br><span class="line">    star.x = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    star.y = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    star.z = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    starsGeometry.vertices.push(star);</span><br><span class="line">&#125;</span><br><span class="line">var starsMaterial = new THREE.PointsMaterial(&#123;color: 0x888888&#125;);</span><br><span class="line">var starField = new THREE.Points(starsGeometry, starsMaterial);</span><br><span class="line">scene.add(starField);</span><br></pre></td></tr></table></figure><p>使用一个空的几何体，将自己创建的顶点坐标放入，也可以实现一组粒子的创建。如果我们需要单独设置每一个粒子的颜色，可以给 geometry 的 colors 数组添加相应数量的颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    var star = new THREE.Vector3();</span><br><span class="line">    //THREE.Math.randFloatSpread 在区间内随机浮动* - 范围 / 2 *到* 范围 / 2 *内随机取值。</span><br><span class="line">    star.x = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    star.y = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    star.z = THREE.Math.randFloatSpread(2000);</span><br><span class="line">    starsGeometry.vertices.push(star);</span><br><span class="line"></span><br><span class="line">    starsGeometry.colors.push(new THREE.Color(&quot;rgb(&quot;+Math.random()*255+&quot;, &quot;+Math.random()*255+&quot;, &quot;+Math.random()*255+&quot;)&quot;)); //添加一个随机颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="THREE-PointsMaterial-粒子的纹理"><a href="#THREE-PointsMaterial-粒子的纹理" class="headerlink" title="THREE.PointsMaterial 粒子的纹理"></a>THREE.PointsMaterial 粒子的纹理</h4><p>如果我们需要设置粒子的样式，还是需要通过设置 <code>THREE.PointsMaterial</code> 属性实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var pointsMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff&#125;); //设置了粒子纹理的颜色</span><br></pre></td></tr></table></figure><p>我们还可以通过 PointsMaterial 的 size 属性设置粒子的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pointsMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff, size:4&#125;); //粒子的尺寸改为原来的四倍</span><br><span class="line">//或者直接设置属性</span><br><span class="line">pointsMaterial.size = 4;</span><br></pre></td></tr></table></figure><p>我们也可以给粒子设置纹理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var pointsMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff, map:texture&#125;); //添加纹理</span><br></pre></td></tr></table></figure><p>默认粒子是不受光照影响的，我们可以设置 lights 属性为 true，让粒子受光照影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pointsMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff, lights:true&#125;); </span><br><span class="line">//或者</span><br><span class="line">pointsMaterial.lights = true; //开启受光照影响</span><br></pre></td></tr></table></figure><p>我们也可以设置粒子不受到距离的影响产生近大远小的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pointsMaterial = new THREE.PointsMaterial(&#123;color: 0xff00ff, sizeAttenuation: false&#125;); </span><br><span class="line">//或者</span><br><span class="line">pointsMaterial.sizeAttenuation = false; //关闭粒子的显示效果受距离影响</span><br></pre></td></tr></table></figure><p>粒子的效果就介绍到这里，希望大家熟练了以后能够做出来各种各样的花哨效果。</p><p>接下来展示下我给大家准备的粒子案例：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/08第八节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/08第八节</a> points/points.html)。</p><p>代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/08第八节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/08第八节</a> points/points.html)。</p><p>这个案例和精灵的案例区别就是，将球体改成了粒子，然后将立方体修改成了带有 canvas 纹理的粒子，并且在背景里面添加了一万个粒子</p><h2 id="进阶篇之-Controls-相机控制器"><a href="#进阶篇之-Controls-相机控制器" class="headerlink" title="进阶篇之 Controls 相机控制器"></a>进阶篇之 Controls 相机控制器</h2><p>我们讲解过相机的相关内容，也制作了一个简易的相机控制器。</p><p>正常的项目中，大家的需求都是不一样的，又通常会碰上需求中途改变的情况，我们之前做的简易版相机控制器很难满足此类项目对相机的操作需求。而且，造轮子的前提是当前的框架以及插件已经无法满足自身的需求时，才会考虑造轮子。要不然，项目的进度会被拖得很慢，甚至有可能因此而错过红利期。</p><p>好在 Three.js 官方和同道中的朋友们给我们提供了很多相关的插件，我们可以根据需求引入相关的插件来实现需求，本文我们就来看一下官方案例中提供的相机控制器。</p><p>从官网下载的代码包里可以发现有很多的相机控制器，文件夹地址为：<code>/examples/js/controls/</code>，里面的文件插件都是和控制相机和控制模型相关的插件，我们罗列一下相关插件：</p><ul><li>DeviceOrientationControls：陀螺仪相机控制器，实现移动端陀螺仪控制相机。</li><li>DragControls：控制鼠标拖拽移动物体的功能。</li><li>EditorControls：实现相机的旋转、缩放、平移功能，相对于 OrbitControls 的功能差不少，不建议使用。</li><li>FirstPersonControls：第一视角相机控制器。</li><li>FlyControls：飞行相机控制器。</li><li>OrbitControls：轨道控制器。</li><li>OrthographicTrackballControls：正交轨迹球控制器——正交相机使用的轨迹球控制器。</li><li>TrackballControls：轨迹球控制器——透视相机使用的轨迹球控制器。</li><li>PointerLockControls：鼠标锁定相机控制器。</li><li>TransformControls：控制模型位置、缩放、旋转的控制器。</li><li>VRControls：实现 VR 双屏相机控制器。</li></ul><p>由于篇幅有限，上面的控制器无法一一介绍，我们将重点介绍三种常用的相机控制器。</p><h3 id="OrbitControls"><a href="#OrbitControls" class="headerlink" title="OrbitControls"></a>OrbitControls</h3><p>OrbitControls 控制器是我们常用的相机控制器，它的功能丰富，使用简单，为大多数项目的使用插件。</p><h4 id="使用操作"><a href="#使用操作" class="headerlink" title="使用操作"></a>使用操作</h4><p>使用 OrbitControls 控制器我们可以实现旋转、缩放、平移等功能，下面简单列一下 OrbitControls 控制器的操作方法：</p><ul><li>围绕焦点旋转：使用鼠标左键拖拽；</li><li>放大和缩小：使用鼠标中键按住拖拽或者鼠标中键滑动滚轮；</li><li>平移相机：按住鼠标右键拖拽或者使用键盘的上下左右键。</li></ul><h4 id="控制器引入"><a href="#控制器引入" class="headerlink" title="控制器引入"></a>控制器引入</h4><p>在项目中使用 OrbitControls 控制器，可分为下面几步。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/OrbitControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机和渲染器的 Dom 对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.OrbitControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了一个最简单的 OrbitControls 控制器使用。</p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>OrbitControls 控制器最大的优势就是有丰富的配置项，供我们修改来实现项目中的需求，接下来我们看看有哪些属性配置。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">是否开启当前控制器，默认值是 True，如果设置为 False，将无法通过操作修改相机。</td></tr><tr><td align="left">target</td><td align="left">控制器的焦点位置，是一个 <code>THREE.Vector3</code> 对象，默认是 <code>(0, 0, 0)</code></td></tr><tr><td align="left">minDistance</td><td align="left">相机距离焦点的最近距离，默认值是0。 此属性适用于透视相机 PerspectiveCamera。</td></tr><tr><td align="left">maxDistance</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远）， 此属性适用于透视相机 PerspectiveCamera。</td></tr><tr><td align="left">minZoom</td><td align="left">相机距离焦点的最近距离，默认值是0，此属性适用于正交相机 OrthographicCamera。</td></tr><tr><td align="left">maxZoom</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远），此属性适用于正交相机 OrthographicCamera。</td></tr><tr><td align="left">minPolarAngle</td><td align="left">相机位置和焦点与焦点和最上方组成的最小夹角限制，默认值是0。</td></tr><tr><td align="left">maxPolarAngle</td><td align="left">相机位置和焦点与焦点和最上方组成的最大夹角限制，默认值是 Math.PI，也就是180度角。</td></tr><tr><td align="left">minAzimuthAngle</td><td align="left">当前相机沿水平方向顺时针旋转的弧度，默认值是 <code>- Infinity</code>。</td></tr><tr><td align="left">maxAzimuthAngle</td><td align="left">当前相机沿水平方向逆时针旋转的弧度，默认值是 <code>Infinity</code>。</td></tr><tr><td align="left">enableDamping</td><td align="left">是否开启拖拽惯性移动，即拖拽停止相机会有缓慢停止的距离移动，默认值是 False。</td></tr><tr><td align="left">dampingFactor</td><td align="left">拖拽惯性移动的阻力，默认值是 0.25。</td></tr><tr><td align="left">enableZoom</td><td align="left">是否开启缩放操作，默认值是 True。</td></tr><tr><td align="left">zoomSpeed</td><td align="left">缩放速度，默认值是 1.0。</td></tr><tr><td align="left">enableRotate</td><td align="left">是否开启相机绕焦点旋转操作，默认值是 True。</td></tr><tr><td align="left">rotateSpeed</td><td align="left">旋转速度，默认值是 1.0。</td></tr><tr><td align="left">enablePan</td><td align="left">是否开启相机平移操作，默认值是 True。</td></tr><tr><td align="left">panSpeed</td><td align="left">平移的速度，默认值是 1.0。</td></tr><tr><td align="left">screenSpacePanning</td><td align="left">修改相机平移的方向，默认值是 False，即沿 x 轴正负方向和 y 轴正负方向移动。可选值是 True，可以修改为沿 x 轴正负方向和 y 轴正负方向移动。</td></tr><tr><td align="left">keyPanSpeed</td><td align="left">键盘上下左右键移动相机的速度，默认值是 7.0。</td></tr><tr><td align="left">autoRotate</td><td align="left">当前相机是否自动旋转，默认值是 False，不自动旋转。</td></tr><tr><td align="left">autoRotateSpeed</td><td align="left">自动旋转的速度，默认值是 2.0，即渲染满60帧的情况下30秒旋转360度。</td></tr><tr><td align="left">enableKeys</td><td align="left">是否开启键盘控制先机平移，默认值是 True。</td></tr></tbody></table><p>OrbitControls 控制器的属性配置介绍完了，我们看看 OrbitControls 控制器还有那些方法。</p><h5 id="update"><a href="#update" class="headerlink" title="update()"></a><strong>update()</strong></h5><p>OrbitControls 控制器更新相机的方法，需要在每一帧里面调用。</p><h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a><strong>reset()</strong></h5><p>重置方法，相机回到初始位置。</p><h5 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a><strong>dispose()</strong></h5><p>销毁当前实例化的 OrbitControls 控制器。</p><h5 id="change-回调"><a href="#change-回调" class="headerlink" title="change 回调"></a><strong>change 回调</strong></h5><p>我们还可以监听相机改变回调，如果控制器修改了相机，将会产生一个回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    console.log(&quot;相机动了！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我附上 OrbitControls 控制器案例：</p><ul><li>[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/OrbitControls.html)</li></ul><p>也可以从这里获取案例源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/OrbitControls.html)</li></ul><h3 id="TrackballControls"><a href="#TrackballControls" class="headerlink" title="TrackballControls"></a>TrackballControls</h3><p>TrackballControls 控制器比 OrbitControls 控制器更自由，TrackballControls 控制器能够沿焦点进行球形旋转，没有死角，但比 OrbitControls 控制器少一些相关的功能配置。如何选择使用它们还是看项目需求，接下来还是先看如何操作。</p><p>注意，透视相机和正交相机使用的不是一个插件，此插件为透视相机使用，如果是正交相机请使用 OrthographicTrackballControls。</p><h4 id="使用操作-1"><a href="#使用操作-1" class="headerlink" title="使用操作"></a>使用操作</h4><p>使用 TrackballControls 控制器我们可以实现旋转、缩放、平移等功能，下面说一下如何使用 TrackballControls 控制器进行操作：</p><ul><li>围绕焦点旋转：使用鼠标左键拖拽；</li><li>放大和缩小：使用鼠标中键按住拖拽或者鼠标中键滑动滚轮；</li><li>平移相机：按住鼠标右键拖拽或者使用键盘的上下左右键。</li></ul><p>TrackballControls 控制器和 OrbitControls 控制器的操作相同，没什么可说的。</p><h4 id="控制器引入-1"><a href="#控制器引入-1" class="headerlink" title="控制器引入"></a>控制器引入</h4><p>在项目中使用 TrackballControls 控制器和 OrbitControls 控制器的方法雷同，分为下面几步。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/TrackballControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机和渲染器的 Dom 对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.TrackballControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h4><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">是否开启当前控制器，默认值是 True，如果设置为 False，将无法通过操作修改相机。</td></tr><tr><td align="left">rotateSpeed</td><td align="left">控制相机旋转速度，默认值是 3.0。</td></tr><tr><td align="left">zoomSpeed</td><td align="left">控制相机缩放速度，默认值是 1.2。</td></tr><tr><td align="left">panSpeed</td><td align="left">控制相机平移速度，默认值是 0.3。</td></tr><tr><td align="left">noRotate</td><td align="left">关闭相机旋转，默认 False，开启。</td></tr><tr><td align="left">noZoom</td><td align="left">关闭相机缩放，默认 False，开启。</td></tr><tr><td align="left">noPan</td><td align="left">关闭相机移动，默认 False 开启。</td></tr><tr><td align="left">staticMoving</td><td align="left">关闭拖拽惯性移动 默认值 False，开启。</td></tr><tr><td align="left">dynamicDampingFactor</td><td align="left">拖拽惯性移动阻力，默认值是 0.2。</td></tr><tr><td align="left">minDistance</td><td align="left">相机距离焦点的最近距离，默认值是 0。</td></tr><tr><td align="left">maxDistance</td><td align="left">相机距离焦点的最远距离，默认值是 Infinity（无限远）。</td></tr></tbody></table><p>相对于 OrbitControls 控制器，TrackballControls 控制器的属性少一些，但是相关的功能还是比较全面的。TrackballControls 控制器的方法也和 OrbitControls 控制器的方法雷同。</p><h5 id="update-1"><a href="#update-1" class="headerlink" title="update()"></a><strong>update()</strong></h5><p>TrackballControls 控制器更新相机的方法，需要在每一帧里面调用。</p><h5 id="reset-1"><a href="#reset-1" class="headerlink" title="reset()"></a><strong>reset()</strong></h5><p>重置方法，相机回到初始位置。</p><h5 id="dispose-1"><a href="#dispose-1" class="headerlink" title="dispose()"></a><strong>dispose()</strong></h5><p>销毁当前实例化的 TrackballControls 控制器。</p><h5 id="change-回调-1"><a href="#change-回调-1" class="headerlink" title="change 回调"></a>change 回调</h5><p>我们还可以监听相机改变回调，如果控制器修改了相机，将会产生一个回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    console.log(&quot;相机动了！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，附上 TrackballControls 控制器案例：</p><ul><li>[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/TrackballControls.html)</li></ul><p>也可以从这里获取案例源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/TrackballControls.html)</li></ul><h3 id="DeviceOrientationControls"><a href="#DeviceOrientationControls" class="headerlink" title="DeviceOrientationControls"></a>DeviceOrientationControls</h3><p>最后，我们介绍的这个控制器只兼容含有陀螺仪的移动端。DeviceOrientationControls 控制器可以通过获取设备的陀螺仪状态来控制相机的朝向。</p><p>如果你还对陀螺仪不了解，<a href="https://blog.csdn.net/qq_30100043/article/details/73323617" target="_blank" rel="noopener">请点击查看这里</a>，在这里不多说。</p><p>DeviceOrientationControls 的内容配置较少，我们先看一下案例。</p><p>使用手机打开网址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/09第九节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/09第九节</a> controls/DeviceOrientationControls.html) ，然后手机朝下然后移动，你会发现能够通过手机的转向来控制相机的朝向，是不是很神奇。接下来我们看看如何引入到项目中。</p><ul><li>首先，将插件文件引入到项目中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/DeviceOrientationControls.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后，通过相机对象实例化相机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control = new THREE.DeviceOrientationControls(camera);</span><br></pre></td></tr></table></figure><ul><li>最后，在每一帧渲染里面更新相机的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了对 DeviceOrientationControls 控制器的添加。</p><p>DeviceOrientationControls 控制器相关的配置也很少，只有一个 Enabled 属性，设置为 True，则控制器会更新相机的位置，反之，设置 False 将无法更新相机位置。</p><p>还有一个方法就是销毁当前控制器的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">controls.dispose(); //销毁当前控制器</span><br></pre></td></tr></table></figure><p>最后，附上源码：</p><ul><li>[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/09第九节</a> controls/DeviceOrientationControls.html)</li></ul><h2 id="使用-Loaders-加载模型"><a href="#使用-Loaders-加载模型" class="headerlink" title="使用 Loaders 加载模型"></a>使用 Loaders 加载模型</h2><p>现在市面上的 3D 模型有上百种，每一种格式都有不同的用途，不同的功能和复杂程度。尽管 Three.js 提供了很多的加载器，但选择正确的格式和工作流程将为以后的工作节省大量时间和成本。而且某些格式难以使用，效率低下，甚至有些目前还未完全被支持。</p><h3 id="推荐使用的模型格式"><a href="#推荐使用的模型格式" class="headerlink" title="推荐使用的模型格式"></a>推荐使用的模型格式</h3><p>官方推荐我们使用的 3D 模型的格式为 glTF，由于 glTF 专注于传输，因此它的传输和解析的速度都很快。glTF 模型的功能包括网格、材质、纹理、蒙皮、骨骼、变形动画、骨骼动画、灯光以及相机。</p><p>如果当前的首选不是 glTF 格式，那么推荐使用 Three.js 定期维护并且流行的格式 FBX、OBJ 或者 COLLADA 格式，Three.js 也有自己独有的 JSON 格式。我们接下来将介绍这五种格式。</p><h3 id="Three-js-的-JSON-格式"><a href="#Three-js-的-JSON-格式" class="headerlink" title="Three.js 的 JSON 格式"></a>Three.js 的 JSON 格式</h3><p>这里的 JSON 格式指的是 Three.js 可以将其转换为场景 3D 对象的 JSON 格式模型。这种格式内部一般必有的四项为：</p><ul><li>metadata：当前模型的相关信息以及生成的工具信息；</li><li>geometries：存储当前模型所使用的几何体的数组；</li><li>materials：存储当前模型所使用的材质的数组；</li><li>object：当前模型的结构以及标示所应用到的材质和几何体标示。</li></ul><p>所有的模型网格，几何体和材质都有一个固定的 UUID 标识符，在 JSON 格式中均通过 UUID 引用。</p><h4 id="3D-对象转成-JSON"><a href="#3D-对象转成-JSON" class="headerlink" title="3D 对象转成 JSON"></a>3D 对象转成 JSON</h4><p>所有的 <code>THREE.Object3D</code> 对象都可以转成 JSON 字符串保存成为文件，但我们不能直接将对象转成 JSON，因为 JSON 无法保存函数。Three.js 给我们提供了一个 toJSON() 的方法来让我们将其转换为可存储的 JSON 格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = scene.toJSON(); //将整个场景的内容转换成为 JSON 对象</span><br><span class="line">var obj = group.toJSON(); //将一个模型组转成 JSON 对象</span><br><span class="line">var obj = mesh.toJSON(); //将一个模型网格转成 JSON 对象</span><br><span class="line">var JSONStr = JSON.stringify(obj); //将 JSON 对象转换成 JSON 字符串</span><br></pre></td></tr></table></figure><p>按照这种方式，我们就可以将生成的场景模型保存为文件。</p><h4 id="使用-ObjectLoader-加载-JSON-模型"><a href="#使用-ObjectLoader-加载-JSON-模型" class="headerlink" title="使用 ObjectLoader 加载 JSON 模型"></a>使用 ObjectLoader 加载 JSON 模型</h4><p>这里我们将使用到 Three.js 内置的对象 <code>THREE.ObjectLoader</code> 加载模型。</p><p>直接加载 Three.js 生成的 JSON 对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = scene.toJSON(); //将整个场景的内容转换成为json对象</span><br><span class="line"></span><br><span class="line">let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象</span><br><span class="line">let scene = loader.parse(obj); //将json对象再转换成3D对象</span><br></pre></td></tr></table></figure><p>加载外部的 JSON 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象</span><br><span class="line"></span><br><span class="line">//加载模型，并在回调中将生成的模型对象添加到场景中</span><br><span class="line">loader.load(&quot;../js/models/json/file.json&quot;, function (group) &#123;</span><br><span class="line">    scene.add(group);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/ObjectLoader.html)。</p><p>案例的右上角有四个点击事件：</p><ul><li>添加模型：将在场景内随机生成一组立方体，每次都不相同。</li><li>导出模型：将场景内这一组立方体导出到本地 JSON 文件。</li><li>导入模型：可以选择将符合 JSON 文件作解析并导入到场景内。</li><li>加载模型：将加载服务器上面的一个 JSON 文件。</li></ul><p>案例代码地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/ObjectLoader.html)。</p><h3 id="glTF-格式文件导入"><a href="#glTF-格式文件导入" class="headerlink" title="glTF 格式文件导入"></a>glTF 格式文件导入</h3><p>glTF 格式的 3D 格式文件是官方推荐的使用格式，这种格式的文件我们可以在 Sketchfab 官网下载，这是一个国外比较知名的模型网站。</p><ul><li>下载地址：<a href="https://sketchfab.com/models?date=week&features=downloadable&sort_by=-likeCount&type=models" target="_blank" rel="noopener">点击这里</a>。</li></ul><p>我们可以在这里下载一些免费的 glTF 格式的模型。</p><p>我在官网上找了个不错的模型做了一个案例，[点击这里查看](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/GLTFLoader.html)。</p><p><img src="/posts/fdb123cb/c4b67350-8394-11e8-81ea-e357bbe10665" alt="gltf"></p><p>模型加载的速度会有些慢，大家可以等待下便能够看到这个小汽车。</p><p>接下来我们便讲解一下加载 glTF 模型的流程。</p><ul><li>首先，将 GLTFLoader 加载器插件引入到页面，插件在官方包的 <code>/examples/js/loaders/</code> 文件夹中，一些文件的导入插件都在这个文件夹内，大家有兴趣可以研究一下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/GLTFLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>然后创建一个加载器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.GLTFLoader();</span><br></pre></td></tr></table></figure><ul><li>使用加载器加载模型，并调节一下模型大小在场景内展示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/gltf/scene.gltf&apos;, function (gltf) &#123;</span><br><span class="line">    gltf.scene.scale.set(.1,.1,.1);</span><br><span class="line">    scene.add(gltf.scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有时候我们可能不明白，我加载了一个模型，哪一部分是需要导入场景的模型呢？</p><p>这里我们可以先将解析的出来的模型对象打印一下，然后通过查看对象属性来了解导入场景内的对象，就比如 glTF 模型转换出来的对象的 scene 属性就是需要导入场景的对象，而 JSON 格式的模型是直接可以导入的对象。</p><p>模型加载案例源码：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/GLTFLoader.html)。</p><h3 id="FBX-模型导入"><a href="#FBX-模型导入" class="headerlink" title="FBX 模型导入"></a>FBX 模型导入</h3><p>FBX 最大的用途是，在诸如 Max、Maya、Softimage 等软件间进行模型、材质、动作和摄影机信息的互导，这样就可以发挥 Max 和 Maya 等软件的优势。可以说，FBX 是最好的互导方案。</p><p><img src="/posts/fdb123cb/e7ead4e0-8396-11e8-a90b-215c3565b75a" alt="fbx"></p><p>接下来我们看一个 FBX 模型导入的案例，是我在网上下载的一个 FBX 格式的模型，导入到场景内的效果：[请点击这里查看](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/FBXLoader.html)。</p><p>接下来，我们看下它的实现过程。</p><p>首先我们需要导入 FBXLoader 插件，并且还需要额外增加一个解析二进制文件的插件 <code>inflate.min.js</code> ，不导入该文件的话，除了一些字符串存储的 FBX 格式，别的格式都会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/inflate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/loaders/FBXLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>创建 FBX 加载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FBXLoader();</span><br></pre></td></tr></table></figure><p>修改模型大小，并设置每个模型网格可以投射阴影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/fbx/file.fbx&apos;, function (fbx) &#123;</span><br><span class="line">    fbx.scale.set(.1,.1,.1);</span><br><span class="line">    fbx.traverse(function (item) &#123;</span><br><span class="line">       if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">           item.castShadow = true;</span><br><span class="line">           item.receiveShadow = true;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    scene.add(fbx);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就实现了 FBX 模型的导入。</p><p>案例源码地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/FBXLoader.html)。</p><h3 id="OBJ-格式模型导入"><a href="#OBJ-格式模型导入" class="headerlink" title="OBJ 格式模型导入"></a>OBJ 格式模型导入</h3><p>OBJ 文件是 3D 模型文件格式。由 Alias|Wavefront 公司为 3D 建模和动画软件 Advanced Visualizer 开发的一种标准，适合用于 3D 软件模型之间的互导，也可以通过 Maya 读写。</p><p>OBJ 文件是一种文本文件，可以直接用写字板打开进行查看和编辑修改，但不包含动画、材质特性、贴图路径、动力学、粒子等信息。</p><p>OBJ 文件的导出通常会和 MTL 格式一同导出，MTL 作为 OBJ 文件的附属文件，却有着 OBJ 文件需要的贴图材质，所以，我们通常使用时，将它们两个文件一同导入。</p><p><img src="/posts/fdb123cb/f0138980-8398-11e8-81ea-e357bbe10665" alt="obj"></p><p>这是我使用官网提供的一个模型制作的一个案例，查看地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/OBJLoader.html)。</p><p>我们看下实现导入的过程。</p><p>首先，我们需要将 OBJLoader 插件和 MTLLoader 插件引入页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/OBJLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/loaders/MTLLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>实例化 MTLLoader ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建MTL加载器</span><br><span class="line">var mtlLoader = new THREE.MTLLoader();</span><br><span class="line">//设置文件路径</span><br><span class="line">mtlLoader.setPath(&apos;../js/models/obj/&apos;);</span><br></pre></td></tr></table></figure><p>如果有需要，我们还可以设置纹理文件夹地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置纹理文件路径</span><br><span class="line">mtlLoader.setTexturePath(&apos;../js/models/obj/&apos;);</span><br></pre></td></tr></table></figure><p>加载 MTL 文件，并在文件加载成功后，创建 OBJLoader 并设置对象应用当前的材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//加载mtl文件</span><br><span class="line">mtlLoader.load(&apos;female02.mtl&apos;, function (material) &#123;</span><br><span class="line">    //创建OBJ加载器</span><br><span class="line">    var objLoader = new THREE.OBJLoader();</span><br><span class="line">    //设置当前加载的纹理</span><br><span class="line">    objLoader.setMaterials(material);</span><br><span class="line">    objLoader.setPath(&apos;../js/models/obj/&apos;);</span><br><span class="line">    objLoader.load(&apos;female02.obj&apos;, function (object) &#123;</span><br><span class="line">        //添加阴影</span><br><span class="line">        object.traverse(function (item) &#123;</span><br><span class="line">            if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">                item.castShadow = true;</span><br><span class="line">                item.receiveShadow = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //缩放</span><br><span class="line">        object.scale.set(.3,.3,.3);</span><br><span class="line">        scene.add(object);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们再去加载 OBJ 文件，加载成功的文件就是可以导入到场景内的 3D 对象。</p><p>案例源码查看地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/OBJLoader.html)。</p><h3 id="COLLADA-模型导入"><a href="#COLLADA-模型导入" class="headerlink" title="COLLADA 模型导入"></a>COLLADA 模型导入</h3><p>COLLADA 是一个开放的标准，最初用于 3D 软件数据交换，由 SCEA 发起，现在则被许多著名厂家（如 Autodesk、XSI 等）支持。COLLADA 不仅仅可以用于建模工具之间的数据交换，也可以作为场景描述语言用于小规模的实时渲染。</p><p>COLLADA DOM 拥有丰富的内容用于表现场景中的各种元素，从多边形几何体到摄像机无所不包。我们可以通过 COLLADA DOM 库来进行场景文件的读取与处理操作。</p><p><img src="/posts/fdb123cb/88b97d60-839a-11e8-884a-35c5e2ab8361" alt="collada"></p><p>上面是我写的一个模型导入案例，案例地址：[请点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/10第十节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/10第十节</a> loaders/ColladaLoader.html)。</p><p>我们看下实现步骤。</p><p>首先引入 ColladaLoader 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/loaders/ColladaLoader.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>接着实例化 ColladaLoader 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.ColladaLoader();</span><br></pre></td></tr></table></figure><p>最后加载文件并调整文件大小，添加到场景内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">loader.load(&apos;../js/models/collada/elf.dae&apos;, function (collada) &#123;</span><br><span class="line"></span><br><span class="line">    //添加阴影</span><br><span class="line">    collada.scene.traverse(function (item) &#123;</span><br><span class="line">        if(item instanceof THREE.Mesh)&#123;</span><br><span class="line">            item.castShadow = true;</span><br><span class="line">            item.receiveShadow = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //缩放</span><br><span class="line">    collada.scene.scale.set(5,5,5);</span><br><span class="line">    scene.add(collada.scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例源码查看：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/10第十节</a> loaders/ColladaLoader.html)。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1. 如何知道，加载完成的模型需要将哪部分导入到场景？</strong></p><p>一般情况下都是将自身导入，比如 FBX，OBJ，JSON 等，还有一种，会在里面生成一个可导入 scene 属性，如 glTF 和 COLLADA 文件。如果导入哪部分你无法确定，你可以把模型对象打印到控制台查看，然后尝试往场景内导入。</p><p><strong>2.导入到场景内的模型无法查看，而且也没有报错，为什么？</strong></p><p>这种情况可能由多种情况造成的，一般主要有下面两种情况：</p><ul><li>模型太小或者太大，这种情况可以尝试放大一千倍或者缩小一千倍来查看效果。</li><li>模型的位置太偏，根本不在相机照射范围内，这种问题我们可以将模型居中到相机照射的焦点位置查看，如何居中我们将在后面的课中讲解。</li></ul><h2 id="Three-js-动画"><a href="#Three-js-动画" class="headerlink" title="Three.js 动画"></a>Three.js 动画</h2><p>动画一般可以分为两种：一种是变形动画，另一种是骨骼动画。下面，我们先介绍一下变形动画。</p><h3 id="变形动画"><a href="#变形动画" class="headerlink" title="变形动画"></a>变形动画</h3><p>变形动画，通过修改当前模型的顶点位置来实现。比如，一个动画需要变动十次才可以实现，那么我们需要为当前模型的每一个顶点定义每一次所在的位置，Three.js 通过这一次次的修改实现了动画的整个流程。</p><p>为了帮助大家更好地理解变形动画的实现与使用，我创建了一个案例，查看地址为：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/morphTargets.html)。</p><p>在这个案例的右上角，我们能发现两个可切换的拖拽条。这两个拖拽条对应的是两个变形目标数组，拖拽范围是0-1，即当前的变形目标对本体的影响程度。拖拽它们，可发现界面中的立方体也会跟随之变动，从而影响当前的立方体。接下来我讲解一下，该案例的实现过程。</p><p>首先，创建模型的几何体，并为几何体 morphTargets 赋值两个变形目标。morphTargets 是一个数组，我们可以为其增加多个变形目标。在给 morphTargets 添加变形目标时，需要为其定义一个名称和相关的顶点，这个顶点数据必须和默认的模型的顶点数据保持一致，设置完后，我们需要调用 geometry 的 <code>computeMorphNormals()</code> 进行更新，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);</span><br><span class="line"></span><br><span class="line">// 创建两个影响立方体的变形目标</span><br><span class="line">var cubeTarget1 = new THREE.BoxGeometry(2, 10, 2);</span><br><span class="line">var cubeTarget2 = new THREE.BoxGeometry(8, 2, 8);</span><br><span class="line"></span><br><span class="line">// 将两个geometry的顶点放入到立方体的morphTargets里面</span><br><span class="line">cubeGeometry.morphTargets[0] = &#123;name: &apos;target1&apos;, vertices: cubeTarget1.vertices&#125;;</span><br><span class="line">cubeGeometry.morphTargets[1] = &#123;name: &apos;target2&apos;, vertices: cubeTarget2.vertices&#125;;</span><br><span class="line">cubeGeometry.computeMorphNormals();</span><br></pre></td></tr></table></figure><p>然后，为当前模型设置材质，变形目标作为参数之一，可以使其变形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cubeMaterial = new THREE.MeshLambertMaterial(&#123;morphTargets: true, color: 0x00ffff&#125;);</span><br></pre></td></tr></table></figure><p>接着，将创建好的网格模型添加到场景中。这时可以在 mesh 对象中找到 morphTargetInfluences 配置项，它也是一个数组，和 geometry 的 morphTargets 相对应，主要用来设置当前变形目标对本体的影响度，默认值为0-1，0为不影响本体，1为完全影响本体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gui = &#123;</span><br><span class="line">    influence1:0.01,</span><br><span class="line">    influence2:0.01,</span><br><span class="line">    update : function () &#123;</span><br><span class="line">        cube.morphTargetInfluences[0] = gui.influence1;</span><br><span class="line">        cube.morphTargetInfluences[1] = gui.influence2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们就手动实现了一个变形动画。在这个过程中，我们发现，变形动画是由于不断修改变形目标对本体的影响度而产生的。我们可以通过这个原理实现其他变形动画。</p><p>案例代码查看地址：[请点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节</a> animation/morphTargets.html)。</p><h3 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h3><p>实现骨骼动画，我们需要生成一个与模型相关的骨架。骨架中的骨骼与骨骼之间存在关联，模型的每一个要动的顶点需要设置影响它的骨骼以及骨骼对顶点的影响度。</p><p>和变形动画相比，骨骼动画更复杂一些，但又有更多的灵活性。使用变形动画，我们需要把所有的每一次的变动都存在一个顶点数组中，而骨骼动画，只需要设置骨骼的相关信息，就可以实现更多的动画。</p><p>下面我们看一个骨骼动画的简单案例：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/skeleton.html)</p><p><img src="https://images.gitbook.cn/5411e080-8da8-11e8-b093-3f5eaa2cb071" alt="skeleton"></p><p>这是官方提供的一个案例。我对其做了些简单修改，以显示出当前一个柱形图形的骨骼。实现起来比较复杂，我们需要先理解它是怎么实现的。</p><p>首先， 我们创建了一个圆柱几何体，通过圆柱的几何体每个顶点的 y 轴坐标位置来设置绑定的骨骼的下标和影响的程度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//遍历几何体所有的顶点</span><br><span class="line">for (var i = 0; i &lt; geometry.vertices.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    //根据顶点的位置计算出骨骼影响下标和权重</span><br><span class="line"></span><br><span class="line">    var vertex = geometry.vertices[i];</span><br><span class="line">    var y = (vertex.y + sizing.halfHeight);</span><br><span class="line"></span><br><span class="line">    var skinIndex = Math.floor(y / sizing.segmentHeight);</span><br><span class="line">    var skinWeight = (y % sizing.segmentHeight) / sizing.segmentHeight;</span><br><span class="line"></span><br><span class="line">    geometry.skinIndices.push(new THREE.Vector4(skinIndex, skinIndex + 1, 0, 0));</span><br><span class="line">    geometry.skinWeights.push(new THREE.Vector4(1 - skinWeight, skinWeight, 0, 0));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何体的 skinIndices 属性和 skinWeights 属性分别用来设置绑定的骨骼下标和权重（骨骼影响程度）。</p><p>相应的，我们需要一组相关联的骨骼。骨骼具有嵌套关系，才得以实现一个骨架。圆柱体比较简单，我们直接创建一条骨骼垂直嵌套的骨骼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bones = [];</span><br><span class="line"></span><br><span class="line">var prevBone = new THREE.Bone();</span><br><span class="line">bones.push(prevBone);</span><br><span class="line">prevBone.position.y = -sizing.halfHeight;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; sizing.segmentCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    var bone = new THREE.Bone();</span><br><span class="line">    bone.position.y = sizing.segmentHeight;</span><br><span class="line">    bones.push(bone); //添加到骨骼数组</span><br><span class="line">    prevBone.add(bone); //上一个骨骼定义为父级</span><br><span class="line">    prevBone = bone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建纹理时，我们还需要设置当前材质属性，并开启骨骼动画对其的修改权限，将材质的 skinning 属性设置为 true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lineMaterial = new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    skinning: true,</span><br><span class="line">    wireframe: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我们需要创建骨骼材质，并将模型绑定骨骼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mesh = new THREE.SkinnedMesh(geometry, [material, lineMaterial]);</span><br><span class="line">var skeleton = new THREE.Skeleton(bones); //创建骨架</span><br><span class="line">mesh.add(bones[0]); //将骨骼添加到模型里面</span><br><span class="line">mesh.bind(skeleton); //模型绑定骨架</span><br></pre></td></tr></table></figure><p>这样，我们就使用 Three.js 创建了一个简单的骨骼动画。使用 <code>dat.gui</code>，便于我们修改每一个骨骼的 poisition、rotation 和 scale 并查看对当前模型的影响。</p><p>案例的源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/11第十一节</a> animation/skeleton.html)。</p><h3 id="两种动画的区别"><a href="#两种动画的区别" class="headerlink" title="两种动画的区别"></a>两种动画的区别</h3><p>变形动画主要用于精度要求高的动画，比如人物的面部表情。其优点是动画的展现效果很到位，缺点就是扩展性不强，只能执行设置好的相关动画。</p><p>骨骼动画主要用于精度要求相对低一些，但需要丰富多样的动画的场合，就比如人物的走动，攻击防御等动画，我们可以通过一套骨骼，修改相应骨骼的位置信息直接实现相应的效果。它没有变形动画的精度高，但可以实现多种多样的效果。</p><blockquote><p><strong>总结：</strong> 我们可以根据项目的需求来设置不同的动画，就比如一个人物模型，说话我们使用变形动画去实现，而肢体动作使用骨骼动画去实现。</p></blockquote><h3 id="导入模型动画"><a href="#导入模型动画" class="headerlink" title="导入模型动画"></a>导入模型动画</h3><p>在 Three.js 动画系统中，你可以为模型的各种属性设置动画，如骨骼动画，变形动画，以及材质的相关属性（颜色，透明度， 是否可见）。动画属性可以设置淡入淡出效果以及各种扭曲特效，也可以单独改变一个或多个对象上的动画影响程度和动画时间。</p><p>为了实现这些，Three.js 动画系统在2015年修改为了类似于 Unity 和虚幻引擎4的架构。接下来我们了解下这套动画系统的主要组件以及它们是如何协同工作的。</p><h4 id="动画片段（Animation-Clips）"><a href="#动画片段（Animation-Clips）" class="headerlink" title="动画片段（Animation Clips）"></a>动画片段（Animation Clips）</h4><p>在我们成功导入模型以后，如果模型拥有相关的动画属性，会在返回的模型数据中产生一个名为 animations 的数组，数组的每一个子项都是一个 AnimationClips 对象。</p><p>每一个单独 AnimationClips 对象相应的保存着模型的一个动画的数据，假如，如果模型网格是一个人物角色，第一个 AnimationClips 对象有可能保存的是人物走动的动画，第二个 AnimationClips 对象用于跳跃，第三个用于攻击动画等等。</p><h4 id="关键帧轨迹（Keyframe-Tracks）"><a href="#关键帧轨迹（Keyframe-Tracks）" class="headerlink" title="关键帧轨迹（Keyframe Tracks）"></a>关键帧轨迹（Keyframe Tracks）</h4><p>在 AnimationClips 对象内部，一般有四个属性：</p><ul><li>name：当前动画的名称；</li><li>uuid：一个不会重复的 uuid；</li><li>duration：当前动画一个循环所需要的时间；</li><li>tracks：轨迹，即当前动画每一次切换动作所需要的数据。</li></ul><p>假设当前的动画是骨骼动画，在关键帧轨迹中存储的数据是每一帧骨骼随着时间变动的数据（位置，旋转和缩放等）。</p><p>如果当前动画是一个变形动画，在关键帧轨迹中将会把顶点数据的变动存储在其中（比如实现人脸的笑以及哭等动作）。</p><h4 id="动画混合器（Animation-Mixer）"><a href="#动画混合器（Animation-Mixer）" class="headerlink" title="动画混合器（Animation Mixer）"></a>动画混合器（Animation Mixer）</h4><p>在动画片段中存储的数据仅仅构成了动画实现的基础，实际的播放权力在动画混合器的手中。你可以想象动画混合器其实不仅仅只是作为动画的播放器，它还可以同时控制几个动画，混合它们或者合并它们。</p><h4 id="动画播放器（Animation-Actions）"><a href="#动画播放器（Animation-Actions）" class="headerlink" title="动画播放器（Animation Actions）"></a>动画播放器（Animation Actions）</h4><p>这个英文我更乐意将它翻译成动画播放器，因为我们最终需要将数据生成一个动画播放器来操作当前的动画执行，暂停或者停止，是否使用淡入淡出效果或者将动画加快或减慢。</p><h4 id="动画对象组（Animation-Object-Groups）"><a href="#动画对象组（Animation-Object-Groups）" class="headerlink" title="动画对象组（Animation Object Groups）"></a>动画对象组（Animation Object Groups）</h4><p>如果你希望一组模型对象共享当前的动画，我们可以使用动画对象组来实现。</p><h3 id="通过导入模型显示动画"><a href="#通过导入模型显示动画" class="headerlink" title="通过导入模型显示动画"></a>通过导入模型显示动画</h3><p><img src="/posts/fdb123cb/316ee240-8e92-11e8-bfb3-8b3f110a427d" alt="变形动画"></p><h4 id="变形动画-1"><a href="#变形动画-1" class="headerlink" title="变形动画"></a>变形动画</h4><p>我们首先查看一个官方的模型案例，这个案例是一匹马奔跑的动画，我们也可以通过下面地址查看：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/morphAnimation.html)。</p><p>接下来我们看一下这匹马是如何实现的。</p><ul><li>在模型加载成功以后，我们首先将模型创建出来，并将材质的 morphTargets 设置为 ture，使顶点数据信息可以受变形动画影响：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    vertexColors: THREE.FaceColors,</span><br><span class="line">    morphTargets: true</span><br><span class="line">&#125;));</span><br><span class="line">mesh.castShadow = true;</span><br><span class="line">mesh.scale.set(0.1, 0.1, 0.1);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><ul><li>然后我们创建了一个针对于该模型的混合器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixer = new THREE.AnimationMixer(mesh);</span><br></pre></td></tr></table></figure><ul><li>接着使用变形目标数据创建一个动画片段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clip = THREE.AnimationClip.CreateFromMorphTargetSequence(&apos;gallop&apos;, geometry.morphTargets, 30);</span><br></pre></td></tr></table></figure><ul><li>使用混合器和动画片段创建一个动画播放器来播放：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var action = mixer.clipAction(clip); //创建动画播放器</span><br><span class="line">action.setDuration(1); //设置当前动画一秒为一个周期</span><br><span class="line">action.play(); //设置当前动画播放</span><br></pre></td></tr></table></figure><ul><li>最后，我们还需要在重新绘制循环中更新混合器，进行动作更新：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line"></span><br><span class="line">    control.update();</span><br><span class="line"></span><br><span class="line">    var time = clock.getDelta();</span><br><span class="line">    //由于模型导入是异步的，所以我们再模型没有加载完之前是获取不到混合器的</span><br><span class="line">    if (mixer) &#123;</span><br><span class="line">        mixer.update(time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/fdb123cb/27172660-8e95-11e8-8ee0-a17ea463076e" alt="骨骼动画"></p><h4 id="骨骼动画-1"><a href="#骨骼动画-1" class="headerlink" title="骨骼动画"></a>骨骼动画</h4><p>骨骼动画模型，我们使用的是 gltf 格式，这个模型是在 Sketchfab 网站下载的，案例是一个小姐姐跳舞的片段，查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/11第十一节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/11第十一节</a> animation/skeletonAnimation.html)。</p><p>gltf 格式的模型导入进来后，我们可以直接通过 animations 数组创建播放器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixer = new THREE.AnimationMixer(obj); //通过当前模型创建混合器</span><br><span class="line">action = mixer.clipAction(gltf.animations[0]); //通过动画数据创建播放器</span><br></pre></td></tr></table></figure><p>直接调用播放器的播放事件让动画播放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.play();</span><br></pre></td></tr></table></figure><p>最后，我们还需要在循环渲染中更新混合器，并将每一帧渲染的间隔时间传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">    control.update();</span><br><span class="line">    var time = clock.getDelta();</span><br><span class="line">    if (mixer) &#123;</span><br><span class="line">        mixer.update(time);</span><br><span class="line">    &#125;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Tween-js-创建补间动画"><a href="#使用-Tween-js-创建补间动画" class="headerlink" title="使用 Tween.js 创建补间动画"></a>使用 Tween.js 创建补间动画</h2><h3 id="Tween-是什么"><a href="#Tween-是什么" class="headerlink" title="Tween 是什么"></a>Tween 是什么</h3><p>Tween.js 是 JavaScript 中一个简单的补间动画库，包含各种经典动画算法。Tween.js 支持数字对象的属性和 CSS 样式属性赋值，API 简单且强大，支持链式调用。</p><p>补间（动画）（来自 In-Between）是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这个过程需要多长时间，补间引擎将负责计算从起始点到结束点的值。</p><p>在 Three.js 中，我们有一些修改模型位置，旋转和缩放的需求，却无法直接在 WebGL 中使用 CSS3 动画来实现，而 Tween.js 恰好给我们提供了一个很好的解决方案。</p><p>比如我们要实现一个模型从 A 点到 B 点的位置移动，常规的实现方法，是使用 setInterval、requestAnimationFrame 手动计算出特定时间的位置点，很不易于管理与查看。而 Tween.js 可以自动根据起始点位置和动画时长计算出所有的位置点，可以很方便地对其进行获取和管理。</p><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>接下来，我们通过一个案例，带大家了解如何在 Three.js 应用中使用 Tween.js。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/simple.html)。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/simple.html)。</p></blockquote><p>本案例的开发思路是：首先获取目标模型的初始位置，然后实例化 Tween，接着设置目标位置，启动 Tween，在 TWEEN.onUpdate() 回调中改变目标模型的位置，从而实现目标模型从初始位置平滑移动到目标位置的动画。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//设置tween</span><br><span class="line">       var position = &#123;x:-40, y:0, z:-30&#125;;</span><br><span class="line">       tween = new TWEEN.Tween(position);</span><br><span class="line">       //设置移动的目标和移动时间</span><br><span class="line">       tween.to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br><span class="line">       //设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">       tween.onUpdate(function (pos) &#123;</span><br><span class="line">           cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>上面代码，首先创建一个 position 对象，存储了当前立方体的位置数据。然后，通过当前的对象创建了一个补间 tween。紧接着，设置每一个属性的目标位置，并告诉 Tween 在 2000 毫秒（动画时长）内移动到目标位置。最后，设置 Tween 对象每次更新的回调，即在每次数据更新以后，将立方体位置更新。</p><p>Tween 对象不会直接执行，需要我们调用 <code>start()</code> 方法激活，即 <code>tween.start()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个保存需求修改的数据对象。</span><br><span class="line">gui = &#123;</span><br><span class="line">    start:function () &#123;</span><br><span class="line">        tween.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>想要完成整个过程，我们还需要在每帧里面调用 <code>TWEEN.update</code>，来触发 Tween 对象更新位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line"></span><br><span class="line">    //更新Tween</span><br><span class="line">    TWEEN.update();</span><br><span class="line"></span><br><span class="line">    control.update();</span><br><span class="line"></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>链式调用可以简化大量代码，逻辑清晰集中，便于查看和修改。</p><p>Tween 插件也支持链式调用的方法，并且还会修改实例化时传入的对象，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//设置tween</span><br><span class="line">var position = &#123;x:-40, y:0, z:-30&#125;;</span><br><span class="line">tween = new TWEEN.Tween(position);</span><br><span class="line"></span><br><span class="line">//设置移动的目标和移动时间</span><br><span class="line">tween.to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br><span class="line"></span><br><span class="line">//设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">tween.onUpdate(function (pos) &#123;</span><br><span class="line">    cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以简化为链式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接链式实现tween</span><br><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000);</span><br></pre></td></tr></table></figure><h3 id="Tween-对象方法"><a href="#Tween-对象方法" class="headerlink" title="Tween 对象方法"></a>Tween 对象方法</h3><h4 id="控制动画方法"><a href="#控制动画方法" class="headerlink" title="控制动画方法"></a>控制动画方法</h4><p>Tween 对象控制动画的方法主要包括开始、取消、重复等方法。</p><ul><li><code>.start()</code></li></ul><p>如果你想激活一个补间，请使用这个方法，调用方式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween.start();</span><br></pre></td></tr></table></figure><p><code>start()</code> 方法还接受一个时间参数，添加该参数后，补间不会立即被激活，Tween 动画将在延时该时间数后才开始动画。否则它将立刻开始动画，且在第一次调用 <code>TWEEN.update</code> 时开始计时。如果设置的时间已经小于计时的总时间，那计算出来的位置数据将是参数设置时间开始后，运行到的所在位置。</p><ul><li><code>.stop()</code></li></ul><p>这个方法刚好和 <code>start()</code> 方法对应，如果你想取消一个补间，直接调用这个方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween.stop();</span><br></pre></td></tr></table></figure><ul><li><code>.update()</code></li></ul><p>其实每个补间都有一个更新方法，只不过我们多会使用 <code>TWEEN.update</code> ，而不会单独调用它（见下方全局函数）。</p><ul><li><code>.chain()</code></li></ul><p>当你按顺序排列不同的补间时，例如当上一个补间结束时立即启动另外一个补间，我们称它为链式补间。关于链式补间的案例请见下面两个链接。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/chain.html)</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/chain.html)</p></blockquote><p>调用方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB);</span><br></pre></td></tr></table></figure><p>或者，采用一个无限的链式，即 tweenA 与 tweenB 无限循环，便可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB);</span><br><span class="line">tweenB.chain(tweenA);</span><br></pre></td></tr></table></figure><p>在其他情况下，您可能需要将多个补间链接到另一个补间，以使它们（链接的补间）同时开始动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB,tweenC);</span><br></pre></td></tr></table></figure><blockquote><p>警告：调用 <code>tweenA.chain（tweenB）</code> 实际上修改的是 tweenA，tweenB 总在 tweenA 完成时启动。<code>chain()</code> 的返回值只是 tweenA，不是一个新的 Tween。</p><p>链接多个补间时，比如 <code>tweenA.chain(tweenB, tweenC)</code> 表示 tweenA 动画结束后，tweenB 和 tweenC 动画同时开始，如果因 tweenB 和 tweenC 修改的属性相同，而存在冲突时，经测试写在后面的属性将是最终动画位置。</p><p>注意，一般不要让两个同时开始的补间存在属性冲突。</p></blockquote><ul><li><code>.repeat()</code></li></ul><p>如果想让一个补间永远重复，可以无限链接自己，但更好的方法是使用 <code>repeat()</code> 方法。它接受一个参数，描述第一个补间完成后需要重复多少次，如下代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.repeat(10); // 循环10次</span><br><span class="line">tween.repeat(Infinity); // 无限循环</span><br></pre></td></tr></table></figure><p>我们可以将案例中 <code>simple.html</code> 文件里面的调用改成无限循环，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000).repeat(Infinity);</span><br></pre></td></tr></table></figure><ul><li><code>.yoyo()</code></li></ul><p>该方法只有在补间使用 <code>repeat()</code> 方法时才会被调用。我们调用 <code>yoyo()</code> 以后，位置的切换就变成了从头到尾，从尾到头这样的循环过程。</p><p>单个补间无限从头到尾的循环，可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween = new TWEEN.Tween(cube.position).to(&#123;x:40, y:30, z:30&#125;, 2000).repeat(Infinity).yoyo(true);</span><br></pre></td></tr></table></figure><p>进一步了解 <code>yoyo()</code>方法的使用，可查看下面案例。</p><blockquote><p>案例 Demo 查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/12第十二节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/12第十二节</a> tween/repeat.html)。</p><p>案例代码查看地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/12第十二节</a> tween/repeat.html)。</p></blockquote><ul><li><code>.delay()</code></li></ul><p>这个方法用于控制激活前的延时，即触发 <code>start()</code> 事件后，需要延时到设置的 delay 时间，才会真正激活，使用方法见下面代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.delay(1000);</span><br><span class="line">tween.start();</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>Tween 每次的位置更新后，都会触发 onUpdate 回调函数，我们可以在此回调中修改模型位置。</p><p>在之前案例的 <code>simple.html</code> 中，我们在每次更新回调中获取更新后的位置信息并修改模型几何体的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置每次更新的回调，然后修改几何体的位置</span><br><span class="line">tween.onUpdate(function (pos) &#123;</span><br><span class="line">    cube.position.set(pos.x, pos.y, pos.z);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>目前，补间支持的回调函数主要有以下几种。</p><ul><li>onStart</li></ul><p>在补间计算开始前的回调，每个补间只能触发一下，即使使用 <code>repeat()</code> 方法循环，这个回调也只被触发一次。</p><ul><li>onStop</li></ul><p>通过调用 <code>stop()</code> 方法停止的补间会触发当前回调，如果是正常完成的补间将不会触发此回调。</p><ul><li>onUpdate</li></ul><p>每次补间更新后，我们可以在此回调中获取更新后的值。</p><ul><li>onComplete</li></ul><p>当补间正常完成时，将会触发此回调。通过使用 <code>stop()</code> 停止的补间将不会触发此回调。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 Three.js 中使用 Tween.js，能够很方便地改变模型的位置，不需要手动计算，便能获取到具体的位置数据，以实现我们的需求。</p><h2 id="Three-js-场景交互"><a href="#Three-js-场景交互" class="headerlink" title="Three.js 场景交互"></a>Three.js 场景交互</h2><p>浏览器是一个 2D 视口，而 Three.js 展示的是 3D 场景。场景交互时，需要在二维平面中控制三维场景的模型，那如何将 2D 视口的 x 和 y 坐标转换成 Three.js 场景中的 3D 坐标呢？</p><p>好在 Three.js 已经有了解决相关问题的方案，那就是 <code>THREE.Raycaster</code> 射线，用于鼠标拾取（计算出鼠标移过的三维空间中的对象）等。我们看下面这张图片：</p><p><img src="/posts/fdb123cb/d5f05ad0-9a20-11e8-8334-9bfa28241acd" alt="raycaster"></p><p>我们一般都会设置三维场景的显示区域，如果指明当前显示的 2D 坐标给 <code>THREE.Raycaster</code>，它将生成一条从显示起点到终点的射线，也就是射线与近视面交点和射线与远视面交点连成的这一条直线。在相机视角下查看，只是一个点，射线会穿过整个显示场景，并按从近到远的顺序返回与模型相交的数据。</p><h3 id="THREE-Raycaster-构造函数和对象方法"><a href="#THREE-Raycaster-构造函数和对象方法" class="headerlink" title="THREE.Raycaster 构造函数和对象方法"></a>THREE.Raycaster 构造函数和对象方法</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.Raycaster( origin, direction, near, far );</span><br></pre></td></tr></table></figure><p>该实例化函数 Raycaster 包含了四个参数。</p><ul><li>origin：光线投射的原点矢量；</li><li>direction：光线投射的方向矢量，应该是被归一化的；</li><li>near：投射近点，用来限定返回比 near 要远的结果。near 不能为负数，缺省为 0；</li><li>far：投射远点，用来限定返回比 far 要近的结果。far 不能比 near 小，缺省为无穷大。</li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>THREE.Raycaster</code> 的属性可以在实例化对象后有修改需求时再修改。除了上面提到的 origin、direction、near、far 四个属性外，我们还有可能用到另一个属性：</p><ul><li>linePrecision：射线和线相交的精度，浮点数类型的值。</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>THREE.Raycaster</code> 给我们提供了一系列的方法，比如修改射线的位置，判断与某些模型是否相交等，接下来我们列举一些经常使用的方法。</p><ul><li><code>.set()</code>：此方法可以重新设置射线的原点和方向，从而更新射线位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.set（origin，direction）</span><br></pre></td></tr></table></figure><p>其中，参数 origin 用来设置射线新的原点矢量位置，direction 用来设置基于原点位置的射线的方向矢量。</p><ul><li><code>.setFromCamera()</code>：使用当前相机和界面的 2D 坐标设置射线的位置和方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setFromCamera ( coords, camera )</span><br></pre></td></tr></table></figure><p>参数 coords 表示鼠标的二维坐标，在归一化的设备坐标（NDC）中，也就是 X 和 Y 分量，应该介于 -1 和 1 之间。camera 表示射线起点处的相机，即把射线起点设置在该相机位置处。</p><p>点击事件大多通过鼠标触发，我们用鼠标点击显示区域的位置和当前场景使用的相机对象调用此对象，Three.js 会为我们计算出当前射线的位置。</p><ul><li><code>.intersectObject ()</code> 和 <code>.intersectObjects ()</code></li></ul><p>两个方法用来检查射线和物体之间的所有交叉点数据。</p><p>如果检测射线和一个对象是否相交，推荐使用 <code>intersectObject()</code>，如果判断的是这个对象的子对象，那推荐使用 <code>intersectObjects()</code>，将 3D 对象的 children 属性传入。</p><p>返回值是一个交叉点对象数组，且按距离排序，最接近的排在首位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.intersectObject ( object, recursive, optionalTarget)</span><br></pre></td></tr></table></figure><p>参数 object，用来检测和射线相交的物体。如果 recursive 设置为 true，还会向下继续检查所有后代，否则只检查该对象本身，缺省值为 false。optionalTarget 为可选参数，用于设置放置结果的数组，如果缺省，则将会实例化一个新数组，并将获取到的数据放入其中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.intersectObjects ( array, recursive, optionalTarget)</span><br></pre></td></tr></table></figure><p><code>intersectObject()</code> 和 <code>intersectObjects()</code> 的区别在于第一个参数。intersectObject 的第一个参数为 3D 对象，而 intersectObjects 需要传入一个由 3D 对象组成的数组。</p><p><strong>我们知道两个方法的返回值均为对象数组。接下来，我们再进一步了解下这个返回值。</strong></p><p>如果射线与场景内的模型没有相交，将返回一个空数组，否则，将返回一个按从近到远顺序排列的对象数组，数组中每个对象的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; distance, point, face, faceIndex, indices, object &#125;, ... ]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>distance：射线的起点到相交点的距离；</li><li>point：在世界坐标中的交叉点；</li><li>face：相交的面；</li><li>faceIndex：相交的面的索引；</li><li>indices：组成相交面的顶点索引；</li><li>object：相交的对象。</li></ul><p>当一个网孔（Mesh）对象和一个缓存几何模型（BufferGeometry）相交时，faceIndex 将是 undefined，并且 indices 将被设置；而当一个网孔（Mesh）对象和一个几何模型（Geometry）相交时，indices 将是 undefined。</p><p>当计算这个对象是否和射线相交时，Raycaster 把传递的对象委托给检测 3D 对象的 raycast 方法，该方法通过计算，检测出当前模型与射线是否相交。</p><p>这允许 Mesh 对光线投射的反应可以不同于 lines 和 pointclouds。Mesh、lines、pointclouds 是三种不同的计算相交的方法。Mesh 对射线与网格对象的每一个面进行相交判断。lines，则是判断两条线之间的距离，至于 pointclouds，则是通过 distanceSqToPoint 判断当前是否相交。</p><p><strong>注意</strong>，对于网格，面（faces）必须朝向射线原点，这样才能被检测到。背面射线的交叉点将无法被检测到。</p><p>为了使光线能投射到一个对象的正反两面，你需要设置 material 的 side 属性为 THREE.DoubleSide。</p><h3 id="模型点击事件的实现"><a href="#模型点击事件的实现" class="headerlink" title="模型点击事件的实现"></a>模型点击事件的实现</h3><p>上面讲解了射线的相关内容，接下来，我们来看一下，如何使用射线实现一个普通的点击事件。</p><p>首先，我们通过点击事件回调的 event 获取点击的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;</span><br><span class="line">mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;</span><br></pre></td></tr></table></figure><p>默认没有经过矩阵转换过的显示区域的宽和高分别是 2，即中心点也是 WebGL 场景的坐标原点，左上角的坐标是 <code>(-1.0, 1.0, 0.0)</code>，右下角的坐标是 <code>(1.0, -1.0, 0.0)</code>。我们通过单击点的位置计算出当前该点在场景中，没有被矩阵转换过的平面坐标。如果 WebGL 的渲染区域没有占满窗口，我们还需获取显示区域距离窗口左上角的偏移量，再计算位置，计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过 dom 的 getBoundingClientRect 方法获得当前显示区域距离左上角的偏移量</span><br><span class="line">var left = renderer.domElement.getBoundingClientRect().left;</span><br><span class="line">var top = renderer.domElement.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">//根据浏览器的设备类型来获取到当前点击的位置</span><br><span class="line">var clientX = dop.browserRedirect() === &quot;pc&quot; ? event.clientX - left : event.touches[0].clientX - left;</span><br><span class="line">var clientY = dop.browserRedirect() === &quot;pc&quot; ? event.clientY - top : event.touches[0].clientY - top;</span><br><span class="line"></span><br><span class="line">//计算出场景内的原始坐标</span><br><span class="line">mouse.x = (clientX / renderer.domElement.offsetWidth) * 2 - 1;</span><br><span class="line">mouse.y = -(clientY / renderer.domElement.offsetHeight) * 2 + 1;</span><br></pre></td></tr></table></figure><p>获取到坐标以后，我们需要使用射线的 <code>setFromCamera()</code> 方法配合场景坐标和相机更新射线的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raycaster.setFromCamera( mouse, camera );</span><br></pre></td></tr></table></figure><p>接着，使用 <code>intersectObjects()</code> 方法获取射线和所有模型相交的数组集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var intersects = raycaster.intersectObjects( scene.children );</span><br></pre></td></tr></table></figure><p>这里再提醒一句，很多读者可能发现，有时点击后射线并未获取到相交的物体。这是因为我们一般使用 <code>intersectObject()</code> 和 <code>intersectObjects()</code> 时，只会传入对象，而有的模型由多个模型组成，也就是它的子类，这时我们需要传入第二个值，设置为 true，来提示 Three.js 遍历它的子类。</p><p>最后，如果有与射线相交的模型，返回的 intersects 数组的长度将不为零：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(intersects.length &gt; 0)&#123;</span><br><span class="line">    alert(&quot;有相交的模型&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提供一个点击案例，点中物体后，模型颜色将会变色：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/13第十三节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/13第十三节</a> 场景交互/raycaster.html) 。</p><p>案例源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节</a> 场景交互/raycaster.html)。</p><h3 id="简单框选案例的实现"><a href="#简单框选案例的实现" class="headerlink" title="简单框选案例的实现"></a>简单框选案例的实现</h3><p>最近有些小伙伴想实现一个简单的框选案例，在这一篇中我来带大家完成。</p><p>本案例通过判断模型的位置实现框选，即框选前先获取所有模型在二维平面上的位置，然后再判断这些二维平面上的点是否处于框内。</p><p>相对于其它实现方式，这种实现节约性能，简单易懂，能够应付大部分场景。</p><p>接下来，我讲解一下这个框选的实现思路。</p><p>首先，编写以下代码，当鼠标按下时，记录鼠标按下时的场景坐标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取到显示区域距离窗口左上角的偏移量</span><br><span class="line">domClient.x = renderer.domElement.getBoundingClientRect().left;</span><br><span class="line">domClient.y = renderer.domElement.getBoundingClientRect().top;</span><br><span class="line">//计算出当前鼠标距离显示区域左上角的距离</span><br><span class="line">down.x = e.clientX - domClient.x;</span><br><span class="line">down.y = e.clientY - domClient.y;</span><br></pre></td></tr></table></figure><p>前两行代码求出了当前显示区域距离窗口左上角的偏移量，后两行则计算出来了当前鼠标点击位置距离显示区域左上角的偏移。</p><p>接着，使用 box 对象方法计算出模型的包围盒中心位置，适用于多个复杂模型场景。如果只是简单几何体，可以直接使用 Mesh 的位置来计算。通过相机将世界坐标的位置转换为平面坐标，并将模型放到一个数组内以便后期使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; group.children.length; i++) &#123;</span><br><span class="line">    let box = new THREE.Box3();</span><br><span class="line">    box.expandByObject(group.children[i]);</span><br><span class="line"></span><br><span class="line">    //获取到平面的坐标</span><br><span class="line">    let vec3 = new THREE.Vector3();</span><br><span class="line">    box.getCenter(vec3);</span><br><span class="line">    let vec = vec3.project(camera);</span><br><span class="line"></span><br><span class="line">    modelsList.push(</span><br><span class="line">        &#123;</span><br><span class="line">            component: group.children[i],</span><br><span class="line">            position: &#123;</span><br><span class="line">                x: vec.x * half.width + half.width,</span><br><span class="line">                y: -vec.y * half.height + half.height</span><br><span class="line">            &#125;,</span><br><span class="line">            normalMaterial: group.children[i].material</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先通过一个循环，计算出了每一模型在二维平面中的位置。</p><p>接下来，绑定 Document 的 mousemove 事件和 mouseup 事件。鼠标移动事件用来判断每个模型是否处于框内，鼠标抬起事件则将绑定的事件清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//绑定鼠标按下移动事件和抬起事件</span><br><span class="line">document.addEventListener(&quot;mousemove&quot;, movefun, false);</span><br><span class="line">document.addEventListener(&quot;mouseup&quot;, upfun, false);</span><br></pre></td></tr></table></figure><p>在鼠标移动事件中，我们计算出当前四个边的位置，并且循环判断哪些模型的位置处于框内，处于框内的模型的材质将被修改为框选材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; modelsList.length; i++) &#123;</span><br><span class="line">    let position = modelsList[i].position;</span><br><span class="line">    //判断当前位置是否处于框内</span><br><span class="line">    if (position.x &gt; min.x &amp;&amp; position.x &lt; max.x &amp;&amp; position.y &gt; min.y &amp;&amp; position.y &lt; max.y) &#123;</span><br><span class="line">        modelsList[i].component.material = material;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        modelsList[i].component.material = modelsList[i].normalMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后的鼠标抬起事件内，将框选框隐藏，并将所有材质修改为默认材质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function upfun(e) &#123;</span><br><span class="line"></span><br><span class="line">    //清除事件</span><br><span class="line">    document.body.removeChild(div);</span><br><span class="line">    document.removeEventListener(&quot;mousemove&quot;, movefun, false);</span><br><span class="line">    document.removeEventListener(&quot;mouseup&quot;, upfun, false);</span><br><span class="line"></span><br><span class="line">    //将所有的模型修改为当前默认的材质</span><br><span class="line">    for (let i = 0; i &lt; modelsList.length; i++) &#123;</span><br><span class="line">        modelsList[i].component.material = modelsList[i].normalMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，附上可以查看的案例地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/13第十三节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/13第十三节</a> 场景交互/boxselection.html)。</p><p>案例源码地址：[点击这里](<a href="https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节" target="_blank" rel="noopener">https://github.com/johnson2heng/GitChat-Three.js/blob/master/13第十三节</a> 场景交互/boxselection.html)</p><h2 id="Three-js-性能优化"><a href="#Three-js-性能优化" class="headerlink" title="Three.js 性能优化"></a>Three.js 性能优化</h2><p>在接触 Three.js 一段时间后，或多或少都会遇到性能问题。此类问题将直接导致页面帧率过低，严重时会导致页面崩溃。</p><p>导致性能问题的原因有很多，比如模型文件太大或顶点数太多导致加载时间过长，甚至失败，又或者代码书写逻辑有问题导致场景帧数太低。面对不同原因，我们需采取不同的应对方案，比如面对模型问题可对模型进行减面、减体积等处理；针对代码问题，则需尽量减少代码的运算。在平时的开发中，我们还要尽可能避免导致这些性能问题的根由。</p><p>下面，我将分享几种简单的有助于提升性能的方法。</p><h3 id="尽量共用几何体和材质"><a href="#尽量共用几何体和材质" class="headerlink" title="尽量共用几何体和材质"></a>尽量共用几何体和材质</h3><p>当大批量进行模型渲染时，不可避免地会有大量重复几何体的创建，这时共用相同的几何体和材质可以减少内存和 GPU 的数据传输。</p><p>我们具体来看一个实例，比如你需要创建三百个简单的相同颜色的立方体模型，普通的实现方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">    let geometry = new THREE.BoxGeometry(10, 10, 10);</span><br><span class="line">    let material = new THREE.MeshLambertMaterial(&#123;color: 0x00ffff&#125;);</span><br><span class="line">    let mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">    //随机位置</span><br><span class="line">    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));</span><br><span class="line">    group.add(mesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码创建了三百个相同的几何体和材质，该方法中有很多不必要的创建过程，增加运算的同时，还浪费了内存。</p><p>要解决这些性能问题，创建时我们可以共用相同的几何体和材质，改良后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let geometry = new THREE.BoxGeometry(10, 10, 10);</span><br><span class="line">let material = new THREE.MeshLambertMaterial(&#123;color: 0x00ffff&#125;);</span><br><span class="line">for (let i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">    let mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">    //随机位置</span><br><span class="line">    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));</span><br><span class="line">    group.add(mesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面代码，我们只需创建一套相同的几何体的顶点数据，不仅降低了内存消耗，还提高了添加运算效率。</p><h3 id="模型删除时，材质和几何体也需从内存中清除"><a href="#模型删除时，材质和几何体也需从内存中清除" class="headerlink" title="模型删除时，材质和几何体也需从内存中清除"></a>模型删除时，材质和几何体也需从内存中清除</h3><p>我们使用 <code>remove()</code> 将模型从场景内删除后，发现内存占用并没有太大变化。这是因为几何体和材质还保存在内存当中，这时需要手动调用 <code>dispose()</code> 方法将其从内存中删除。</p><p>下面为删除整个场景组的案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//删除group</span><br><span class="line">function deleteGroup(name) &#123;</span><br><span class="line">    let group = scene.getObjectByName(name);</span><br><span class="line">    if (!group) return;</span><br><span class="line">    //删除掉所有的模型组内的mesh</span><br><span class="line">    group.traverse(function (item) &#123;</span><br><span class="line">        if (item instanceof THREE.Mesh) &#123;</span><br><span class="line">            item.geometry.dispose(); //删除几何体</span><br><span class="line">            item.material.dispose(); //删除材质</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    scene.remove(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-merge-方法合并不需要单独操作的模型"><a href="#使用-merge-方法合并不需要单独操作的模型" class="headerlink" title="使用 merge 方法合并不需要单独操作的模型"></a>使用 merge 方法合并不需要单独操作的模型</h3><p>在 Three.js 新版本中，将 merge 方法整合在了几何体上，主要应用于拥有大量几何体且材质相同的模型上。我们可以将多个几何体拼接成单个整体的几何体，从而达到节约性能的目的，但该做法的缺点则是失去了对单个模型的控制。</p><p>通过下面代码，我们了解下 merge 的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//合并模型，则使用merge方法合并</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line">//merge方法将两个几何体对象或者Object3D里面的几何体对象合并，(使用对象的变换)将几何体的顶点、面、UV 分别合并。</span><br><span class="line">//THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead. 如果新版本用老版本的会报这个错</span><br><span class="line">for(var i=0; i&lt;20000; i++)&#123;</span><br><span class="line">    var cube = addCube(); //创建了一个随机位置的几何体模型</span><br><span class="line">    cube.updateMatrix(); //手动更新模型的矩阵</span><br><span class="line">    geometry.merge(cube.geometry, cube.matrix); //将几何体合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scene.add(new THREE.Mesh(geometry, cubeMaterial));</span><br></pre></td></tr></table></figure><p>我们再看一个案例：<a href="http://www.wjceo.com/blog/threejs/2018-03-14/123.html" target="_blank" rel="noopener">点击这里</a>。</p><p>在上面案例中，在不选中 combined 的前提下 ，选择 redraw 20000 个模型的话，一般只有十几帧的帧率。但如果选中了 combined，会发现渲染的帧率可达到满帧（60帧），性能得到了巨大提升。</p><h3 id="在循环渲染中避免使用更新"><a href="#在循环渲染中避免使用更新" class="headerlink" title="在循环渲染中避免使用更新"></a>在循环渲染中避免使用更新</h3><p>几何体、材质、纹理等相关数据的更新尽量不要放到循环渲染中进行。循环渲染时，每一帧都会对 GPU 数据进行更新，这将引发很多不必要的数据更新过程。</p><p>接下来，我们了解下几何体、材质、纹理数据更新的相关属性。</p><ul><li>几何体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geometry.verticesNeedUpdate = true; //顶点发生了修改</span><br><span class="line">geometry.elementsNeedUpdate = true; //面发生了修改</span><br><span class="line">geometry.morphTargetsNeedUpdate = true; //变形目标发生了修改</span><br><span class="line">geometry.uvsNeedUpdate = true; //uv映射发生了修改</span><br><span class="line">geometry.normalsNeedUpdate = true; //法向发生了修改</span><br><span class="line">geometry.colorsNeedUpdate = true; //顶点颜色发生的修改</span><br></pre></td></tr></table></figure><ul><li>材质</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">material.needsUpdate = true；</span><br></pre></td></tr></table></figure><ul><li>纹理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture.needsUpdate = true;</span><br></pre></td></tr></table></figure><p>如果它们发生更新，则将其设置为 true，Three.js 会通过判断，将数据重新传输到显存当中，并将配置项重新修改为 false。这是一个十分影响运行效率的过程，我们尽量只在需要的时候修改，且不要放到 <code>render()</code> 方法当中循环设置。</p><h3 id="只在需要的时候渲染"><a href="#只在需要的时候渲染" class="headerlink" title="只在需要的时候渲染"></a>只在需要的时候渲染</h3><p>在没有操作的时候，一直循环渲染属于浪费资源。接下来我带给大家一个只在需要时渲染的方法。</p><p>首先在循环渲染中加入一个判断，如果判断值为 true 时，才可以循环渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var renderEnabled;</span><br><span class="line">function animate() &#123;</span><br><span class="line"></span><br><span class="line">    if (renderEnabled) &#123;</span><br><span class="line">        renderer.render(scene, camera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animate();</span><br></pre></td></tr></table></figure><p>然后设置一个延迟器函数，每次调用后，可以将 renderEnabled 设置为 true，并延迟三秒将其设置为 false，这个延迟时间大家可以根据需求来修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//调用一次可以渲染三秒</span><br><span class="line">let timeOut = null;</span><br><span class="line">function timeRender() &#123;</span><br><span class="line">    //设置为可渲染状态</span><br><span class="line">    renderEnabled = true;</span><br><span class="line">    //清除上次的延迟器</span><br><span class="line">    if (timeOut) &#123;</span><br><span class="line">        clearTimeout(timeOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeOut = setTimeout(function () &#123;</span><br><span class="line">        renderEnabled = false;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在需要的时候调用这个 <code>timeRender()</code> 方法即可，比如在相机控制器更新后的回调中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controls.addEventListener(&apos;change&apos;, function()&#123;</span><br><span class="line">    timeRender();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果相机位置发生变化，就会触发回调，开启循环渲染，更新页面显示。</p><p>如果我们添加了一个模型到场景中，直接调用重新渲染即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh);</span><br><span class="line">timeRender();</span><br></pre></td></tr></table></figure><p>最后一个重点问题，就是材质的纹理为异步渲染，需要在图片添加完成后，触发回调。好在 Three.js 已经考虑到了这一点，Three.js 的静态对象 <code>THREE.DefaultLoadingManager</code> 的 onLoad 回调会在每一个纹理图片加载完成后触发回调。依靠它，我们可以在 Three.js 的每一个内容发生变更后触发重新渲染，且闲置状态下停止渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//每次材质和纹理更新，触发重新渲染</span><br><span class="line">THREE.DefaultLoadingManager.onLoad = function () &#123;</span><br><span class="line">    timeRender();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Three-js-核心对象"><a href="#Three-js-核心对象" class="headerlink" title="Three.js 核心对象"></a>Three.js 核心对象</h2><p>本文是介绍 Three.js 核心技术知识的最后一节，带大家了解经常接触到的对象。第16课，也是课程的最后一节，我们就开始实战演练。</p><h3 id="THREE-Clock"><a href="#THREE-Clock" class="headerlink" title="THREE.Clock"></a>THREE.Clock</h3><p>时间对象用于跟踪时间，用于计算每一帧的渲染时间或者从开始渲染到结束的时间。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数的使用，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clock = new THREE.Clock();</span><br></pre></td></tr></table></figure><p>实例化时间对象，还可以接收一个布尔类型的参数，用于设置实例化完成后，是否启动时间对象计时，默认为开启。</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>该类主要有以下几种方法。</p><ul><li><strong>.start()：</strong>此方法用于启动时间对象开始计时，将所有的信息重置；</li><li><strong>.stop()：</strong>停止时间对象的计时；</li><li><strong>.getElapsedTime()：</strong>此方法返回自时间对象开启以后到现在的时间；</li><li><strong>.getDelta()：</strong>此方法返回上次调用到这次调用此方法的间隔时间，用于计算渲染间隔。</li></ul><h3 id="THREE-Color"><a href="#THREE-Color" class="headerlink" title="THREE.Color"></a>THREE.Color</h3><p>THREE.Color 为颜色类，用到颜色的地方，都可以实例化此类，如设置材质颜色、场景背景颜色等。</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们可以通过 <code>new THREE.Color()</code> 传入一个值来初始化一个颜色对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//不传参数将默认渲染成白色</span><br><span class="line">var color = new THREE.Color();</span><br><span class="line"></span><br><span class="line">//十六进制颜色（推荐）</span><br><span class="line">var color = new THREE.Color( 0xff0000 );</span><br><span class="line"></span><br><span class="line">//RGB 字符串</span><br><span class="line">var color = new THREE.Color(&quot;rgb(255, 0, 0)&quot;);</span><br><span class="line">var color = new THREE.Color(&quot;rgb(100%, 0%, 0%)&quot;);</span><br><span class="line"></span><br><span class="line">//支持所有140个颜色名称</span><br><span class="line">var color = new THREE.Color( &apos;skyblue&apos; );</span><br><span class="line"></span><br><span class="line">//HSL 字符串</span><br><span class="line">var color = new THREE.Color(&quot;hsl(0, 100%, 50%)&quot;);</span><br><span class="line"></span><br><span class="line">//支持区间为从0到1的RGB数值</span><br><span class="line">var color = new THREE.Color( 1, 0, 0 );</span><br></pre></td></tr></table></figure><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>该类主要有以下几种方法。</p><ul><li><strong>.clone()：</strong>返回一个相同颜色的颜色对象；</li><li><strong>.add()：</strong>将一个颜色对象的颜色值和此颜色对象的颜色相加；</li><li><strong>.multiply()：</strong>将一个颜色对象的颜色值和此颜色对象的颜色相乘；</li><li><strong>.set()：</strong>重新设置颜色对象的颜色，支持实例化时的所有方式。</li></ul><h3 id="矢量对象"><a href="#矢量对象" class="headerlink" title="矢量对象"></a>矢量对象</h3><p>矢量是 GLSL ES 语言内的标准数据类型，也是 WebGL 原生着色器语言的数据类型。而 Three.js 为了方便和原生融合，内置了 <code>THREE.Vector2</code>、<code>THREE.Vector3</code> 和 <code>THREE.Vector4</code> 三种矢量，分别代表二维向量、三维向量和四维向量。</p><h4 id="二维矢量"><a href="#二维矢量" class="headerlink" title="二维矢量"></a>二维矢量</h4><p>二维矢量一般表示二维平面上点的位置和方向。</p><p>下面代码生成了一个普通的二维矢量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = new THREE.Vector2( 0, 1 );</span><br></pre></td></tr></table></figure><p>我们也可以通过 <code>set()</code> 方法，重新修改二维矢量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.set(2, 3);</span><br></pre></td></tr></table></figure><h4 id="三维矢量"><a href="#三维矢量" class="headerlink" title="三维矢量"></a>三维矢量</h4><p>在项目当中，我们经常会用到三维矢量，比如模型的位置属性、缩放属性，都是一个三维矢量。它由三个有序的数字组成的。</p><p>使用三维矢量，我们可以表示：</p><ol><li>三维空间中一个点的位置；</li><li>三维空间中两点连线的方向和长度；</li><li>任意有序的三个数字。</li></ol><p>我们看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建一个普通的三维矢量</span><br><span class="line">var a = new THREE.Vector3( 0, 1, 0 );</span><br><span class="line"></span><br><span class="line">//默认空值，将会重置为(0, 0, 0)</span><br><span class="line">var b = new THREE.Vector3( );</span><br><span class="line"></span><br><span class="line">//d矢量是从a点到b点的方向和长度</span><br><span class="line">var d = a.distanceTo( b );</span><br></pre></td></tr></table></figure><p>我们经常进行的模型位置改变以及缩放操作，其实都是通过修改三维矢量的值来实现的，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建一个三维矢量</span><br><span class="line">var vec = new THREE.Vector3(0, 1, 0);</span><br><span class="line"></span><br><span class="line">//修改模型的位置</span><br><span class="line">mesh.position = vec;</span><br><span class="line"></span><br><span class="line">//修改三维矢量的值</span><br><span class="line">vec.set(1, 2, 1);</span><br><span class="line"></span><br><span class="line">//修改模型的缩放值</span><br><span class="line">mesh.scale.set(2, 2, 2);</span><br></pre></td></tr></table></figure><p>我们还可以修改三维向量的单个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec.setComponent(0, 20); //将三维向量的第一值修改为20</span><br><span class="line"></span><br><span class="line">.setComponent(index, value); </span><br><span class="line">//index 修改的单个值的下标，可选值为 0 1 2 对应 vec.x vec.y vec.z</span><br><span class="line">//value 修改成的数字</span><br></pre></td></tr></table></figure><h4 id="四维矢量"><a href="#四维矢量" class="headerlink" title="四维矢量"></a>四维矢量</h4><p>四维矢量是由四个数字组成的数据类型，四个值分别代表 x、y、z、w。</p><p>四维矢量可以表示的内容有：</p><ol><li>思维空间内的一个点；</li><li>思维空间里的方向和长度；</li><li>任意有序的四个数字。</li></ol><p>我们再看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个普通的四维矢量</span><br><span class="line">var a = new THREE.Vector4( 0, 1, 0, 0 );</span><br><span class="line"></span><br><span class="line">//如果不设置参数，默认值为 (0, 0, 0, 1)</span><br><span class="line">var b = new THREE.Vector4( );</span><br></pre></td></tr></table></figure><h3 id="四维矩阵"><a href="#四维矩阵" class="headerlink" title="四维矩阵"></a>四维矩阵</h3><p>矩阵是高等代数中的常见工具，也常见于统计分析等应用数学学科中。Three.js 为我们封装了三维矩阵（3x3）四维矩阵（4x4）。</p><p>篇幅有限，这里就不介绍三维矩阵了，我们主要看下四维矩阵。</p><p>在 3D 计算机图形中，最常见的四维矩阵主要用于转换矩阵。这代表三维空间中的点 Vector3 通过乘以转换矩阵，可以实现如平移、旋转、剪切、缩放、发射、正交或透视投影等变化。</p><p>在每个 3D 对象中都有三个四维矩阵。</p><ul><li>Object3D.matrix：存储 3D 对象的局部变换，这是 3D 对象相对于父对象的转换；</li><li>Object3D.matrixWorld：3D 对象的全局或世界变换，如果 3D 对象没有父对象，则当前矩阵和其局部变换矩阵相同。</li><li>Object3D.modelViewMatrix：表示 3D 对象相对于摄像机的坐标转换，对象的 modelViewMatrix 是对象的 matrixWorld 再乘以相机的 matrixWorldInverse 获得的结果。</li></ul><p>相机对象不但含有 3D 对象的四维矩阵，还额外拥有以下两个四维矩阵。</p><ul><li>Camera.matrixWorldInverse：视图矩阵（相机的 matrixWorld 反转后的四维矩阵）；</li><li>Camera.projectionMatrix：表示场景内的模型如何转换到二维显示区域的变换矩阵。</li></ul><p>如果你对矩阵的实现原理感兴趣的话，可<a href="https://blog.csdn.net/qq_30100043/article/details/72783071" target="_blank" rel="noopener">点击这里</a>查看，这里不再过多解释原理。</p><p>接下来我们查看一下 Three.js 封装的四维变换矩阵为我们提供了哪些方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">//我们可以通过手动设置每一项的数值来生成变换矩阵</span><br><span class="line">m.set( 11, 12, 13, 14,</span><br><span class="line">       21, 22, 23, 24,</span><br><span class="line">       31, 32, 33, 34,</span><br><span class="line">       41, 42, 43, 44 );</span><br><span class="line"></span><br><span class="line">//创建一个矢量，并应用此变换矩阵</span><br><span class="line">var v = new THREE.Vector3();</span><br><span class="line"></span><br><span class="line">v.applyMatrix4(m); //应用变换矩阵</span><br></pre></td></tr></table></figure><p>上面代码创建了一个默认的四维矩阵，三维矢量乘以默认的四维矩阵将不会产生变化。</p><p>我们可以使用 <code>.identity()</code> 方法来重置变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">m.identity(); //重置矩阵恢复默认</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>.lookAt()</code> 传入一个三个矢量生成一个旋转矩阵。这三个矢量分别代表眼的位置、查看的物体位置和向上的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">m.lookAt(eye, center, up); //生成旋转变换矩阵</span><br></pre></td></tr></table></figure><p>我们也可以通过旋转弧度来生成旋转变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line">//通过绕x轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationX(Math.PI/2); //绕x轴旋转90度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2); //效果同上</span><br><span class="line"></span><br><span class="line">//通过绕y轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationY(Math.PI); //绕y轴旋转180度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI); //效果同上</span><br><span class="line"></span><br><span class="line">//通过绕z轴旋转生成变换矩阵</span><br><span class="line">m.makeRotationZ(Math.PI/4); //绕z轴旋转45度变换矩阵</span><br><span class="line">m.makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI/4); //效果同上</span><br></pre></td></tr></table></figure><p>通过设置缩放来生成缩放变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">m.makeScale(1, 2, 5); //生成沿x轴不变，y轴放大两倍，z轴放大五倍的缩放变换矩阵</span><br></pre></td></tr></table></figure><p>通过设置位置平移来生成变换矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">m.makeTranslation(10, -20, 100); //生成沿x正轴偏移10，y负轴偏移20，z正轴偏移100的平移变换矩阵</span><br></pre></td></tr></table></figure><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角通过在每个轴指定旋转的弧度和指定旋转轴的先后顺序来进行旋转变换。之前介绍场景时已做介绍，不再赘述。这里想说明的是，每个 3D 对象的 rotation 属性都是一个欧拉角对象。</p><p>创建欧拉角定义方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var e = new THREE.Euler( 0, 1, 1.57, &apos;XYZ&apos; );</span><br></pre></td></tr></table></figure><p>前三个值分别代表每个轴上旋转的弧度，第四个值是应用旋转的顺序。默认为“XYZ”，这意味着对象将首先围绕其 X 轴旋转，然后围绕其 Y 轴旋转，最后围绕其 Z 轴旋转。其他可能性有 YZX、ZXY、XZY、YXZ、ZYX，都必须大写。</p><p>修改欧拉角的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过set方法重新设置</span><br><span class="line">var e = new THREE.Euler();</span><br><span class="line">e.set(Math.PI, 0, - Math.PI / 2, &quot;YZX&quot;); //先沿y轴旋转180度，再沿z轴旋转0度，最后沿x轴逆时针旋转90度，第四个值可以不填，默认是&quot;XYZ&quot;</span><br></pre></td></tr></table></figure><p>我们也可以通过变换矩阵来修改当前的欧拉角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var e = new THREE.Euler( 0, 1, 1.57, &apos;XYZ&apos; );</span><br><span class="line">var m = new THREE.Matrix4();</span><br><span class="line"></span><br><span class="line">e.setFromRotationMatrix(m); //在当前的旋转角度，再进行矩阵变换</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Three.js 知识讲解部分，到这里基本就结束了。我第一次写正式的教程，难免有一些瑕疵，有不足的地方欢迎在读者圈给我留言。同时，希望该教程能带给大家一些感悟。</p><p>下一篇，也就是课程最后一篇，我将会编写一个简单的小案例。大家经常玩王者荣耀，那 Three.js 能否实现王者荣耀那种人物操作呢？答案是肯定的。我将通过实现逻辑分析加案例解析，带大家完成这个案例。</p><h2 id="人物操作案例"><a href="#人物操作案例" class="headerlink" title="人物操作案例"></a>人物操作案例</h2><p>下图是本文所分享实例最后的展示效果。本案例实现了人物跟随操作杆移动并跑步的动作，右边按钮可以实现攻击，短时间内连按可以实现不同的攻击动作。接下来我将带大家一步步实现这个案例。</p><p><img src="/posts/fdb123cb/be0cf2c0-a39e-11e8-8f3e-11f74a61cc3e" alt="案例图片"></p><h3 id="场景的搭建"><a href="#场景的搭建" class="headerlink" title="场景的搭建"></a>场景的搭建</h3><p>首先，我们需要把舞台搭建出来，先创建 Scene 场景。</p><h4 id="创建-Scene"><a href="#创建-Scene" class="headerlink" title="创建 Scene"></a>创建 Scene</h4><p>如下代码，我们创建了场景，并将背景设置为灰色。此外，还为场景设置了雾化效果，其中的三个参数分别表示雾的颜色、雾的开始距离、完全雾化距离相机的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene = new THREE.Scene();</span><br><span class="line">scene.background = new THREE.Color(0xa0a0a0);</span><br><span class="line">scene.fog = new THREE.Fog(0xa0a0a0, 1000, 11000);</span><br></pre></td></tr></table></figure><h4 id="创建-Camera"><a href="#创建-Camera" class="headerlink" title="创建 Camera"></a>创建 Camera</h4><p>我们创建了一个与地面呈 45 度角并朝向原点的相机，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);</span><br><span class="line">camera.position.set(0, 800, -800);</span><br><span class="line">camera.lookAt(new THREE.Vector3());</span><br></pre></td></tr></table></figure><h4 id="创建灯光"><a href="#创建灯光" class="headerlink" title="创建灯光"></a>创建灯光</h4><p>我们创建了两个灯光，分别为照射全局的环境光和可以产生阴影的平衡光。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scene.add(new THREE.AmbientLight(0x444444));</span><br><span class="line"></span><br><span class="line">light = new THREE.DirectionalLight(0xaaaaaa);</span><br><span class="line">light.position.set(0, 200, 100);</span><br><span class="line">light.lookAt(new THREE.Vector3());</span><br><span class="line"></span><br><span class="line">light.castShadow = true;</span><br><span class="line">light.shadow.camera.top = 180;</span><br><span class="line">light.shadow.camera.bottom = -180;</span><br><span class="line">light.shadow.camera.left = -180;</span><br><span class="line">light.shadow.camera.right = 180;</span><br><span class="line"></span><br><span class="line">//告诉平行光需要开启阴影投射</span><br><span class="line">light.castShadow = true;</span><br><span class="line"></span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><h4 id="创建草地"><a href="#创建草地" class="headerlink" title="创建草地"></a>创建草地</h4><p>我们使用平面几何体，创建一个草皮材质的模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var groundTexture = new THREE.TextureLoader().load(&apos;../images/grasslight-big.jpg&apos;);</span><br><span class="line">groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;</span><br><span class="line">groundTexture.repeat.set(25, 25);</span><br><span class="line">groundTexture.anisotropy = 16;</span><br><span class="line">var groundMaterial = new THREE.MeshLambertMaterial(&#123;map: groundTexture&#125;);</span><br><span class="line">var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);</span><br><span class="line">mesh.rotation.x = -Math.PI / 2;</span><br><span class="line">mesh.receiveShadow = true;</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><p>到这里，场景、灯光、相机、舞台都已经备齐。接下来我们将请出我们主角 naruto 登场。</p><h3 id="人物模型和动画"><a href="#人物模型和动画" class="headerlink" title="人物模型和动画"></a>人物模型和动画</h3><h4 id="添加人物模型"><a href="#添加人物模型" class="headerlink" title="添加人物模型"></a>添加人物模型</h4><p>接下来主人公登场，首先我们将模型导入到场景内，注意，案例中的模型比较大，加载和处理需要一定的时间，请小伙伴们耐心等待即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FBXLoader();</span><br><span class="line">        loader.load(&quot;../js/models/fbx/Naruto.fbx&quot;, function (mesh) &#123;</span><br><span class="line">            scene.add(mesh);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>我们不单单只是将模型添加到场景，还对模型的阴影和位置做了一下调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//设置模型的每个部位都可以投影</span><br><span class="line">mesh.traverse(function (child) &#123;</span><br><span class="line">    if (child.isMesh) &#123;</span><br><span class="line">        child.castShadow = true;</span><br><span class="line">        child.receiveShadow = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调整模型的位置，使其站立在草地上面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.y += 110;</span><br></pre></td></tr></table></figure><p>设置灯光一直照射模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置光线焦点模型</span><br><span class="line">light.target = mesh;</span><br></pre></td></tr></table></figure><h4 id="添加动画"><a href="#添加动画" class="headerlink" title="添加动画"></a>添加动画</h4><p>这个模型里含有 27 个骨骼动画，我们可以通过设置不同的动画，实现一整套动作来实现诸如攻击、移动等效果。接下来我们通过模型数据生成所需动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">actions = []; //所有的动画数组</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; mesh.animations.length; i++) &#123;</span><br><span class="line">    createAction(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createAction(i) &#123;</span><br><span class="line">    actions[i] = mixer.clipAction(mesh.animations[i]);</span><br><span class="line">    gui[&quot;action&quot; + i] = function () &#123;</span><br><span class="line">        for (var j = 0; j &lt; actions.length; j++) &#123;</span><br><span class="line">            if (j === i) &#123;</span><br><span class="line">                actions[j].play();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                actions[j].stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加暂停所有动画的按键</span><br><span class="line">gui.stop = function () &#123;</span><br><span class="line">    for (var i = 0; i &lt; actions.length; i++) &#123;</span><br><span class="line">        actions[i].stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模型加载成功后，我们需要让模型执行一个普通的站立效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第24个动作是鸣人站立的动作</span><br><span class="line">gui[&quot;action&quot; + 24]();</span><br></pre></td></tr></table></figure><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><p>在案例中，我们主要添加了两种操作，分别为模型位置移动操作和攻击操作。</p><p>为了方便，操作按钮直接使用 dom 标签来模拟。</p><p>模型位置移动操作中，我们需要模型位置的变动、模型的朝向以及修改站立动画和奔跑动画的切换。</p><p>攻击操作则是实现攻击，并根据点击速度，实现一整套攻击动作切换。</p><h4 id="实现位置移动效果"><a href="#实现位置移动效果" class="headerlink" title="实现位置移动效果"></a>实现位置移动效果</h4><p>为了实现位置移动，我们为按钮绑定了三个事件，分别为鼠标按下、鼠标移动、鼠标抬起。</p><p>在鼠标按下时，我们获取当前操作圆盘中心点的位置，让模型进入跑步动画，并绑定鼠标移动和抬起事件。重要的是更新模型的移动方向和移动速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dop.$(control).on(&quot;down&quot;, function (event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    //获取当前的按钮中心点</span><br><span class="line">    center.x = window.innerWidth - parseFloat(dop.getFinalStyle(control, &quot;right&quot;)) - parseFloat(dop.getFinalStyle(control, &quot;width&quot;)) / 2;</span><br><span class="line">    center.y = window.innerHeight - parseFloat(dop.getFinalStyle(control, &quot;bottom&quot;)) - parseFloat(dop.getFinalStyle(control, &quot;height&quot;)) / 2;</span><br><span class="line"></span><br><span class="line">    getRadian(event);</span><br><span class="line"></span><br><span class="line">    //鼠标按下切换跑步动作</span><br><span class="line">    state.skills === 0 &amp;&amp; gui[&quot;action&quot; + 3]();</span><br><span class="line"></span><br><span class="line">    //给document绑定拖拽和鼠标抬起事件</span><br><span class="line">    doc.on(&quot;move&quot;, move);</span><br><span class="line">    doc.on(&quot;up&quot;, up);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的 dop 类是我封装的一个兼容多端的事件库，具体详情可以<a href="https://github.com/johnson2heng/dop" target="_blank" rel="noopener">点击这里</a>查看。</p><p>在鼠标移动回调事件中，我们更新模型的移动方向和移动速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function move(event) &#123;</span><br><span class="line">    getRadian(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在鼠标抬起事件中，我们解绑事件，将按键复原，并停止模型的移动状态，将模型动画恢复到站立状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function up() &#123;</span><br><span class="line">    doc.remove(&quot;move&quot;, move);</span><br><span class="line">    doc.remove(&quot;up&quot;, up);</span><br><span class="line"></span><br><span class="line">    //按钮复原</span><br><span class="line">    bar.style.marginTop = 0;</span><br><span class="line">    barWrap.style.transform = `translate(-50%, -50%) rotate(0deg)`;</span><br><span class="line">    bar.style.transform = `translate(-50%, -50%) rotate(0deg)`;</span><br><span class="line"></span><br><span class="line">    //设置移动距离为零</span><br><span class="line">    characterMove(new THREE.Vector2(), 0);</span><br><span class="line"></span><br><span class="line">    //鼠标抬起切换站立状态</span><br><span class="line">    state.skills === 0 &amp;&amp; gui[&quot;action&quot; + 24]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个事件绑定完成后，我们需要利用回调中获得的值求出当前的偏转方向和移动速度。</p><p>首先我们获取当前鼠标的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (media === &quot;pc&quot;) &#123;</span><br><span class="line">    mouse.x = event.clientX;</span><br><span class="line">    mouse.y = event.clientY;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    mouse.x = event.touches[0].clientX;</span><br><span class="line">    mouse.y = event.touches[0].clientY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据位置求出距离操作圆盘中心的位置，并保证最大值不会超出圆盘的半径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let distance = center.distanceTo(mouse);</span><br><span class="line">distance &gt;= parseFloat(dop.getFinalStyle(control, &quot;width&quot;)) / 2 &amp;&amp; (distance = parseFloat(dop.getFinalStyle(control, &quot;width&quot;)) / 2);</span><br></pre></td></tr></table></figure><p>计算出当前位置和中心夹角，并修改 dom 的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//计算两点之间的夹角</span><br><span class="line">mouse.x = mouse.x - center.x;</span><br><span class="line">mouse.y = mouse.y - center.y;</span><br><span class="line"></span><br><span class="line">//修改操作杆的css样式</span><br><span class="line">bar.style.marginTop = `-$&#123;distance&#125;px`;</span><br><span class="line">bar.style.transform = `translate(-50%, -50%) rotate(-$&#123;(mouse.angle() / Math.PI * 180 + 90) % 360&#125;deg)`;</span><br><span class="line">barWrap.style.transform = `translate(-50%, -50%) rotate($&#123;(mouse.angle() / Math.PI * 180 + 90) % 360&#125;deg)`;</span><br></pre></td></tr></table></figure><p>函数的最后，则调用的 <code>characterMove()</code> 方法，将按钮数据转换成模型实际需要移动的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//修改当前的移动方向和移动速度</span><br><span class="line">characterMove(mouse.normalize(), distance / (parseFloat(dop.getFinalStyle(control, &quot;width&quot;)) / 2));</span><br></pre></td></tr></table></figure><p>接下来我们查看下 <code>characterMove()</code> 方法。在该方法中，我们计算出了模型每一帧需要移动的距离。这里有一个问题，我们所谓的操作杆向前让模型移动前方，其实是相机朝向的前方。所以我们需要先求出相机的前方矢量，再以相机的前方矢量为基础，计算出来模型实际方向。</p><p>我们首先声明了两个变量，一个是旋转矩阵，另一个是移动矢量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let direction = new THREE.Matrix4(); //当前移动的旋转矩阵</span><br><span class="line">let move = new THREE.Vector3(); //当前位置移动的距离</span><br></pre></td></tr></table></figure><p>在 <code>characterMove()</code> 函数内，我们根据相机的四元数获得了旋转矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//重置矩阵</span><br><span class="line">direction.identity();</span><br><span class="line"></span><br><span class="line">//通过相机的四元数获取到相机的旋转矩阵</span><br><span class="line">let quaternion = camera.quaternion;</span><br><span class="line">direction.makeRotationFromQuaternion(quaternion);</span><br></pre></td></tr></table></figure><p>然后通过旋转矩阵和当前操作杆的方向相乘计算出实际模型移动的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取到操作杆的移动方向</span><br><span class="line">move.x = vector.x;</span><br><span class="line">move.y = 0;</span><br><span class="line">move.z = vector.y;</span><br><span class="line"></span><br><span class="line">//通过相机方向和操作杆获得最终角色的移动方向</span><br><span class="line">move.applyMatrix4(direction);</span><br><span class="line">move.normalize();</span><br></pre></td></tr></table></figure><p>最后，通过比例和方向得出当前模型每一帧移动的距离。我们不需要修改模型 y 轴，只修改了 x、y 两个轴的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move.x = move.x * ratio * 10;</span><br><span class="line">move.z = move.z * ratio * 10;</span><br></pre></td></tr></table></figure><p>我们获取了模型每一帧移动的距离，还需要在帧循环中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//如果模型添加成功，则每帧都移动角色位置</span><br><span class="line">if (naruto) &#123;</span><br><span class="line">    //获取当前位置</span><br><span class="line">    position.x += move.x;</span><br><span class="line">    position.z += move.z;</span><br><span class="line"></span><br><span class="line">    //修改模型位置</span><br><span class="line">    naruto.position.x = position.x;</span><br><span class="line">    naruto.position.z = position.z;</span><br><span class="line"></span><br><span class="line">    //修改平衡光的位置</span><br><span class="line">    light.position.x = position.x;</span><br><span class="line">    light.position.z = position.z + 100;</span><br><span class="line"></span><br><span class="line">    //修改相机位置</span><br><span class="line">    camera.position.x = position.x;</span><br><span class="line">    camera.position.z = position.z - 800;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的模型、灯光和相机都会跟随移动，实现了我们上面动图中的模型移动效果。</p><h4 id="实现攻击效果"><a href="#实现攻击效果" class="headerlink" title="实现攻击效果"></a>实现攻击效果</h4><p>在实现攻击效果时，我并没有简单地实现一个普通的攻击，而是实现了一套连环招。</p><p>这套连环招由五个动作组成，在执行一个攻击动画时，如果再次点击攻击按钮，执行完该攻击动画后，不会切换到站立动画，而是直接切换到连环招的下一个攻击动画。</p><p>只要连续单击攻击按钮，模型将完成一整套的动作。实现这个效果，我们只需一个简单的定时器，接下来我们通过代码了解实现过程。</p><p>在实现动画前，先设置一个连环招的数组，将需要的动作添加到数组当中。我这里添加了五个手部攻击的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let attackList = [12, 13, 14, 15, 16]; //连招的循序</span><br><span class="line">let attackCombo = false; //是否连招，接下一个攻击</span><br></pre></td></tr></table></figure><p>我们还定义了 attackCombo 变量，用来设置是否使用连环招。变量 <code>state.skills</code> 值不为 0 时，它将变为 True。定时器每一次更新时，将判断 attackCombo 是否为 True，在 True 的状态下，将执行连环招的下一个动作。否则，将停止连环招。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//attackIndex 等于0，当前不处于攻击状态  不等于，当前处于攻击状态</span><br><span class="line">if(state.skills === 0)&#123;</span><br><span class="line">    state.skills++;</span><br><span class="line">    gui[&quot;action&quot; + attackList[state.skills-1]]();</span><br><span class="line">    attackInterval = setInterval(function () &#123;</span><br><span class="line">        if(attackCombo)&#123;</span><br><span class="line">            //如果设置了连招，上一个攻击动作完成后，进行下一个攻击动作</span><br><span class="line">            state.skills++;</span><br><span class="line">            //如果整套攻击动作已经执行完成，则清除定时器</span><br><span class="line">            if(state.skills-1 &gt;= attackList.length)&#123;</span><br><span class="line">                closeAttack();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //进行下一个动作</span><br><span class="line">            gui[&quot;action&quot; + attackList[state.skills-1]]();</span><br><span class="line"></span><br><span class="line">            attackCombo = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            closeAttack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, naruto.animations[attackList[state.skills-1]].duration*1000);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    attackCombo = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在关闭攻击动画的函数内，我们首先将 <code>state.skills</code> 设置为 0，然后恢复到移动或者站立动画，最后清除掉定时器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//关闭攻击状态</span><br><span class="line">function closeAttack() &#123;</span><br><span class="line">    state.skills = 0;</span><br><span class="line">    //根据状态设置是移动状态还是站立状态</span><br><span class="line">    state.move ? gui[&quot;action&quot; + 3]() :gui[&quot;action&quot; + 24](); //回到站立状态</span><br><span class="line">    clearInterval(attackInterval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过很简单的一些代码，我们就实现了一个复杂的连环招效果。</p><p>最后，奉上案例查看页面：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/16" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/16</a> 简单案例/demo.html)。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;基础功能之-Camera-相机&quot;&gt;&lt;a href=&quot;#基础功能之-Camera-相机&quot; class=&quot;headerlink&quot; title=&quot;基础功能之 Camera 相机&quot;&gt;&lt;/a&gt;基础功能之 Camera 相机&lt;/h2&gt;&lt;p&gt;相机是 Three.js 抽象出来的一个对象，使用此对象，我们可以定义显示的内容，并且可以通过移动相机位置来显示不同的内容。&lt;/p&gt;&lt;p&gt;下面讲解一下 Three.js 中相机的通用属性和常用的相机对象。&lt;/p&gt;&lt;h3 id=&quot;相机通用属性和方法&quot;&gt;&lt;a href=&quot;#相机通用属性和方法&quot; class=&quot;headerlink&quot; title=&quot;相机通用属性和方法&quot;&gt;&lt;/a&gt;相机通用属性和方法&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结5</title>
    <link href="https://blog.aigisss.com/posts/2bfe5b85.html"/>
    <id>https://blog.aigisss.com/posts/2bfe5b85.html</id>
    <published>2019-10-08T01:05:42.000Z</published>
    <updated>2019-10-08T14:59:12.743Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="Light-光照"><a href="#Light-光照" class="headerlink" title="Light 光照"></a>Light 光照</h2><p>在场景中添加光效和阴影效果。首先我们先介绍一下光照的创建。</p><p><img src="/posts/2bfe5b85/1570500658523.png" alt="1570500658523"></p><a id="more"></a><h3 id="创建光照"><a href="#创建光照" class="headerlink" title="创建光照"></a>创建光照</h3><p>所有的光照效果可以通过这种方式创建出来。</p><p>创建出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>); <span class="comment">//添加了一个白色的平行光</span></span><br></pre></td></tr></table></figure><p>并且还在场景中添加了一个全局光照：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.add(<span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x222222</span>));</span><br></pre></td></tr></table></figure><p>不同种类的光照，通过实例化，可以接受两个传值，分别是光照颜色和光照强度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">1.0</span>); <span class="comment">//添加了一个白色的平行光</span></span><br></pre></td></tr></table></figure><p>第二个值光照强度默认值是 1.0，我们可以根据项目需求调整光照强度。</p><p>我们也可以动态修改光的颜色和光照强度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>); <span class="comment">//添加了一个白色的平行光</span></span><br><span class="line"></span><br><span class="line">light.color.set(<span class="number">0x000000</span>); <span class="comment">//将光照的颜色修改为黑色</span></span><br><span class="line">light.intensity = <span class="number">2.0</span>; <span class="comment">// 光照的强度改为默认的两倍</span></span><br></pre></td></tr></table></figure><h3 id="光照种类"><a href="#光照种类" class="headerlink" title="光照种类"></a>光照种类</h3><p>实现了光照的创建，接下来，我们介绍一下 Three.js 内置的常用的几种光照的种类。</p><h4 id="AmbientLight-环境全局光"><a href="#AmbientLight-环境全局光" class="headerlink" title="AmbientLight 环境全局光"></a>AmbientLight 环境全局光</h4><p>环境光会照亮场景中所有的物体，在计算物体的颜色的时候，都会叠加上环境光的颜色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> THREE.AmbientLight( <span class="number">0x404040</span> ); <span class="comment">// 创建一个灰色的环境光</span></span><br><span class="line">scene.add( light );</span><br></pre></td></tr></table></figure><p>由于环境光作用于所有的物体，所有的材质，所以环境光是没有方向的，也无法产生阴影效果。</p><h4 id="DirectionalLight-平衡光"><a href="#DirectionalLight-平衡光" class="headerlink" title="DirectionalLight 平衡光"></a>DirectionalLight 平衡光</h4><p>平行光是以特定的方向发射的光。它产生的光都是平行的状态，主要用于模拟太阳光线。</p><p>创建平行光也接受两个值，颜色和光线强度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight( <span class="number">0xffffff</span>, <span class="number">0.5</span> ); <span class="comment">//创建一个颜色为纯白色并且强度为默认的一半的平行光</span></span><br><span class="line">scene.add( directionalLight );</span><br></pre></td></tr></table></figure><p>平行光除了可以动态修改光的颜色和强度外，还可以通过设置它的位置和目标位置来确定平行光的照射方向（两点确定一条直线的概念）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight( <span class="number">0xffffff</span>, <span class="number">0.5</span> ); </span><br><span class="line">directionalLight.color.set(<span class="number">0x000000</span>);  <span class="comment">//将光照颜色修改为黑色</span></span><br><span class="line">directionalLight.intensity = <span class="number">1.0</span>; <span class="comment">//将光照强度修改为默认</span></span><br><span class="line"></span><br><span class="line">directionalLight.position.set(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">//设置平行光的位置</span></span><br><span class="line">directionalLight.target.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//设置当前的平行光的朝向位置</span></span><br><span class="line">scene.add( directionalLight );</span><br></pre></td></tr></table></figure><h5 id="添加阴影效果"><a href="#添加阴影效果" class="headerlink" title="添加阴影效果"></a><strong>添加阴影效果</strong></h5><p>平行光是可以产生投影效果的，下面我们来看下平行光是如何产生阴影效果。</p><p>首先，需要设置渲染器可以渲染阴影效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.shadowMap.enabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>实例化灯光时，需要设置灯光渲染阴影：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="string">"#ffffff"</span>);</span><br><span class="line">directionalLight.castShadow = <span class="literal">true</span>; <span class="comment">// 设置平行光投射投影</span></span><br><span class="line"></span><br><span class="line">scene.add(directionalLight);</span><br></pre></td></tr></table></figure><p>最后，我们还需要设置哪些模型需要产生阴影和哪些模型可以接收阴影：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sphere.castShadow = <span class="literal">true</span>; <span class="comment">//开启阴影</span></span><br><span class="line">scene.add(sphere);</span><br><span class="line"></span><br><span class="line">cube.castShadow = <span class="literal">true</span>; <span class="comment">//开启阴影</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line">plane.receiveShadow = <span class="literal">true</span>; <span class="comment">//可以接收阴影</span></span><br><span class="line">scene.add(plane);</span><br></pre></td></tr></table></figure><p>上面我们设置了球体和立方体可以产生阴影，底部的平面可以接收球和立方体产生的阴影，便可以产生下面的图片效果：</p><p><img src="/posts/2bfe5b85/4a4dfa00-72ed-11e8-9e76-835574e7e257-1570499341261" alt="阴影效果"></p><p>由于设置阴影是一项十分耗性能的工作，所以我们需要尽量设置合适的阴影渲染范围和密度。平行光阴影的实现原理是通过正交相机 OrthographicCamera（将在下一篇讲解相机）检测当前模型，也就是 <code>directionalLight.shadow.camera</code>(它是一个正交相机），只要在这个正交相机可视范围内的可以投影的物体才可以被设置投影。并且我们可以通过设置一些相机的属性来实现产生阴影的范围：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">directionalLight.shadow.camera.near = <span class="number">20</span>; <span class="comment">//产生阴影的最近距离</span></span><br><span class="line">directionalLight.shadow.camera.far = <span class="number">100</span>; <span class="comment">//产生阴影的最远距离</span></span><br><span class="line">directionalLight.shadow.camera.left = <span class="number">-50</span>; <span class="comment">//产生阴影距离位置的最左边位置</span></span><br><span class="line">directionalLight.shadow.camera.right = <span class="number">50</span>; <span class="comment">//最右边</span></span><br><span class="line">directionalLight.shadow.camera.top = <span class="number">50</span>; <span class="comment">//最上边</span></span><br><span class="line">directionalLight.shadow.camera.bottom = <span class="number">-50</span>; <span class="comment">//最下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个值决定生成阴影密度 默认512</span></span><br><span class="line">directionalLight.shadow.mapSize.height = <span class="number">1024</span>;</span><br><span class="line">directionalLight.shadow.mapSize.width = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>具体效果请查看案例：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/06第六节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/06第六节</a> Light/directionalLight.html)。</p><h4 id="PointLight-点光源"><a href="#PointLight-点光源" class="headerlink" title="PointLight 点光源"></a>PointLight 点光源</h4><p>点光源就是从一个点的位置向四面八方发射出去的光，一个简单的例子就是一个裸露的灯泡。</p><p>实现一个最普通的点光源很简单，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xff0000</span>); <span class="comment">//创建一个白色的点光源</span></span><br><span class="line">pointLight.position.set( <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span> );</span><br><span class="line">scene.add( pointLight );</span><br></pre></td></tr></table></figure><p>点光源支持四个参数配置，除了前两个颜色和光的强度外，另外两个是照射范围和衰减度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xff0000</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>); <span class="comment">//创建一个白色的点光源</span></span><br><span class="line">pointLight.position.set( <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span> );</span><br><span class="line">scene.add( pointLight );</span><br></pre></td></tr></table></figure><p>第三个参数为照射范围，如果物体距离点光源超过这个距离，将不会受到点光源的影响，默认是所有的物体会受到点光源的影响。如果设置了参数，将按照第四个参数，即衰减度的值来慢慢减少影响，默认是1，如果需要模拟现实中的效果，这个参数可以设置为2。</p><p>这些属性也可以通过动态修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointLight.color.set(<span class="number">0x000000</span>); <span class="comment">//修改光照颜色</span></span><br><span class="line">pointLight.intensity = <span class="number">0.5</span>; <span class="comment">//修改光的强度</span></span><br><span class="line">pointLight.distance = <span class="number">50</span>; <span class="comment">//修改光的照射范围</span></span><br><span class="line">pointLight.decay = <span class="number">1.0</span>; <span class="comment">//修改衰减度</span></span><br></pre></td></tr></table></figure><h5 id="实现点光源的阴影效果"><a href="#实现点光源的阴影效果" class="headerlink" title="实现点光源的阴影效果"></a><strong>实现点光源的阴影效果</strong></h5><p>实现点光源阴影效果和实现平行光的阴影效果的设置基本一样，而且由于点光源是散射，阴影效果会终止在点光源的影响范围内。我们可以仿照平行光的阴影实现过程进行实现，只是将平行光修改成了点光源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="string">"#ffffff"</span>);</span><br><span class="line">pointLight.position.set(<span class="number">40</span>, <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//告诉平行光需要开启阴影投射</span></span><br><span class="line">pointLight.castShadow = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">scene.add(pointLight);</span><br></pre></td></tr></table></figure><p>查看点光源的效果：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/06第六节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/06第六节</a> Light/pointLight.html)。</p><h4 id="SpotLight-聚光灯光源"><a href="#SpotLight-聚光灯光源" class="headerlink" title="SpotLight 聚光灯光源"></a>SpotLight 聚光灯光源</h4><p>聚光灯光源的效果也是从一个点发出光线，然后沿着一个个圆锥体进行照射，可以模仿手电筒，带有灯罩的灯泡等效果。</p><p>实现聚光灯的案例最简单的做法是直接设置一个颜色即可，默认照射原点位置的光照：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight( <span class="number">0xffffff</span> ); <span class="comment">//创建一个白色光照</span></span><br><span class="line">spotLight.position.set( <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span> );</span><br><span class="line">scene.add( spotLight );</span><br></pre></td></tr></table></figure><p>聚光灯光源和点光源一样，也可以设置光的强度和照射范围：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight = <span class="keyword">new</span> THREE.SpotLight( <span class="number">0xffffff</span>, <span class="number">2.0</span>, <span class="number">100</span>); <span class="comment">//设置光照强度是默认的两倍,照射范围为100</span></span><br></pre></td></tr></table></figure><p>聚光灯由于是沿圆锥体照射，我们可以设置聚光灯的这个椎体的角度来影响光照范围：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight = <span class="keyword">new</span> THREE.SpotLight( <span class="number">0xffffff</span>, <span class="number">2.0</span>, <span class="number">100</span>, <span class="built_in">Math</span>.PI/<span class="number">4</span>); <span class="comment">//设置光的照射圆锥范围为90度</span></span><br></pre></td></tr></table></figure><p>因为聚光灯只能照射一定的区域的物体，所以会出现光亮和无法照射地方的交接，我们可以通过配置第五个值来设置交接渐变的过渡效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight = <span class="keyword">new</span> THREE.SpotLight( <span class="number">0xffffff</span>, <span class="number">2.0</span>, <span class="number">100</span>, <span class="built_in">Math</span>.PI/<span class="number">4</span>, <span class="number">0.5</span>); <span class="comment">//设置交界过渡幅度为0.5，默认是0，没有过渡，最大值为1</span></span><br></pre></td></tr></table></figure><p>我们也可以通过设置第六个值来设置聚光灯的衰减度，和点光源一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight = <span class="keyword">new</span> THREE.SpotLight( <span class="number">0xffffff</span>, <span class="number">2.0</span>, <span class="number">100</span>, <span class="built_in">Math</span>.PI/<span class="number">4</span>, <span class="number">0.5</span>, <span class="number">2.0</span>); <span class="comment">// 设置衰减度为物理效果的值2.0</span></span><br></pre></td></tr></table></figure><p>同样道理，我们也可以动态修改相关配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spotLight.color.set(<span class="number">0x000000</span>); <span class="comment">//修改光照颜色</span></span><br><span class="line">spotLight.intensity = <span class="number">0.5</span>; <span class="comment">//修改光的强度</span></span><br><span class="line">spotLight.distance = <span class="number">50</span>; <span class="comment">//修改光的照射范围</span></span><br><span class="line">spotLight.angle = <span class="built_in">Math</span>.PI/<span class="number">3</span>; <span class="comment">//修改光的照射弧度</span></span><br><span class="line">spotLight.penumbra = <span class="number">1.0</span>; <span class="comment">//修改交界过渡</span></span><br><span class="line">spotLight.decay = <span class="number">1.0</span>; <span class="comment">//修改衰减度</span></span><br></pre></td></tr></table></figure><p>我们也可以修改聚光灯的 target 来修改光的照射方向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotLight.target.set(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//修改照射方向</span></span><br></pre></td></tr></table></figure><h5 id="实现聚光灯阴影"><a href="#实现聚光灯阴影" class="headerlink" title="实现聚光灯阴影"></a><strong>实现聚光灯阴影</strong></h5><p>实现聚光灯阴影与实现平行光和点光源的设置一样，聚光灯的设置也是将可以生成阴影设置打开，并将聚光灯添加到场景中即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spotLight= <span class="keyword">new</span> THREE.SpotLight(<span class="string">"#ffffff"</span>);</span><br><span class="line">spotLight.position.set(<span class="number">40</span>, <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//告诉平行光需要开启阴影投射</span></span><br><span class="line">spotLight.castShadow = <span class="literal">true</span>;</span><br><span class="line">scene.add(spotLight);</span><br></pre></td></tr></table></figure><p><img src="/posts/2bfe5b85/8191e1a0-731c-11e8-9e76-835574e7e257-1570499335071" alt="聚光灯"></p><p>案例查看地址：[点击这里](<a href="https://johnson2heng.github.io/GitChat-Three.js/06第六节" target="_blank" rel="noopener">https://johnson2heng.github.io/GitChat-Three.js/06第六节</a> Light/spotLight.html)。</p><h4 id="HemisphereLight-室外光源"><a href="#HemisphereLight-室外光源" class="headerlink" title="HemisphereLight 室外光源"></a>HemisphereLight 室外光源</h4><p>最后我们说一下室外光源，这个光源主要是为了模拟在户外的环境光效果，比如在蓝天绿地的户外，模型下面会显示出来绿色的环境光，而上方则会受到蓝天的影响而颜色偏蓝。</p><p>实例化室外光源支持三个参数：天空的颜色，地面的颜色，和光的强度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加户外光源</span></span><br><span class="line"><span class="keyword">var</span> hemisphereLight = <span class="keyword">new</span> THREE.HemisphereLight(<span class="number">0xffffbb</span>, <span class="number">0x080820</span>, <span class="number">1</span>);</span><br><span class="line">scene.add(hemisphereLight);</span><br></pre></td></tr></table></figure><p>同样的道理，我们也可以通过配置属性实时修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hemisphereLight.color.set(<span class="number">0xffffff</span>); <span class="comment">//将天空颜色修改为白色</span></span><br><span class="line">hemisphereLight.groundColor.set(<span class="number">0x000000</span>); <span class="comment">//将地面颜色修改为黑色</span></span><br></pre></td></tr></table></figure><p>我们也可以修改 position 配置项来修改渲染的方向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hemisphereLight.position.set(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//默认从上往下渲染，也就是天空在上方，当前修改为了，天空颜色从下往上渲染</span></span><br></pre></td></tr></table></figure><p>案例查看地址：</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Light-光照&quot;&gt;&lt;a href=&quot;#Light-光照&quot; class=&quot;headerlink&quot; title=&quot;Light 光照&quot;&gt;&lt;/a&gt;Light 光照&lt;/h2&gt;&lt;p&gt;在场景中添加光效和阴影效果。首先我们先介绍一下光照的创建。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/2bfe5b85/1570500658523.png&quot; alt=&quot;1570500658523&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结4</title>
    <link href="https://blog.aigisss.com/posts/5cf96b13.html"/>
    <id>https://blog.aigisss.com/posts/5cf96b13.html</id>
    <published>2019-10-07T13:54:08.000Z</published>
    <updated>2019-10-07T14:52:27.044Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="基础功能之-Material-材质"><a href="#基础功能之-Material-材质" class="headerlink" title="基础功能之 Material 材质"></a>基础功能之 Material 材质</h2><p>模型的表现，也就是我们看到的的模型外观——材质。</p><p><img src="/posts/5cf96b13/materials.png" alt></p><a id="more"></a><p>简单的说，就是物体看起来是什么质地。材质可以看成是材料和质感的结合。在渲染程序中，它是表面各种可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。Three.js 给我们封装好了大部分的材质效果，避免我们使用复杂的 Shader 语言自己去实现。接下来我们先介绍下 Material 常用的一些属性和方法。</p><h3 id="基本属性和方法"><a href="#基本属性和方法" class="headerlink" title="基本属性和方法"></a>基本属性和方法</h3><h4 id="needsUpdate"><a href="#needsUpdate" class="headerlink" title="needsUpdate"></a>needsUpdate</h4><p>如果修改了 Material 内的内容，需要将 needsUpdate 属性设置为 true，Three.js 会在下一帧里将修改内容同步到 WebGL 的显存内。切记不要在 requestAnimationFrame 方法内更新，会浪费性能，只需要在更新 Material 属性后设置一次即可。</p><h4 id="side"><a href="#side" class="headerlink" title="side"></a>side</h4><p>此属性可以定义当前面的哪个方向会被渲染，默认值是 <code>THREE.FrontSide</code>（只渲染正面），可选值有：<code>THREE.BackSide</code>（只渲染背面）和 <code>THREE.DoubleSide</code>（正面和背面都会渲染）。</p><h4 id="transparent"><a href="#transparent" class="headerlink" title="transparent"></a>transparent</h4><p>此属性定义了材质是否可以透明，因为对于透明需要材质进行特殊处理，并在不透明的物体渲染完成后再渲染透明物体。当设置此属性为<code>true</code>后，可以通过设置<code>opacity</code>来调整透明度，默认为<code>false</code>。</p><h4 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h4><p>此属性可以定义材质的透明度，必须将材质的 transparent 设置为 true 才可使透明度管用。取值范围为 0.0 到 1.0。默认值是1.0，也就是不透明。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>此属性可以配置当前材质的纹理贴图，是一个 <code>THREE.Texture</code> 对象，下面我们将会讲解如何给材质贴图。这是大部分材质都会有的属性，只有极其个别的材质如 <code>LineBasicMaterial</code>（线材质）等没有这个属性。</p><h4 id="wireframe"><a href="#wireframe" class="headerlink" title="wireframe"></a>wireframe</h4><p>是否将模型渲染成线框，默认为 false。个别材质也没有这个属性。</p><h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h4><p>此方法用于将材质从内存中删除，在不需要使用当前材质时使用，但不会将材质的纹理贴图删除，如果需要将纹理贴图也删除，需要调用 <code>material.map.dispose()</code>。</p><h3 id="配置纹理贴图"><a href="#配置纹理贴图" class="headerlink" title="配置纹理贴图"></a>配置纹理贴图</h3><p>由于经常使用纹理贴图，所以在这里单独讲解一下如何实现一个纹理贴图。 实现纹理贴图有以下两种方式。</p><p>第一种，使用 <code>THREE.TextureLoader</code> 进行生成纹理对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load( <span class="string">"textures/water.jpg"</span> ); </span><br><span class="line">material.map = texture; <span class="comment">//将纹理赋值给材质</span></span><br></pre></td></tr></table></figure><p>或者直接实例化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.Texture(canvas); <span class="comment">//实例化的第一个对象可以是`img`、`canvas`和`video`。</span></span><br><span class="line">material.map = texture; <span class="comment">//将纹理赋值给材质</span></span><br></pre></td></tr></table></figure><h4 id="纹理重复问题"><a href="#纹理重复问题" class="headerlink" title="纹理重复问题"></a>纹理重复问题</h4><p>如果图片不是标准的2的幂数（2、4、8、16、32、64、128、256、512、1024、2048……），在控制台会给我们提示：“THREE.WebGLRenderer: image is not power of two”，意思就是说图片不是标准格式高宽不是2的幂数。我们需要的水平方向和垂直方向上设置的图片重复显示。需要配置的两个属性是：<code>texture.wrapS</code>（水平方向重复）和 <code>texture.wrapT</code>（垂直方向重复），默认值是：<code>THREE.ClampToEdgeWrapping</code>，即纹理的最后一个像素延伸到网格的边缘。可选项有：<code>THREE.RepeatWrapping</code>，表示纹理将重复无穷大；<code>MirroredRepeatWrapping</code>，表示镜像重复，可以理解为重复时，反着绘制一个然后正着绘制一个，达到的效果就是没有强烈的过渡感觉。</p><h4 id="needsUpdate-属性"><a href="#needsUpdate-属性" class="headerlink" title="needsUpdate 属性"></a>needsUpdate 属性</h4><p>如果更新了纹理的相关属性，需要将此属性设置为 true，将数据同步到 WebGL。</p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>纹理在整个表面水平方向和垂直方向重复多少次，也会受纹理重复设置的影响，设置方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load( <span class="string">"textures/water.jpg"</span> );</span><br><span class="line">texture.wrapS = THREE.RepeatWrapping; <span class="comment">//设置水平方向无限循环</span></span><br><span class="line">texture.wrapT = THREE.RepeatWrapping; <span class="comment">//设置垂直方向无限循环</span></span><br><span class="line">texture.repeat.set( <span class="number">4</span>, <span class="number">4</span> ); <span class="comment">//水平方向和垂直方向都重复四次</span></span><br></pre></td></tr></table></figure><h3 id="内置常用材质"><a href="#内置常用材质" class="headerlink" title="内置常用材质"></a>内置常用材质</h3><p>在讲解常用材质之前，我们先讲解一下如何实例化一个材质和一些需要注意的地方。我们使用第一个讲到的材质 MeshBasicMaterial 作为例子。</p><h4 id="MeshBasicMaterial-和设置颜色的方法"><a href="#MeshBasicMaterial-和设置颜色的方法" class="headerlink" title="MeshBasicMaterial 和设置颜色的方法"></a>MeshBasicMaterial 和设置颜色的方法</h4><p>这种材质是一种简单的材质，不会受到光的影响，直接看到的效果就是整个物体的颜色都是一样，没有立体的感觉。在实例化材质时，我们可以传入一个对象，设置材质的相关属性可以通过对象属性的方式传入，但是属性 color（颜色）例外，实例化的时候可以传入十六进制数，也可以写十六进制字符串。实例化完成后再修改需要重新赋值 <code>THREE.Color</code> 对象，或者调用 <code>material.color.set</code> 方法赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><p>上面的案例就是使用 MeshBasicMaterial 材质创建了一个立方体，我们设置了显示颜色为一种浅蓝色，除了上面实例化的时候进行设置，后面也可以再修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;); <span class="comment">//设置初始的颜色为浅蓝色</span></span><br><span class="line">material.color.set(<span class="number">0xff00ff</span>); <span class="comment">//将颜色修改为紫色</span></span><br></pre></td></tr></table></figure><p>我们也可以直接赋值一个新的 <code>THREE.Color</code> 对象，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;); <span class="comment">//设置初始的颜色为浅蓝色</span></span><br><span class="line">material.color = <span class="keyword">new</span> THREE.Color(<span class="number">0xff00ff</span>); <span class="comment">//将颜色修改为紫色</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <code>new THREE.Color</code> 创建一个颜色对象，Three.js 支持的颜色书写方式比较丰富，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接传入十六进制数或者字符串</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color( <span class="number">0xff0000</span> );</span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color( <span class="string">"#ff0000"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB 字符串</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color(<span class="string">"rgb(255, 0, 0)"</span>);</span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color(<span class="string">"rgb(100%, 0%, 0%)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持一百四十多中颜色名称</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color( <span class="string">'skyblue'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//HSL 字符串</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color(<span class="string">"hsl(0, 100%, 50%)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持RGB值设置在0到1之间的方式</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> THREE.Color( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br></pre></td></tr></table></figure><h4 id="MeshNormalMaterial-法向材质"><a href="#MeshNormalMaterial-法向材质" class="headerlink" title="MeshNormalMaterial 法向材质"></a>MeshNormalMaterial 法向材质</h4><p>这种材质会根据面的方向不同自动改变颜色，也是我们之前一直在用的材质。此材质不受灯光影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">//创建几何体</span></span><br><span class="line">material = <span class="keyword">new</span> THREE.MeshNormalMaterial(); <span class="comment">//创建材质</span></span><br><span class="line"></span><br><span class="line">mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material ); <span class="comment">//创建网格</span></span><br><span class="line">scene.add( mesh ); <span class="comment">//将网格添加到场景</span></span><br></pre></td></tr></table></figure><h4 id="LineBasicMaterial-线条材质"><a href="#LineBasicMaterial-线条材质" class="headerlink" title="LineBasicMaterial 线条材质"></a>LineBasicMaterial 线条材质</h4><p>在上一篇我们讲几何体时，没有讲解如何画直线，是由于直线需要单独的材质进行实现，所以我们将直线放到了材质这一篇中进行讲解。注意，由于 Windows 系统的原因，线的宽度只能为1。</p><p>要绘制线段，我们需要确定两个点，就是起点和终点，案例中我们使用了四个顶点创建了三条线。然后 Geometry 对象使用这组顶点配置几何体，实例化线的材质，最后使用 <code>THREE.Line</code> 生成线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加直线</span></span><br><span class="line"><span class="keyword">var</span> pointsArr = [</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">-10</span>, <span class="number">0</span>, <span class="number">-5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">-5</span>, <span class="number">15</span>, <span class="number">5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">20</span>, <span class="number">15</span>, <span class="number">-5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span> )</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lineGeometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//实例化几何体</span></span><br><span class="line">lineGeometry.setFromPoints(pointsArr); <span class="comment">//使用当前点的属性配置几何体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lineMaterial = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ff00</span>&#125;); <span class="comment">//材质</span></span><br><span class="line"></span><br><span class="line">line = <span class="keyword">new</span> THREE.Line(lineGeometry, lineMaterial);</span><br><span class="line">scene.add(line);</span><br></pre></td></tr></table></figure><h4 id="LineDashedMaterial-虚线"><a href="#LineDashedMaterial-虚线" class="headerlink" title="LineDashedMaterial 虚线"></a>LineDashedMaterial 虚线</h4><p>我们也可以创建虚线，这里我们来点新花样，就是实现曲线。曲线也和直线一样，在 Windows 系统线的粗度只能为1。</p><p>要创建曲线，我们需要使用到 <code>THREE.CatmullRomCurve3</code> 来生成一个 curve 对象，这是一个曲线对象，可以从对象获取生成的曲线的点的集合，在这里科普一下，曲线也是由无数段的直线组成的，段数分的越清晰，曲线过渡越顺滑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointsArr = [</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">-10</span>, <span class="number">0</span>, <span class="number">-5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">-5</span>, <span class="number">15</span>, <span class="number">5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">20</span>, <span class="number">15</span>, <span class="number">-5</span> ),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector3( <span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span> )</span><br><span class="line">];</span><br><span class="line"><span class="comment">//指定一些用于生成曲线线的三维顶点</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CatmullRomCurve3(pointsArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> points = curve.getPoints( <span class="number">50</span> ); <span class="comment">//使用getPoints获取当前曲线分成50段后的所有顶点</span></span><br><span class="line"><span class="keyword">var</span> curveGeometry = <span class="keyword">new</span> THREE.BufferGeometry().setFromPoints( points ); <span class="comment">//使用顶点生成几何体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curveMaterial = <span class="keyword">new</span> THREE.LineDashedMaterial( &#123; <span class="attr">color</span> : <span class="number">0xff0000</span> &#125; ); <span class="comment">//创建一条红色的线材质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用THREE.Line创建线</span></span><br><span class="line">curveLine = <span class="keyword">new</span> THREE.Line( curveGeometry, curveMaterial );</span><br><span class="line">curveLine.computeLineDistances(); <span class="comment">//需要重新计算位置才能显示出虚线</span></span><br><span class="line">scene.add(curveLine);</span><br></pre></td></tr></table></figure><h4 id="添加光"><a href="#添加光" class="headerlink" title="添加光"></a>添加光</h4><p>由于 MeshBasicMaterial 不会受光的影响，即使有光也不会影响它的效果，前面我们也没有添加光。但是后面介绍的材质会受到光源的影响，在介绍之前，我们需要添加一个光源，来影响材质的显示效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建灯光</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>); <span class="comment">//添加了一个白色的平行光</span></span><br><span class="line">    light.position.set(<span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">//设置光的方向</span></span><br><span class="line">    scene.add(light); <span class="comment">//添加到场景</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个全局环境光</span></span><br><span class="line">    scene.add(<span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x222222</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们添加了一个模拟太阳光线的平行光和一个对每一个物理都造成影响的环境光，具体的内容将会在下一篇讲解。</p><p>下面介绍的材质都是对光有反应的，而且如果场景内没有光，模型将无法显示。</p><h4 id="MeshLambertMaterial-兰伯特材质"><a href="#MeshLambertMaterial-兰伯特材质" class="headerlink" title="MeshLambertMaterial 兰伯特材质"></a>MeshLambertMaterial 兰伯特材质</h4><p>这种材质会对光有反应，但是不会出现高光，可以模拟一些粗糙的材质的物体，比如木头或者石头。</p><p>实现案例，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">//创建几何体</span></span><br><span class="line">material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;); <span class="comment">//创建材质</span></span><br><span class="line"></span><br><span class="line">mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material ); <span class="comment">//创建网格</span></span><br><span class="line">scene.add( mesh ); <span class="comment">//将网格添加到场景</span></span><br></pre></td></tr></table></figure><h4 id="MeshPhongMaterial-高光材质"><a href="#MeshPhongMaterial-高光材质" class="headerlink" title="MeshPhongMaterial 高光材质"></a>MeshPhongMaterial 高光材质</h4><p>这种材质具有高光效果，可以模拟一些光滑的物体的材质效果，比如油漆面，瓷瓦等光滑物体。</p><p>实现案例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">//创建几何体</span></span><br><span class="line">material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;); <span class="comment">//创建材质</span></span><br><span class="line"></span><br><span class="line">mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material ); <span class="comment">//创建网格</span></span><br><span class="line">scene.add( mesh ); <span class="comment">//将网格添加到场景</span></span><br></pre></td></tr></table></figure><h4 id="MeshStandardMaterial-基于物理的渲染（PBR）材质"><a href="#MeshStandardMaterial-基于物理的渲染（PBR）材质" class="headerlink" title="MeshStandardMaterial 基于物理的渲染（PBR）材质"></a>MeshStandardMaterial 基于物理的渲染（PBR）材质</h4><p>这种材质基于物理的渲染（PBR）材质，生成的材质效果更佳，但是相应也占用更多的计算量。这种材质我们可以定义它的粗糙度来确定反光效果，经常用于模拟金属的质感，使金属质感更加真实。</p><p>实现案例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">//创建几何体</span></span><br><span class="line">material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;<span class="attr">color</span>:<span class="number">0x00ffff</span>&#125;); <span class="comment">//创建材质</span></span><br><span class="line">material.metalness = <span class="number">0.1</span>; <span class="comment">//设置的值的范围为0-1，值越小，材质越光滑，高光越明显</span></span><br><span class="line">material.metalnessMap = <span class="number">0.1</span>; <span class="comment">//设置的值的范围为0-1，值越大，越有生锈金属的质感，值越小反光越清晰</span></span><br><span class="line"></span><br><span class="line">mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material ); <span class="comment">//创建网格</span></span><br><span class="line">scene.add( mesh ); <span class="comment">//将网格添加到场景</span></span><br></pre></td></tr></table></figure><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;基础功能之-Material-材质&quot;&gt;&lt;a href=&quot;#基础功能之-Material-材质&quot; class=&quot;headerlink&quot; title=&quot;基础功能之 Material 材质&quot;&gt;&lt;/a&gt;基础功能之 Material 材质&lt;/h2&gt;&lt;p&gt;模型的表现，也就是我们看到的的模型外观——材质。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/5cf96b13/materials.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结3</title>
    <link href="https://blog.aigisss.com/posts/c29dfeb0.html"/>
    <id>https://blog.aigisss.com/posts/c29dfeb0.html</id>
    <published>2019-10-06T09:13:20.000Z</published>
    <updated>2019-10-07T13:11:42.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="几何体-Geometry"><a href="#几何体-Geometry" class="headerlink" title="几何体 Geometry"></a>几何体 Geometry</h2><p>一个模型是由几何体 Geometry 和材质 Material 组成。Three.js 内置了很多的几何体种类，如立方体、三棱锥、球、八面体、十二面体、二十面体等等，将介绍这些几何体的模型创建和几何体的通用方法。</p><p><img src="/posts/c29dfeb0/geometry.png" alt></p><a id="more"></a><h3 id="Geometry-和-BufferGeometry"><a href="#Geometry-和-BufferGeometry" class="headerlink" title="Geometry 和 BufferGeometry"></a>Geometry 和 BufferGeometry</h3><p>当前 Three.js 内置了这两种几何体类型，这两个几何体类型都用于存储模型的顶点位置、面的索引、法向量、颜色、UV 纹理以及一些自定义的属性。</p><p>它们两个的区别是：BufferGeometry 存储的都是一些原始的数据，性能比 Geometry 高，很适合存储一些放入场景内不需要再额外操作的模型。而 Geometry 的优势刚好相反，Geometry 比 BufferGeometry 更友好，使用了 Three.js 提供的 <code>THREE.Vector3</code> 或者 <code>THREE.Color</code> 这样的对象来存储数据（顶点位置、面、颜色等），这些对象易于阅读和编辑，但效率低于 BufferGeometry 使用的类型化数组。</p><p>所以，我们可以根据项目的大小来使用不同的几何体，<strong>小项目可以使用 Geometry 实现，中大型的项目还是推荐 BufferGeometry。</strong></p><p>我们将使用较为简单的 Geometry 来实现案例。</p><h4 id="Geometry-和-BufferGeometry-互转"><a href="#Geometry-和-BufferGeometry-互转" class="headerlink" title="Geometry 和 BufferGeometry 互转"></a>Geometry 和 BufferGeometry 互转</h4><p>在这里插一点内容，两种几何体类型可以互转，所以，不要担心现在使用的是哪种。</p><ul><li>Geometry 转换成 BufferGeometry</li></ul><p>转换代码，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个Geometry对象</span></span><br><span class="line"><span class="keyword">var</span> geo = <span class="keyword">new</span> THREE.Geometry(); </span><br><span class="line"><span class="comment">//调用对象的fromBufferGeometry方法，并将需要转换的geometry传入</span></span><br><span class="line"><span class="keyword">var</span> bufferGeo = geo.fromBufferGeometry(geometry);</span><br><span class="line"><span class="comment">//返回的对象转换成的BufferGeometry</span></span><br></pre></td></tr></table></figure><ul><li><code>BufferGeometry</code>转换成<code>Geometry</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个BufferGeometry对象</span></span><br><span class="line"><span class="keyword">var</span> bufferGeo = <span class="keyword">new</span> THREE.BufferGeometry(); </span><br><span class="line"><span class="comment">//调用对象的fromGeometry方法，并将需要转换的bufferGeometry传入</span></span><br><span class="line"><span class="keyword">var</span> geo = bufferGeo.fromGeometry(bufferGeometry);</span><br><span class="line"><span class="comment">//返回的对象转换成的Geometry</span></span><br></pre></td></tr></table></figure><p>接下来，我们将讲解一下 Three.js 内置几何体。</p><h4 id="立方体-BoxGeometry-和-BoxBufferGeometry"><a href="#立方体-BoxGeometry-和-BoxBufferGeometry" class="headerlink" title="立方体 BoxGeometry 和 BoxBufferGeometry"></a>立方体 BoxGeometry 和 BoxBufferGeometry</h4><p>立方体是最早接触的几何体，可以通过设置长宽高来创建各种各样的立方体。</p><p>看下面的案例，代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;<span class="attr">color</span>: <span class="number">0x00ff00</span>&#125; );</span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( cube );</span><br></pre></td></tr></table></figure><p>案例中的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoxGeometry(width : <span class="string">'浮点类型'</span>, <span class="attr">height</span> : <span class="string">'浮点类型'</span>, <span class="attr">depth</span> : <span class="string">'浮点类型'</span>, <span class="attr">widthSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">heightSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">depthSegments</span> : <span class="string">'整数类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数的含义：</p><ul><li>width：沿 X 轴的宽度，默认值为1；</li><li>height：沿 Y 轴的高度，默认值为1；</li><li>depth：沿 Z 轴的深度，默认值为1；</li><li>widthSegments：可选，沿着边的宽度的分割面的数量。默认值为1；</li><li>heightSegments：可选，沿着边的高度的分割面的数量。默认值为1；</li><li>depthSegments：可选，沿着边的深度的分割面的数量。缺省值是1；</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="圆-CircleGeometry-和-CircleBufferGeometry"><a href="#圆-CircleGeometry-和-CircleBufferGeometry" class="headerlink" title="圆 CircleGeometry 和 CircleBufferGeometry"></a>圆 CircleGeometry 和 CircleBufferGeometry</h4><p><strong>在 WebGL 里，所有的模型都是通过三角形面组成，圆形是由多个三角形分段构成，这些三角形分段围绕一个中心点延伸并且延伸到给定半径以外。它从起始角度和给定的中心角度逆时针方向构建。它也可以用来创建规则的多边形，其中线段的数量决定了边的数量。</strong></p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CircleGeometry( <span class="number">5</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">var</span> circle = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( circle );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CircleGeometry(radius : <span class="string">'浮点类型'</span>, <span class="attr">segments</span> : <span class="string">'整数类型'</span>, <span class="attr">thetaStart</span> : <span class="string">'浮点类型'</span>, <span class="attr">thetaLength</span> : <span class="string">'浮点类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数的含义：</p><ul><li>radius：圆的半径，默认值为1；</li><li>segments：段数（三角形），最小值为3，默认值为8；</li><li>thetaStart：第一段的起始角度，默认值为0；</li><li>thetaLength：圆形扇形的中心角，通常称为 theta。默认值是 2 * Pi，画出一个整圆。</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="圆锥-ConeGeometry-和-ConeBufferGeometry"><a href="#圆锥-ConeGeometry-和-ConeBufferGeometry" class="headerlink" title="圆锥 ConeGeometry 和 ConeBufferGeometry"></a>圆锥 ConeGeometry 和 ConeBufferGeometry</h4><p>这是一个可以创建圆锥体的类。</p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ConeGeometry( <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>&#125; );</span><br><span class="line"><span class="keyword">var</span> cone = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( cone );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConeGeometry(radius : <span class="string">'浮点类型'</span>, <span class="attr">height</span> : <span class="string">'浮点类型'</span>, <span class="attr">radialSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">heightSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">openEnded</span> : <span class="string">'布尔类型'</span>, <span class="attr">thetaStart</span> : <span class="string">'浮点类型'</span>, <span class="attr">thetaLength</span> : <span class="string">'浮点类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><ul><li>radius：底部圆锥的半径，默认值为1；</li><li>height：圆锥体的高度，默认值为1；</li><li>radialSegments：圆锥周围的分段面数，默认值为8；</li><li>heightSegments：沿圆锥体高度的面的行数，默认值为1；</li><li>openEnded：圆锥体底部是是隐藏还是显示，默认值为 false，显示；</li><li>thetaStart：第一段的起始角度，默认值是0（Three.js 的0度位置）</li><li>thetaLength — 圆形扇形的中心角，通常称为 theta。默认值是2 * Pi，画出一个整圆。</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#ConeGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="圆柱-CylinderGeometry-和-CylinderBufferGeometry"><a href="#圆柱-CylinderGeometry-和-CylinderBufferGeometry" class="headerlink" title="圆柱 CylinderGeometry 和 CylinderBufferGeometry"></a>圆柱 CylinderGeometry 和 CylinderBufferGeometry</h4><p>这是一个可以创建圆柱几何体的类。</p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry( <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>&#125; );</span><br><span class="line"><span class="keyword">var</span> cylinder = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( cylinder );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CylinderGeometry(radiusTop : <span class="string">'浮点类型'</span>, <span class="attr">radiusBottom</span> : <span class="string">'浮点类型'</span>, <span class="attr">height</span> : <span class="string">'浮点类型'</span>, <span class="attr">radialSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">heightSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">openEnded</span> : <span class="string">'布尔类型'</span>, <span class="attr">thetaStart</span> : <span class="string">'浮点类型'</span>, <span class="attr">thetaLength</span> : <span class="string">'浮点类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><ul><li>radiusTop：顶部圆柱体的半径。默认值为1；</li><li>radiusBottom：底部圆柱体的半径。默认值为1；</li><li>height：圆柱体的高度。默认值为1；</li><li>radialSegments：圆柱周围的分段面数。默认值为8；</li><li>heightSegments：沿圆柱体高度的面的行数。默认值为1；</li><li>openEnded：圆柱体的两端是否显示，默认值是 false，显示；</li><li>thetaStart：第一段的起始角度，默认值是0（Three.js 的0度位置）。</li><li>thetaLength — 圆形扇形的中心角，通常称为 theta。默认值是2 * Pi，画出一个整圆。</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#CylinderGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="球-SphereGeometry-和-SphereBufferGeometry"><a href="#球-SphereGeometry-和-SphereBufferGeometry" class="headerlink" title="球 SphereGeometry 和 SphereBufferGeometry"></a>球 SphereGeometry 和 SphereBufferGeometry</h4><p>这是一个可以创建球体几何体的类。</p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry( <span class="number">5</span>, <span class="number">32</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>&#125; );</span><br><span class="line"><span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( sphere );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SphereGeometry(radius : <span class="string">'浮点类型'</span>, <span class="attr">widthSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">heightSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">phiStart</span> : <span class="string">'浮点类型'</span>, <span class="attr">phiLength</span> : <span class="string">'浮点类型'</span>, <span class="attr">thetaStart</span> : <span class="string">'浮点类型'</span>, <span class="attr">thetaLength</span> : <span class="string">'浮点类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><ul><li>radius：球体半径。默认值是1；</li><li>widthSegments：水平线段的数量。最小值是3，默认值是8；</li><li>heightSegments：垂直段的数量。最小值是2，默认值是6；</li><li>phiStart：指定水平渲染起始角度。默认值为0；</li><li>phiLength：指定水平渲染角度大小。默认值是 Math.PI * 2；</li><li>thetaStart：指定垂直渲染起始角度。默认值为0；</li><li>thetaLength：指定垂直渲染角度大小。默认是 Math.PI。</li></ul><p>默认是渲染整个的圆，如果线段越多，显得球体越圆滑。</p><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#SphereGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="平面-PlaneGeometry-和-SphereBufferGeometry"><a href="#平面-PlaneGeometry-和-SphereBufferGeometry" class="headerlink" title="平面 PlaneGeometry 和 SphereBufferGeometry"></a>平面 PlaneGeometry 和 SphereBufferGeometry</h4><p>这是一个可以创建平面几何体的类。</p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry( <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>, <span class="attr">side</span>: THREE.DoubleSide&#125; );</span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( plane );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlaneGeometry(width : <span class="string">'浮点类型'</span>, <span class="attr">height</span> : <span class="string">'浮点类型'</span>, <span class="attr">widthSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">heightSegments</span> : <span class="string">'整数类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><ul><li>width：沿 X 轴的宽度。默认值为1；</li><li>height：沿着 Y 轴的高度。默认值为1；</li><li>widthSegments：宽度的分段数，可选。默认值为1；</li><li>heightSegments：高度的分段数，可选。默认值为1。</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><h4 id="圆环-TorusGeometry-和-TorusBufferGeometry"><a href="#圆环-TorusGeometry-和-TorusBufferGeometry" class="headerlink" title="圆环 TorusGeometry 和 TorusBufferGeometry"></a>圆环 TorusGeometry 和 TorusBufferGeometry</h4><p>一个可以创建圆环几何体的类。</p><p>看下面案例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.TorusGeometry( <span class="number">10</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">100</span> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">var</span> torus = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( torus );</span><br></pre></td></tr></table></figure><p>案例中的构造函数，如下 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TorusGeometry(radius : <span class="string">'浮点类型'</span>, <span class="attr">tube</span> : <span class="string">'浮点类型'</span>, <span class="attr">radialSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">tubularSegments</span> : <span class="string">'整数类型'</span>, <span class="attr">arc</span> : <span class="string">'浮点类型'</span>)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><ul><li>radius：圆环的半径，从圆环的中心到管的中心。默认值为1；</li><li>tube：管的半径。默认值是0.4；</li><li>radialSegments：横向分段数，默认值是8；</li><li>tubularSegments：纵向分段数，默认值是6；</li><li>arc — 绘制的弧度。默认值是 Math.PI * 2，绘制整个圆环。</li></ul><p>案例查看：<a href="https://threejs.org/docs/scenes/geometry-browser.html#TorusGeometry" target="_blank" rel="noopener">请点击这里</a>。</p><p>以上是 Three.js 内置的一些基础的几何体，Three.js 还内置了一些其他的几何体模型（如字体几何体、拉伸几何体、车床几何体等），由于篇幅原因和难度原因，在这里不一一讲解。</p><p>如果迫不及待得想了解这一块的内容可以通过<a href="https://threejs.org/docs/" target="_blank" rel="noopener">官方文档</a>或者我的博客中<a href="https://blog.csdn.net/qq_30100043/article/category/7003591" target="_blank" rel="noopener">关于 Three.js 的笔记</a>来了解更多。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Geometry 和 BufferGeomety 内置了一些常用的方法，在每一种几何体上面，我们都可以调用相关的方法来达到我们的目的。</p><h4 id="center"><a href="#center" class="headerlink" title="center()"></a>center()</h4><p>此方法为居中方法，可以根据边界框居中几何图形。</p><h4 id="computeBoundingBox"><a href="#computeBoundingBox" class="headerlink" title="computeBoundingBox()"></a>computeBoundingBox()</h4><p>此方法可以计算几何的边界框，方法调用后，会更新 <code>Geometry.boundingBox</code> 属性，我们可以通过 <code>Geometry.boundingBox</code> 属性获取到一个包围几何体的立方体的每个轴向的最大值和最小值。</p><h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h4><p>将几何体从内存中删除，这个方法必须记得使用。如果频繁的删除模型，一定要记得将几何体从内存中删除掉。</p><h3 id="总结案例"><a href="#总结案例" class="headerlink" title="总结案例"></a>总结案例</h3><p>最后，我将上面介绍的所有几何体放到一个场景内，制作了一个小案例，案例代码地址如下：</p><ul><li><a href="https://github.com/Cenergy/webpack-threejs/blob/master/src/test/second.js" target="_blank" rel="noopener">Github 地址</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;几何体-Geometry&quot;&gt;&lt;a href=&quot;#几何体-Geometry&quot; class=&quot;headerlink&quot; title=&quot;几何体 Geometry&quot;&gt;&lt;/a&gt;几何体 Geometry&lt;/h2&gt;&lt;p&gt;一个模型是由几何体 Geometry 和材质 Material 组成。Three.js 内置了很多的几何体种类，如立方体、三棱锥、球、八面体、十二面体、二十面体等等，将介绍这些几何体的模型创建和几何体的通用方法。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/c29dfeb0/geometry.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结2</title>
    <link href="https://blog.aigisss.com/posts/b59ace26.html"/>
    <id>https://blog.aigisss.com/posts/b59ace26.html</id>
    <published>2019-10-04T06:26:47.000Z</published>
    <updated>2019-10-07T14:52:16.513Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="Scene-场景和页面调试"><a href="#Scene-场景和页面调试" class="headerlink" title="Scene 场景和页面调试"></a>Scene 场景和页面调试</h2><p>场景是我们每个 Three.js 项目里面放置内容的容器，我们也可以拥有多个场景进行切换展示，你可以在场景内放置你的模型、灯光和照相机。还可以通过调整场景的位置，让场景内的所有内容都一起跟着调整位置。</p><p><img src="/posts/b59ace26/scence.png" alt></p><a id="more"></a><h3 id="场景的结构"><a href="#场景的结构" class="headerlink" title="场景的结构"></a>场景的结构</h3><p>之前在刚刚开始学 JavaScript 基础时，我们总免不了去操作 DOM 对象，而且我们都知道 DOM 的结构是树形结构的，Three.js 也遵循了这样的理念，将所有可以添加到场景内的结构梳理成了一种树形的结构，方便我们能够更好的理解Three.js。</p><p>我们可以把 Scene 想象成一个 body，body 内可以添加 DOM 对象，scene 内也可以添加它的 3D 对象，这样一层层的嵌套出来，组成了我们现在需要的项目。所以，在 Three.js 中，为了方便操作，将所有 3D 对象共同的内容抽象成了一个基类，就是 <code>THREE.Object3D</code>。</p><h3 id="THREE-Object3D"><a href="#THREE-Object3D" class="headerlink" title="THREE.Object3D"></a>THREE.Object3D</h3><p>为了方便操作，Three.js 将每个能够直接添加到场景内的对象都继承自一个基类——<code>THREE.Object3D</code>，以后我们将继承自这个基类的对象称为 3D 对象，判断一个对象是否是继承自 <code>THREE.Object3D</code>，我们可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> THREE.Object3D</span><br><span class="line"><span class="comment">//继承至返回 true 否则返回false</span></span><br></pre></td></tr></table></figure><p>这个基类上封装了我们常用的一些方法，下面我们分别介绍下。</p><h4 id="添加一个-3D-对象"><a href="#添加一个-3D-对象" class="headerlink" title="添加一个 3D 对象"></a>添加一个 3D 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh); <span class="comment">//将网格添加到场景</span></span><br></pre></td></tr></table></figure><p>将一个立方体添加到场景内显示。</p><p>这个方法不光能够在场景内使用，而且也可以将一个 3D 对象添加到另一个 3D 对象里面，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.add(child);</span><br></pre></td></tr></table></figure><h4 id="获取一个-3D-对象"><a href="#获取一个-3D-对象" class="headerlink" title="获取一个 3D 对象"></a>获取一个 3D 对象</h4><p>获取一个 3D 对象可以使用 getObjectByName 通过 3D 对象的 name 值进行获取，在获取前我们首先要设置当前 3D 对象的 name 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object3D.name = <span class="string">"firstObj"</span>;</span><br><span class="line">scene.add(object3D);</span><br><span class="line">scene.getObjectByName(<span class="string">"firstObj"</span>); <span class="comment">//返回第一个匹配的3d对象</span></span><br></pre></td></tr></table></figure><p>另一种方式就是使用 getObjectById 通过 3D 对象的 id 值进行获取，3D 对象的 id 值只能读取，它是在添加到场景时，按 1、2、3、4、5……的顺序默认生成的一个值，无法自定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.getObjectById(<span class="number">1</span>); <span class="comment">//返回id值为1的3d对象</span></span><br></pre></td></tr></table></figure><h4 id="删除一个-3D-对象"><a href="#删除一个-3D-对象" class="headerlink" title="删除一个 3D 对象"></a>删除一个 3D 对象</h4><p>如果我们想隐藏一个 3D 对象，而不让它显示，可以通过设置它的 visible的值来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.visible = <span class="literal">false</span>; <span class="comment">//设置为false，模型将不会被渲染到场景内</span></span><br></pre></td></tr></table></figure><p>如果一个模型不再被使用到，需要彻底删除，我们可以使用 remove 方法进行删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh); <span class="comment">//将一个模型添加到场景当中</span></span><br><span class="line">scene.remove(mesh); <span class="comment">//将一个模型从场景中删除</span></span><br></pre></td></tr></table></figure><h4 id="获取到所有的子类"><a href="#获取到所有的子类" class="headerlink" title="获取到所有的子类"></a>获取到所有的子类</h4><p>每一个 3D 对象都有一个 children 属性，这是一个数组，里面包含所有添加的 3D 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh1);</span><br><span class="line">scene.add(mesh2);</span><br><span class="line"><span class="built_in">console</span>.log(scene.children);</span><br><span class="line"><span class="comment">// [mesh1, mesh2]</span></span><br></pre></td></tr></table></figure><p>如果想获取 3D 对象下面所有的 3D 对象，我们可以通过 traverse方法获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mesh1.add(mesh2); <span class="comment">//mesh2是mesh1的子元素</span></span><br><span class="line">scene.add(mesh1); <span class="comment">//mesh1是场景对象的子元素</span></span><br><span class="line">scene.traverse(fucntion(child)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(child);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//将按顺序分别将mesh1和mesh2打印出来</span></span><br></pre></td></tr></table></figure><h4 id="获取-3D-对象的父元素"><a href="#获取-3D-对象的父元素" class="headerlink" title="获取 3D 对象的父元素"></a>获取 3D 对象的父元素</h4><p>每个 3D 对象都有一个父元素，可以通过 parent 属性进行获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scene.add(mesh); <span class="comment">//将模型添加到场景</span></span><br><span class="line"><span class="built_in">console</span>.log(mesh.parent === scene); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="修改-3D-对象"><a href="#修改-3D-对象" class="headerlink" title="修改 3D 对象"></a>修改 3D 对象</h4><p>前面介绍了场景的结构以及场景的 3D 对象添删查，下面，我们接着介绍对场景内模型的一些操作。</p><h5 id="修改位置方式"><a href="#修改位置方式" class="headerlink" title="修改位置方式"></a>修改位置方式</h5><p>我们可以通过设置模型的 position 属性来修改模型的当前位置，具体方法有以下几种。</p><ul><li>单独设置每个方向的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.x = <span class="number">3</span>; <span class="comment">//将模型的位置调整到x正轴距离原点为3的位置。</span></span><br><span class="line">mesh.position.y += <span class="number">5</span>; <span class="comment">//将模型的y轴位置以当前的位置向上移动5个单位。</span></span><br><span class="line">mesh.position.z -= <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>直接一次性设置所有方向的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.set(<span class="number">3</span>, <span class="number">5</span>, <span class="number">-6</span>);  <span class="comment">//直接将模型的位置设置在x轴为3，y轴为5，z轴为-6的位置</span></span><br></pre></td></tr></table></figure><ul><li>Three.js 模型的位置属性是一个 <code>THREE.Vector3</code>（三维向量）的对象，我们可以直接重新赋值一个新的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.position = <span class="keyword">new</span> THREE.Vector3(<span class="number">3</span>, <span class="number">5</span>, <span class="number">-6</span>); <span class="comment">//上面的设置位置也可以通过这样设置。</span></span><br></pre></td></tr></table></figure><h5 id="修改大小的方式"><a href="#修改大小的方式" class="headerlink" title="修改大小的方式"></a>修改大小的方式</h5><p>模型导入后，很多情况下都需要调整模型的大小。我们可以通过设置模型的 scale 属性来调整大小。</p><ul><li>第一种方式是单独设置每个方向的缩放。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.scale.x = <span class="number">2</span>; <span class="comment">//模型沿x轴放大一倍</span></span><br><span class="line">mesh.scale.y = <span class="number">0.5</span>; <span class="comment">//模型沿y轴缩小一倍</span></span><br><span class="line">mesh.scale.z = <span class="number">1</span>; <span class="comment">//模型沿z轴保持不变</span></span><br></pre></td></tr></table></figure><ul><li>第二种是使用 set 方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.scale.set(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//每个方向等比放大一倍</span></span><br><span class="line">mesh.scale.set(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>); <span class="comment">//每个方向等比缩小一倍</span></span><br></pre></td></tr></table></figure><ul><li>第三种方式，由于 scale 属性也是一个三维向量，我们可以通过赋值的方式重新修改。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.scale = <span class="keyword">new</span> THREE.Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//每个方向都放大一倍</span></span><br></pre></td></tr></table></figure><h5 id="修改模型的转向"><a href="#修改模型的转向" class="headerlink" title="修改模型的转向"></a>修改模型的转向</h5><p>很多情况下，我们需要对模型进行旋转，以达到将模型显示出它需要显示的方位，我们可以通过设置模型的 rotation 属性进行旋转（注意：旋转 Three.js 使用的是弧度不是角度）。</p><ul><li>第一种方式是单独设置每个轴的旋转。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.rotation.x = <span class="built_in">Math</span>.PI; <span class="comment">//模型沿x旋转180度</span></span><br><span class="line">mesh.rotation.y = <span class="built_in">Math</span>.PI * <span class="number">2</span>; <span class="comment">//模型沿y轴旋转360度，跟没旋转一样的效果。。。</span></span><br><span class="line">mesh.rotation.z = - <span class="built_in">Math</span>.PI / <span class="number">2</span>; <span class="comment">//模型沿z轴逆时针旋转90度</span></span><br></pre></td></tr></table></figure><ul><li>第二种方式就是使用 set 方法重新赋值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.rotation.set(<span class="built_in">Math</span>.PI, <span class="number">0</span>, - <span class="built_in">Math</span>.PI / <span class="number">2</span>); <span class="comment">//旋转效果和第一种显示的效果相同</span></span><br></pre></td></tr></table></figure><p>正常模型的旋转方式是按照 XYZ 依次旋转的，如果你想先旋转其他轴，我们可以添加第四项修改，有可能的情况为：YZX、ZXY、XZY、YXZ 和 ZYX。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.rotation.set(<span class="built_in">Math</span>.PI, <span class="number">0</span>, - <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="string">"YZX"</span>); <span class="comment">//先沿y轴旋转180度，再沿z轴旋转0度，最后沿x轴逆时针旋转90度</span></span><br></pre></td></tr></table></figure><ul><li>第三种方式，模型的 rotation 属性其实是一个欧拉角对象（<code>THREE.Euler</code>），欧拉角后面会讲解到，我们可以通过重新赋值一个欧拉角对象来实现旋转调整：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh.rotation = <span class="keyword">new</span> THREE.Euler(<span class="built_in">Math</span>.PI, <span class="number">0</span>, - <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="string">"YZX"</span>);</span><br></pre></td></tr></table></figure><h3 id="使用-dat-GUI-实现页面调试"><a href="#使用-dat-GUI-实现页面调试" class="headerlink" title="使用 dat.GUI 实现页面调试"></a>使用 dat.GUI 实现页面调试</h3><p>有些时候，我们需要调整模型的位置或者大小等，且需要每次都去场景内调试，一种常用的插件 <code>dat.GUI</code></p><ul><li>首先，需要将插件的源码引入到页面当中，我这里直接使用 CDN 的连接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/dat-gui/0.7.1/dat.gui.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>创建一个对象，在里面设置我们需要修改的一些数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">controls = &#123;</span><br><span class="line">    positionX:<span class="number">0</span>,</span><br><span class="line">    positionY:<span class="number">0</span>,</span><br><span class="line">    positionZ:<span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>实例化<code>dat.GUI</code>对象，将需要修改的配置添加对象中，并监听变化回调。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(controls, <span class="string">"positionX"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updatePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mesh.position.set(controls.positionX, controls.positionY, controls.positionZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/11b4aae0-60ff-11e8-8a60-1bdde4cc4659" alt="enter image description here"></p><p>这样，只要我们每次修改对象里面的值，都会触发 <code>updatePosition</code> 回调，来更新模型的位置。这样，我们就实现了一个简单的案例。</p><p>接下来，我列出一下经常会使用到一些方式和方法。</p><h4 id="生成一个输入框"><a href="#生成一个输入框" class="headerlink" title="生成一个输入框"></a>生成一个输入框</h4><p><code>dat.GUI</code> 能够根据 controls 值的不同而生成不同的操作方法，如果值的类型为字符串或者数字类型，则可以生成一个默认的输入框：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gui.add(controls, <span class="string">"positionX"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/ff916b00-60fe-11e8-b977-f33e31f528f0" alt="enter image description here"></p><h4 id="生成一个可以滑动的滑块"><a href="#生成一个可以滑动的滑块" class="headerlink" title="生成一个可以滑动的滑块"></a>生成一个可以滑动的滑块</h4><p>使用 <code>gui.add()</code> 方法，如果值为数字类型，传入的第三个值（最小值）和第四个值（最大值），就限制了值能够取值的范围，这样就生成了可以滑动的滑块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gui.add(controls, <span class="string">"positionX"</span>, <span class="number">-1</span>, <span class="number">1</span>); <span class="comment">//设置了最小值和最大值，可以生成滑块</span></span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>).max(<span class="number">1</span>); <span class="comment">//只设置了最大值，无法生成滑块</span></span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>).min(<span class="number">-1</span>); <span class="comment">//只设置了最小值，也无法生成滑块</span></span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/d87954b0-60fe-11e8-a59f-c7ac04233ce1" alt="enter image description here"></p><p>我们还可以通过 step() 方法来限制每次变化的最小值，也就是你增加或者减少，必须都是这个值的倍数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gui.add(controls, <span class="string">"positionX"</span>, <span class="number">-10</span>, <span class="number">10</span>).step(<span class="number">1</span>); <span class="comment">//限制必须为整数</span></span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>, <span class="number">-10</span>, <span class="number">10</span>).step(<span class="number">0.1</span>); <span class="comment">//每次变化都是0.1的倍数</span></span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>, <span class="number">-10</span>, <span class="number">10</span>).step(<span class="number">10</span>); <span class="comment">//每次变化都是10的倍数</span></span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/360d2c00-60ff-11e8-b977-f33e31f528f0" alt="step"></p><h4 id="生成一个下拉框"><a href="#生成一个下拉框" class="headerlink" title="生成一个下拉框"></a>生成一个下拉框</h4><p>只要按规则在 <code>gui.add()</code> 的第三个值传入一个对象或者数组，<code>dat.GUI</code> 就能够自动匹配生成一个下拉框：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controls = &#123;</span><br><span class="line">    positionX:<span class="number">0</span>,</span><br><span class="line">    positionY:<span class="literal">false</span>,</span><br><span class="line">    positionZ:<span class="string">"middle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(controls, <span class="string">"positionX"</span>, &#123;<span class="attr">left</span>:<span class="number">-10</span>, <span class="attr">middle</span>:<span class="number">0</span>, <span class="attr">right</span>:<span class="number">10</span>&#125;); <span class="comment">//数字类型的下拉框</span></span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>, [<span class="literal">true</span>, <span class="literal">false</span>]); <span class="comment">//布尔值类型的下拉框</span></span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>, [<span class="string">"left"</span>, <span class="string">"middle"</span>, <span class="string">"right"</span>]); <span class="comment">//字符串类型的下拉框</span></span><br></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/00b45540-6101-11e8-b864-0bd1f4b74dfb" alt="下拉框"></p><h4 id="生成一个-Checkbox"><a href="#生成一个-Checkbox" class="headerlink" title="生成一个 Checkbox"></a>生成一个 Checkbox</h4><p>只要 controls 的值是一个布尔类型，使用 <code>gui.add()</code> 方法就可以生成一个复选框：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controls = &#123;</span><br><span class="line">    positionX:<span class="literal">true</span>,</span><br><span class="line">    positionY:<span class="literal">false</span>,</span><br><span class="line">    positionZ:<span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(controls, <span class="string">"positionX"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/68ceb940-6101-11e8-8a60-1bdde4cc4659" alt="复选框"></p><h4 id="生成一个点击事件按钮"><a href="#生成一个点击事件按钮" class="headerlink" title="生成一个点击事件按钮"></a>生成一个点击事件按钮</h4><p>如果 controls 的值为一个函数 Function，<code>dat.GUI</code> 会自动生成一个可以点击的按钮，当按下时就会触发这个函数事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controls = &#123;</span><br><span class="line">    positionX:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    positionY:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    positionZ:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(controls, <span class="string">"positionX"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/d30f6330-6102-11e8-8a60-1bdde4cc4659" alt="事件按钮"></p><h4 id="修改显示的名称"><a href="#修改显示的名称" class="headerlink" title="修改显示的名称"></a>修改显示的名称</h4><p>我们可以在后面使用 name() 事件设置显示的名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gui.add(controls, <span class="string">"positionX"</span>, <span class="number">-1</span>, <span class="number">1</span>).name(<span class="string">"x轴"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>, <span class="number">-1</span>, <span class="number">1</span>).name(<span class="string">"y轴"</span>);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>, <span class="number">-1</span>, <span class="number">1</span>).name(<span class="string">"z轴"</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/bb928ce0-6103-11e8-b977-f33e31f528f0" alt="自定义显示名称"></p><h4 id="颜色选择框"><a href="#颜色选择框" class="headerlink" title="颜色选择框"></a>颜色选择框</h4><p>实现颜色选择框，首先需要一种正常格式的颜色值，比如 CSS 的颜色样式或者 RGB 格式，然后再使用 <code>gui.addColor()</code> 的方法添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controls = &#123;</span><br><span class="line">    positionX:<span class="string">"#cccccc"</span>, <span class="comment">//css样式</span></span><br><span class="line">    positionY: [<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>], <span class="comment">//RGB格式</span></span><br><span class="line">    positionZ: [<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>] <span class="comment">//RGBA格式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.addColor(controls, <span class="string">"positionX"</span>).name(<span class="string">"x轴"</span>);</span><br><span class="line">gui.addColor(controls, <span class="string">"positionY"</span>).name(<span class="string">"y轴"</span>);</span><br><span class="line">gui.addColor(controls, <span class="string">"positionZ"</span>).name(<span class="string">"z轴"</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/e6796900-6104-11e8-8a60-1bdde4cc4659" alt="颜色选择框"></p><h4 id="监听事件回调"><a href="#监听事件回调" class="headerlink" title="监听事件回调"></a>监听事件回调</h4><p><code>dat.GUI</code> 给我们提供了监听事件回调的方法 onChange()，如果值变化就能够触发函数回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gui.add(controls, <span class="string">"positionX"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">gui.add(controls, <span class="string">"positionY"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">gui.add(controls, <span class="string">"positionZ"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updatePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mesh.position.set(controls.positionX, controls.positionY, controls.positionZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h4><p>我们可以使用 <code>gui.addFolder()</code> 方法来创建分组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line"><span class="keyword">var</span> first = gui.addFolder(<span class="string">"第一个分组"</span>); <span class="comment">//创建第一个分组</span></span><br><span class="line">first.add(controls, <span class="string">"positionX"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">first.open();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> two = gui.addFolder(<span class="string">"第二个分组"</span>);</span><br><span class="line">two.add(controls, <span class="string">"positionY"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br><span class="line">two.add(controls, <span class="string">"positionZ"</span>, <span class="number">-1</span>, <span class="number">1</span>).onChange(updatePosition);</span><br></pre></td></tr></table></figure><p><img src="/posts/b59ace26/3d02f730-6107-11e8-8a60-1bdde4cc4659" alt="分组"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Scene-场景和页面调试&quot;&gt;&lt;a href=&quot;#Scene-场景和页面调试&quot; class=&quot;headerlink&quot; title=&quot;Scene 场景和页面调试&quot;&gt;&lt;/a&gt;Scene 场景和页面调试&lt;/h2&gt;&lt;p&gt;场景是我们每个 Three.js 项目里面放置内容的容器，我们也可以拥有多个场景进行切换展示，你可以在场景内放置你的模型、灯光和照相机。还可以通过调整场景的位置，让场景内的所有内容都一起跟着调整位置。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/posts/b59ace26/scence.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结1</title>
    <link href="https://blog.aigisss.com/posts/2c939f9c.html"/>
    <id>https://blog.aigisss.com/posts/2c939f9c.html</id>
    <published>2019-09-29T02:35:56.000Z</published>
    <updated>2019-09-29T15:34:40.906Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><p><img src="/posts/2c939f9c/165ea89aa7559037.jpg" alt></p><a id="more"></a><p><strong>使用 Three.js 显示创建的内容，我们必须需要的三大件是：渲染器、相机和场景。</strong>相机获取到场景内显示的内容，然后再通过渲染器渲染到画布上面。</p><p>要在屏幕上展示3D图形，思路大体上都是这样的：</p><ol><li>构建一个三维空间<ul><li>Three中称之为场景(Scene)</li></ul></li><li>选择一个观察点，并确定观察方向/角度等<ul><li>Three中称之为相机(Camera)</li></ul></li><li>在场景中添加供观察的物体<ul><li>Three中的物体有很多种，包括Mesh,Line,Points等，它们都继承自Object3D类</li></ul></li><li>将观察到的场景渲染到屏幕上的指定区域<ul><li>Three中使用Renderer完成这一工作</li></ul></li></ol><h2 id="构建场景-Scene"><a href="#构建场景-Scene" class="headerlink" title="构建场景 Scene"></a>构建场景 Scene</h2><p>场景是所有物体的容器，也对应着我们创建的三维世界。</p><h2 id="创建相机-Camera"><a href="#创建相机-Camera" class="headerlink" title="创建相机 Camera"></a>创建相机 Camera</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化相机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCamera</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">200</span>); <span class="comment">// 实例化相机</span></span><br><span class="line">  camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>Three中的相机有两种，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。</p><p><img src="/posts/2c939f9c/v2-3a0604ded6e3edc25e5b12fd63ba97bb_hd.png" alt="img"></p><p>正交投影与透视投影的区别如上图所示，左图是正交投影，物体发出的光平行地投射到屏幕上，远近的方块都是一样大的；右图是透视投影，近大远小，符合我们平时看东西的感觉。<br><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%B8%89%E7%BB%B4%E6%8A%95%E5%BD%B1" target="_blank" rel="noopener">维基百科：三维投影</a></p><h4 id="正交投影相机"><a href="#正交投影相机" class="headerlink" title="正交投影相机"></a>正交投影相机</h4><p><img src="/posts/2c939f9c/v2-62ede52e0bb0d8b49f6cf2e41debc247_hd.jpg" alt="img"></p><p>可以近似地认为，视景体里的物体平行投影到近平面上，然后近平面上的图像被渲染到屏幕上。</p><h4 id="透视投影相机"><a href="#透视投影相机" class="headerlink" title="透视投影相机"></a>透视投影相机</h4><p><img src="/posts/2c939f9c/v2-3b160a77bda7661c4dd3920ddeaae605_hd.jpg" alt="img"></p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>Camera是三维世界中的观察者，为了观察这个世界，首先我们要描述空间中的位置，Three中使用采用常见的<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E5%9D%90%E6%A0%87%E7%B3%BB%23.E4.B8.89.E7.B6.AD.E7.A9.BA.E9.96.93" target="_blank" rel="noopener">右手坐标系</a>定位：</p><p><img src="/posts/2c939f9c/zbx.png" alt></p><p>我们这里使用到的是 <code>THREE.PerspectiveCamera</code>，这个相机模拟人眼看到的效果，就是具有透视的效果，近大远小。</p><p>第一行，我们实例化了一个透视相机，需要四个值，分别是视野、宽高比、近裁面和远裁面。</p><ul><li>视野：当前相机视野的宽度，值越大，渲染出来的内容也会更多。</li><li>宽高比：默认是按照画布显示的宽高比例来设置，如果比例设置的不对，会发现渲染出来的画面有拉伸或者压缩的感觉。</li><li>近裁面和远裁面：这个是设置相机可以看到的场景内容的范围，如果场景内的内容位置不在这两个值内的话，将不会被显示到渲染的画面中。</li></ul><p>第二行，我们设置了相机的位置。</p><h2 id="创建渲染器-Renderer"><a href="#创建渲染器-Renderer" class="headerlink" title="创建渲染器 Renderer"></a>创建渲染器 Renderer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化渲染器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    renderer = <span class="keyword">new</span> THREE.WebGLRenderer(); <span class="comment">//实例化渲染器</span></span><br><span class="line">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight); <span class="comment">//设置宽和高</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//添加到dom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行实例化了一个 <code>THREE.WebGLRenderer</code>，这是一个基于 WebGL 渲染的渲染器，当然，Three.js 向下兼容，还有 CanvasRenderer、CSS2DRenderer、CSS3DRenderer 和 SVGRenderer，这四个渲染器分别基于 canvas2D、CSS2D、CSS3D 和 SVG 渲染的渲染器。由于，作为 3D 渲染，WebGL 渲染的效果最好，并且支持的功能更多。</p><p>第二行，调用了一个设置函数 setSize 方法，这个是设置需要显示的窗口大小。案例是基于浏览器全屏显示，所以设置了浏览器窗口的宽和高。</p><p>第三行，<code>renderer.domElement</code> 是在实例化渲染器时生成的一个 Canvas 画布，渲染器渲染界面生成的内容，都将在这个画布上显示。所以，我们将这个画布添加到了 DOM 当中，来显示渲染的内容。</p><h2 id="创建模型-Object3D"><a href="#创建模型-Object3D" class="headerlink" title="创建模型 Object3D"></a>创建模型 Object3D</h2><p>渲染器，场景和相机都全了，是不是就能显示东西了？不能！因为场景内没有内容，即使渲染出来也是一片漆黑，所以我们需要往场景里面添加内容。接下来，我们将查看 initMesh 方法，看看如何创建一个最简单的模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMesh</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">//创建几何体</span></span><br><span class="line">    material = <span class="keyword">new</span> THREE.MeshNormalMaterial(); <span class="comment">//创建材质</span></span><br><span class="line"></span><br><span class="line">    mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material ); <span class="comment">//创建网格</span></span><br><span class="line">    scene.add( mesh ); <span class="comment">//将网格添加到场景</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个网格（模型）需要两种对象：几何体和材质。</p><ul><li>几何体代表模型的形状，它是由固定的点的位置组成，点绘制出面，面组成了模型。</li><li>材质是我们看到当前模型显示出来的效果，如显示的颜色，质感等。</li></ul><p>Three中供显示的物体有很多，它们都继承自Object3D类</p><h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p>我们都知道，计算机的世界里，一条弧线是由有限个点构成的有限条线段连接得到的。线段很多时，看起来就是一条平滑的弧线了。<br>计算机中的三维模型也是类似的，普遍的做法是用三角形组成的网格来描述，我们把这种模型称之为Mesh模型。</p><p><img src="/posts/2c939f9c/v2-d1ac417178674e359837b5795edca3b3_hd.jpg" alt="img"></p><blockquote><p>这是那只著名的<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Stanford_bunny" target="_blank" rel="noopener">斯坦福兔子</a>。它在3D图形中的地位与数字图像处理领域中著名的<a href="[https://baike.baidu.com/item/%E8%8E%B1%E5%A8%9C%E5%9B%BE/3797874?fr=aladdin">Lenna</a>是类似的。<br>看这只兔子，随着三角形数量的增加，它的表面越来越平滑</p></blockquote><p>在Three中，Mesh的构造函数是这样的：Mesh( geometry, material )<br>geometry是它的形状，material是它的材质。<br>不止是Mesh，创建很多物体都要用到这两个属性。下面我们来看看这两个重要的属性。</p><h4 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h4><p>Geometry，形状，相当直观。Geometry通过存储模型用到的点集和点间关系(哪些点构成一个三角形)来达到描述物体形状的目的。<br>Three提供了立方体(其实是长方体)、平面(其实是长方形)、球体、圆形、圆柱、圆台等许多基本形状；<br>你也可以通过自己定义每个点的位置来构造形状；<br>对于比较复杂的形状，我们还可以通过外部的模型文件导入。</p><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p>Material，材质，这就没有形状那么直观了。<br>材质其实是物体表面除了形状以为所有可视属性的集合，例如色彩、纹理、光滑度、透明度、反射率、折射率、发光度。<br>这里讲一下材质(Material)、贴图(Map)和纹理(Texture)的关系。<br>材质上面已经提到了，它包括了贴图以及其它。<br>贴图其实是‘贴’和‘图’，它包括了图片和图片应当贴到什么位置。<br>纹理嘛，其实就是‘图’了。<br>Three提供了多种材质可供选择，能够自由地选择漫反射/镜面反射等材质。</p><h2 id="创建光影Light"><a href="#创建光影Light" class="headerlink" title="创建光影Light"></a>创建光影Light</h2><p>神说：要有光！<br>光影效果是让画面丰富的重要因素。<br>Three提供了包括环境光AmbientLight、点光源PointLight、 聚光灯SpotLight、方向光DirectionalLight、半球光HemisphereLight等多种光源。<br>只要在场景中添加需要的光源就好了。</p><h2 id="让场景动起来"><a href="#让场景动起来" class="headerlink" title="让场景动起来"></a>让场景动起来</h2><p>动画，就是多幅图片一直切换便可显示动画的效果。为了能显示动画的效果，我们首先要了解一个函数 requestAnimationFrame，这个函数专门为了动画而出现。它与 setInterval 相比，优势在于不需要设置多长时间重新渲染，而是在当前线程内 JS 空闲时自动渲染，并且最大帧数控制在一秒60帧。所以，我们书写了一个可以循环调用的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestAnimationFrame(animate); <span class="comment">//循环调用函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环调用的函数中，每一帧我们都让页面重新渲染相机拍摄下来的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.render( scene, camera ); <span class="comment">//渲染界面</span></span><br></pre></td></tr></table></figure><p>渲染的 render 方法需要两个值，第一个值是场景对象，第二个值是相机对象。这意味着，你可以有多个相机和多个场景，可以通过渲染不同的场景和相机让画布上显示不同的画面。</p><p>但是，如果现在一直渲染的话，我们发现就一个立方体在那，也没有动，我们需要做的是让立方体动起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.rotation.x += <span class="number">0.01</span>; <span class="comment">//每帧网格模型的沿x轴旋转0.01弧度</span></span><br><span class="line">mesh.rotation.y += <span class="number">0.02</span>; <span class="comment">//每帧网格模型的沿y轴旋转0.02弧度</span></span><br></pre></td></tr></table></figure><p>每一个实例化的网格对象都有一个 rotation 的值，通过设置这个值可以让立方体旋转起来。在每一帧里，我们让立方体沿 x 轴方向旋转0.01弧度，沿 y 轴旋转0.02弧度（1π 弧度等于180度角度）。</p><h2 id="Three-js-的性能检测插件"><a href="#Three-js-的性能检测插件" class="headerlink" title="Three.js 的性能检测插件"></a>Three.js 的性能检测插件</h2><p>在 Three.js 里面，遇到最多的问题就是性能问题，所以我们需要时刻检测当前的 Three.js 的性能。现在 Three.js 常使用的一款插件叫 stats。接下来我们看看如何将 stats 插件在 Three.js 的项目中使用。</p><ul><li>首先在页面中引入插件代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://www.wjceo.com/lib/js/libs/stats.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是 一个 CDN 的地址，直接引入即可。</p><ul><li>然后，我们需要实例化一个 stats 对象，然后把对象内生成的 DOM 添加到页面当中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats = <span class="keyword">new</span> Stats();</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(stats.dom);</span><br></pre></td></tr></table></figure><ul><li>最后一步，我们需要在 requestAnimationFrame 的回调里面更新每次渲染的时间：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestAnimationFrame(animate); <span class="comment">//循环调用函数</span></span><br><span class="line">    stats.update(); <span class="comment">//更新性能插件</span></span><br><span class="line">    renderer.render( scene, camera ); <span class="comment">//渲染界面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了性能检测插件以后，整个代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Stats插件案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      canvas &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/three.js/92/three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.wjceo.com/lib/js/libs/stats.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//声明一些全局变量</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> renderer, camera, scene, geometry, material, mesh, stats;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//初始化渲染器</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">initRenderer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        renderer = <span class="keyword">new</span> THREE.WebGLRenderer(); <span class="comment">//实例化渲染器</span></span></span><br><span class="line"><span class="javascript">        renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight); <span class="comment">//设置宽和高</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//添加到dom</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//初始化场景</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">initScene</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        scene = <span class="keyword">new</span> THREE.Scene(); <span class="comment">//实例化场景</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//初始化相机</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">initCamera</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span></span><br><span class="line">          45,</span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span></span><br><span class="line">          0.1,</span><br><span class="line">          200</span><br><span class="line"><span class="javascript">        ); <span class="comment">//实例化相机</span></span></span><br><span class="line">        camera.position.set(0, 0, 15);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//创建模型</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">initMesh</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//创建几何体</span></span></span><br><span class="line"><span class="javascript">        material = <span class="keyword">new</span> THREE.MeshNormalMaterial(); <span class="comment">//创建材质</span></span></span><br><span class="line"><span class="javascript">        mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//创建网格</span></span></span><br><span class="line"><span class="javascript">        scene.add(mesh); <span class="comment">//将网格添加到场景</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//运行动画</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        requestAnimationFrame(animate); <span class="comment">//循环调用函数</span></span></span><br><span class="line"><span class="javascript">        mesh.rotation.x += <span class="number">0.01</span>; <span class="comment">//每帧网格模型的沿x轴旋转0.01弧度</span></span></span><br><span class="line"><span class="javascript">        mesh.rotation.y += <span class="number">0.02</span>; <span class="comment">//每帧网格模型的沿y轴旋转0.02弧度</span></span></span><br><span class="line"><span class="javascript">        stats.update(); <span class="comment">//更新性能检测框</span></span></span><br><span class="line"><span class="javascript">        renderer.render(scene, camera); <span class="comment">//渲染界面</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//性能检测框</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">initStats</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        stats = <span class="keyword">new</span> Stats();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(stats.dom);</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//初始化函数，页面加载完成是调用</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        initRenderer();</span><br><span class="line">        initScene();</span><br><span class="line">        initCamera();</span><br><span class="line">        initMesh();</span><br><span class="line">        initStats();</span><br><span class="line">        animate();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/2c939f9c/165ea89aa7559037.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Threejs" scheme="https://blog.aigisss.com/tags/Threejs/"/>
    
  </entry>
  
  <entry>
    <title>THREE.js的学习与总结</title>
    <link href="https://blog.aigisss.com/posts/cb98d479.html"/>
    <id>https://blog.aigisss.com/posts/cb98d479.html</id>
    <published>2019-09-27T13:05:25.000Z</published>
    <updated>2019-10-07T14:53:13.925Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h3 id="Three-js基础知识"><a href="#Three-js基础知识" class="headerlink" title="Three.js基础知识"></a>Three.js基础知识</h3><p>使用Three.js绘制一个三维效果，至少需要以下几个步骤：</p><ul><li>创建一个容纳三维空间的场景 (<strong><em>\</em>Sence**</strong>)</li><li>将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置</li><li>给定一个观察场景的位置，以及观察角度，我们用相机对象（<strong><em>\</em>Camera**</strong>）来控制</li><li>将绘制好的元素使用渲染器（<strong><em>\</em>Renderer**</strong>）进行渲染，最终呈现在浏览器上</li></ul><p>拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。</p><p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene" target="_blank" rel="noopener">THREE.js文档</a></p><a id="more"></a><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>场景允许你设置哪些对象被three.js渲染以及渲染在哪里。在场景中放置对象、灯光和相机。</p><p>很简单，直接创建一个Scene的实例即可。<code>_scene = new Scene()</code></p><h4 id="元素（包含光线）"><a href="#元素（包含光线）" class="headerlink" title="元素（包含光线）"></a>元素（包含光线）</h4><p>Three.js 为我们提供了非常多的Geometry，例如SphereGeometry（球体）、TetrahedronGeometry（四面体）、TorusGeometry（圆环体）等等。</p><p>在Three.js中，材质（Material）决定了几何图形具体是以什么形式展现的。它包括了一个几何体如何形状以外的其他属性，例如色彩、纹理、透明度等等，Material和Geometry是相辅相成的，必须结合使用。</p><h4 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h4><h5 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h5><p><img src="/posts/cb98d479/zbx.png" alt></p><p>我们可以在场景中添加一个坐标系，清楚的看到元素处于什么位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坐标系插件</span></span><br><span class="line"></span><br><span class="line">scene.add(<span class="keyword">new</span> THREE.AxisHelper(<span class="number">1000</span>));<span class="comment">//坐标系插件</span></span><br><span class="line"></span><br><span class="line">scene.add(<span class="keyword">new</span> THREE.AxisHelper(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h5 id="PerspectiveCamera（透视相机）"><a href="#PerspectiveCamera（透视相机）" class="headerlink" title="PerspectiveCamera（透视相机）"></a>PerspectiveCamera（透视相机）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_camera = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br></pre></td></tr></table></figure><p>最常用的摄像机类型，模拟人眼的视觉，近大远小（透视），如果是需要模拟现实，基本都是用这个相机。Fov表示的是视角，Fov越大，表示眼睛睁得越大，离得越远，看得更多。aspect代表水平方向和竖直方向可观测距离的比值。near、far分别对应相机可观测的最近和最远距离。</p><p><img src="/posts/cb98d479/camera.png" alt></p><h5 id="OrthographicCamera（正交投影相机）"><a href="#OrthographicCamera（正交投影相机）" class="headerlink" title="OrthographicCamera（正交投影相机）"></a><strong>OrthographicCamera（正交投影相机）</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_camera = <span class="keyword">new</span> OrthographicCamera(left, right, top, bottom, near, far);</span><br></pre></td></tr></table></figure><p>只有在这个矩形可视区域内才是可见的物体无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。对于渲染2D场景或者UI元素是非常有用的。</p><p><img src="/posts/cb98d479/camera1.png" alt></p><h5 id="position、lookAt"><a href="#position、lookAt" class="headerlink" title="position、lookAt"></a><strong>position、lookAt</strong></h5><p>position属性指定了相机所处的位置。lookAt函数指定相机观察的方向。接收的参数都是一个类型为Vector3的对象。</p><h4 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a><strong>渲染器</strong></h4><p>Three.js也为我们提供了几种不同的渲染器，主要看WebGL渲染器(WebGLRenderer)。WebGL渲染器使用WebGL来绘制场景，其够利用GPU硬件加速从而提高渲染性能。Three.js绘制的元素添加到浏览器上，这个过程需要一个载体，这个载体就是Canvas，你可以通过_renderer.domElement获取到这个Canvas，并将它给定到真实DOM中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_renderer = <span class="keyword">new</span> WebGLRenderer();</span><br><span class="line">_container = <span class="built_in">document</span>.getElementById(<span class="string">'conianer'</span>);</span><br><span class="line">_container.appendChild(_renderer.domElement);</span><br></pre></td></tr></table></figure><p>使用setSize函数设定你要渲染的范围，实际上它改变的就是上面Canvas的范围.通过render函数渲染上面指定的场景和相机.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line">_renderer.render(_scene, _camera);</span><br></pre></td></tr></table></figure><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong>requestAnimationFrame</strong></h4><p>要渲染的元素可能并未被加载完，你就执行了渲染，并且只执行了一次，这时需要requestAnimationFrame方法，让场景和相机进行实时渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">  _renderer.render(_scene, _camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>参考：<a href="https://ouyangresume.github.io/2019/08/20/VR全景功能/" target="_blank" rel="noopener">VR全景功能</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;Three-js基础知识&quot;&gt;&lt;a href=&quot;#Three-js基础知识&quot; class=&quot;headerlink&quot; title=&quot;Three.js基础知识&quot;&gt;&lt;/a&gt;Three.js基础知识&lt;/h3&gt;&lt;p&gt;使用Three.js绘制一个三维效果，至少需要以下几个步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;创建一个容纳三维空间的场景 (&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Sence**&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置&lt;/li&gt;&lt;li&gt;给定一个观察场景的位置，以及观察角度，我们用相机对象（&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Camera**&lt;/strong&gt;）来控制&lt;/li&gt;&lt;li&gt;将绘制好的元素使用渲染器（&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Renderer**&lt;/strong&gt;）进行渲染，最终呈现在浏览器上&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;THREE.js文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结0</title>
    <link href="https://blog.aigisss.com/posts/456b6ccc.html"/>
    <id>https://blog.aigisss.com/posts/456b6ccc.html</id>
    <published>2019-09-27T02:19:55.000Z</published>
    <updated>2019-10-05T14:52:13.941Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="学习Three-js之前要知道的"><a href="#学习Three-js之前要知道的" class="headerlink" title="学习Three.js之前要知道的"></a>学习Three.js之前要知道的</h2><p><img src="/posts/456b6ccc/QQ%E5%9B%BE%E7%89%8720190929102706.png" alt></p><a id="more"></a><h3 id="什么是-WebGL？"><a href="#什么是-WebGL？" class="headerlink" title="什么是 WebGL？"></a>什么是 WebGL？</h3><p>WebGL（Web 图形库）是一种 JavaScript API，用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形，而无需使用插件。WebGL 通过引入一个与 OpenGL ES 2.0 紧密相符合的 API，可以在 HTML5 <code>&lt;canvas&gt;</code> 元素中使用。WebGL 给我们提供了一系列的图形接口，能够让我们通过 JavaScript 去使用 GPU 来进行浏览器图形渲染的工具。</p><h3 id="什么是-Three-js？"><a href="#什么是-Three-js？" class="headerlink" title="什么是 Three.js？"></a>什么是 Three.js？</h3><p>Three.js 是一款 webGL 框架，由于其易用性被广泛应用。Three.js 在 WebGL 的 API 接口基础上，又进行的一层封装。Three.js 以简单、直观的方式封装了 3D 图形编程中常用的对象。Three.js 在开发中使用了很多图形引擎的高级技巧，极大地提高了性能。另外，由于内置了很多常用对象和极易上手的工具，Three.js 的功能也非常强大，Three.js 还是完全开源的。</p><h4 id="WEBGL-和-Three-js-的关系"><a href="#WEBGL-和-Three-js-的关系" class="headerlink" title="WEBGL 和 Three.js 的关系"></a>WEBGL 和 Three.js 的关系</h4><p>WebGL 原生 API 是一种非常低级的接口，而且还需要一些数学和图形学的相关技术。对于没有相关基础的人来说，入门真的很难，Three.js 将入门的门槛降低了一大截，对 WebGL 进行封装，简化我们创建三维动画场景的过程。</p><p>用最简单的一句话概括：WebGL 和 Three.js 的关系，相当于 JavaScript 和 jQuery 的关系。</p><h4 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h4><p>Three.js 作为 WebGL 框架中的佼佼者，由于它的易用性和扩展性，使得它能够满足大部分的开发需求，Three.js 的具体功能如下：</p><ol><li><strong>Three.js 掩盖了 3D 渲染的细节</strong>：Three.js 将 WebGL 原生 API 的细节抽象化，将 3D 场景拆解为网格、材质和光源（即它内置了图形编程常用的一些对象种类）。</li><li><strong>面向对象</strong>：开发者可以使用上层的 JavaScript 对象，而不是仅仅调用 JavaScript 函数。</li><li><strong>功能非常丰富</strong>：Three.js 除封装了 WebGL 原始 API 之外，Three.js 还包含了许多实用的内置对象，可以方便地应用于游戏开发、动画制作、幻灯片制作、髙分辨率模型和一些特殊的视觉效果制作。</li><li><strong>速度很快</strong>：Three.js 采用了 3D 图形最佳实践来保证在不失可用性的前提下，保持极高的性能。</li><li><strong>支持交互</strong>：WebGL 本身并不提供拾取（Picking）功能（即是否知道鼠标正处于某个物体上）。而 Three.js 则固化了拾取支持，这就使得你可以轻松为你的应用添加交互功能。</li><li><strong>包含数学库</strong>：Three.js 拥有一个强大易用的数学库，你可以在其中进行矩阵、投影和矢量运算。</li><li><strong>内置文件格式支持</strong>：你可以使用流行的 3D 建模软件导出文本格式的文件，然后使用 Three.js 加载，也可以使用 Three.js 自己的 JSON 格式或二进制格式。</li><li><strong>扩展性很强</strong>：为 Three.js 添加新的特性或进行自定义优化是很容易的事情。如果你需要某个特殊的数据结构，那么只需要封装到 Three.js 即可。</li><li><strong>支持HTML5 Canvas</strong>：Three.js 不但支持 WebGL，而且还支持使用 Canvas2D、Css3D 和 SVG 进行渲染。在未兼容 WebGL 的环境中可以回退到其它的解决方案。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>官网文档非常粗糙，对于新手极度不友好。</li><li>国内的相关资源匮乏。</li><li>Three.js 所有的资料都是以英文格式存在，对国内的朋友来说又提高了门槛。</li><li>Three.js 不是游戏引擎，一些游戏相关的功能没有封装在里面，如果需要相关的功能需要进行二次开发。</li></ul><h4 id="Three-js-与其他库的对比"><a href="#Three-js-与其他库的对比" class="headerlink" title="Three.js 与其他库的对比"></a>Three.js 与其他库的对比</h4><table><thead><tr><th>库名</th><th>描述</th><th>相比Three.js</th></tr></thead><tbody><tr><td>Babylon.js</td><td>是最好的 JavaScript 3D 游戏引擎，它能创建专业级三维游戏。主要以游戏开发和易用性为主</td><td><p>Three.js 比较全面，而 Babylon.js 专注于游戏方面。</p><p>Babylon.js 提供了对碰撞检测、场景重力、面向游戏的照相机，Three.js 本身不自带，需要依靠引入插件实现。</p><p>对于 WebGL 的封装，双方做得各有千秋，Three.js 浅一些，好处是易于扩展，易于向更底层学习；Babylon.js 深一些，好处是易用，但扩展难度大一些。</p><p>Three.js 的发展依靠社区推动，出来的比较早，发展比较成熟，Babylon.js 由微软公司在2013推出，文档和社区都比较健全，国内还不怎么火。</p></td></tr><tr><td>PlayCanvas</td><td>是一个基于 WebGL 游戏引擎的企业级开源 JavaScript 框架，它有许多的开发工具能帮你快速创建 3D 游戏</td><td>PlayCanvas 的优势在于它有云端的在线可视化编辑工具。 PlayCanvas 的扩展性不如 Three.js。 最主要是 PlayCanvas 不完全开源，还商业付费。</td></tr><tr><td>Cesium</td><td>是国外一个基于 JavaScript 编写的使用 WebGL 的地图引擎，支持 3D、2D、2.5D 形式的地图展示，可以自行绘制图形，高亮区域。</td><td>Cesium 是一个地图引擎，专注于 GIS，相关项目推荐使用它，其它项目还是算了。 至于库的扩展，其它的配套插件，以及周边的资源都不及Three.js。</td></tr></tbody></table><p>Three.js 在其库的扩展性，易用性以及功能方面有很好的优势。</p><h3 id="Three-js-master-源码目录结构"><a href="#Three-js-master-源码目录结构" class="headerlink" title="Three.js-master 源码目录结构"></a>Three.js-master 源码目录结构</h3><ul><li>build：里面含有 Three.js 构建出来的 JavaScript 文件，可以直接引入使用，并有压缩版；</li><li>docs：Three.js 的官方文档；</li><li>editor：Three.js 的一个网页版的模型编辑器；</li><li>examples：Three.js 的官方案例，如果全都学会，必将成为大神；</li><li>src：这里面放置的全是编译 Three.js 的源文件；</li><li>test：一些官方测试代码，我们一般用不到；</li><li>utils：一些相关插件；</li><li>其他：开发环境搭建、开发所需要的文件，如果不对 Three.js 进行二次开发，用不到。</li></ul><h3 id="使用Three-js"><a href="#使用Three-js" class="headerlink" title="使用Three.js"></a>使用Three.js</h3><h4 id="第一个案例"><a href="#第一个案例" class="headerlink" title="第一个案例"></a>第一个案例</h4><div class="note info">所有关于Threejs的代码均在https://github.com/Cenergy/webpack-threejs.git</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个Three.js案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">body &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas &#123;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 100%;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/three.js/108/three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">//声明一些全局变量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> renderer, camera, scene, geometry, material, mesh;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//初始化渲染器</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">initRenderer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">renderer = <span class="keyword">new</span> THREE.WebGLRenderer(); <span class="comment">//实例化渲染器</span></span></span><br><span class="line"><span class="javascript">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight); <span class="comment">//设置宽和高</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//添加到dom</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//初始化场景</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">initScene</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">scene = <span class="keyword">new</span> THREE.Scene(); <span class="comment">//实例化场景</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//初始化相机</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">initCamera</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span></span><br><span class="line">45,</span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span></span><br><span class="line">0.1,</span><br><span class="line">200</span><br><span class="line"><span class="javascript">); <span class="comment">//实例化相机</span></span></span><br><span class="line">camera.position.set(0, 0, 15);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//创建模型</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">initMesh</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//创建几何体</span></span></span><br><span class="line"><span class="javascript">material = <span class="keyword">new</span> THREE.MeshNormalMaterial(); <span class="comment">//创建材质</span></span></span><br><span class="line"><span class="javascript">mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//创建网格</span></span></span><br><span class="line"><span class="javascript">scene.add(mesh); <span class="comment">//将网格添加到场景</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//运行动画</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">requestAnimationFrame(animate); <span class="comment">//循环调用函数</span></span></span><br><span class="line"><span class="javascript">mesh.rotation.x += <span class="number">0.01</span>; <span class="comment">//每帧网格模型的沿x轴旋转0.01弧度</span></span></span><br><span class="line"><span class="javascript">mesh.rotation.y += <span class="number">0.02</span>; <span class="comment">//每帧网格模型的沿y轴旋转0.02弧度</span></span></span><br><span class="line"><span class="javascript">renderer.render(scene, camera); <span class="comment">//渲染界面</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//初始化函数，页面加载完成是调用</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">initRenderer();</span><br><span class="line">initScene();</span><br><span class="line">initCamera();</span><br><span class="line">initMesh();</span><br><span class="line">animate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/456b6ccc/first.gif" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;学习Three-js之前要知道的&quot;&gt;&lt;a href=&quot;#学习Three-js之前要知道的&quot; class=&quot;headerlink&quot; title=&quot;学习Three.js之前要知道的&quot;&gt;&lt;/a&gt;学习Three.js之前要知道的&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/456b6ccc/QQ%E5%9B%BE%E7%89%8720190929102706.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>webpack学习与总结</title>
    <link href="https://blog.aigisss.com/posts/6e7939e6.html"/>
    <id>https://blog.aigisss.com/posts/6e7939e6.html</id>
    <published>2019-09-24T12:37:14.000Z</published>
    <updated>2019-10-04T09:44:02.959Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><p><img src="/posts/6e7939e6/webpack.png" alt></p><a id="more"></a><h2 id="初识-Webpack"><a href="#初识-Webpack" class="headerlink" title="初识 Webpack"></a>初识 Webpack</h2><p>webpack 是模块打包工具，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。</p><p>历史上先后出现一系列构建工具，它们各有其优缺点。由于前端工程师很熟悉 JavaScript ，Node.js 又可以胜任所有构建需求，所以大多数构建工具都是用 Node.js 开发的。下面来一一介绍它们。</p><h3 id="Npm-Script"><a href="#Npm-Script" class="headerlink" title="Npm Script"></a>Npm Script</h3><p><a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="noopener">Npm Script</a> 是一个任务执行者。Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 <code>package.json</code> 文件里面使用 <code>scripts</code> 字段定义任务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"node dev.js"</span>,</span><br><span class="line">    <span class="attr">"pub"</span>: <span class="string">"node build.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的 <code>scripts</code> 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 <code>dev</code> 和 <code>pub</code>。 其底层实现原理是通过调用 Shell 去运行脚本命令，例如执行 <code>npm run pub</code> 命令等同于执行命令 <code>node build.js</code>。</p><p>Npm Script的优点是内置，无须安装其他依赖。其缺点是功能太简单，虽然提供了 <code>pre</code> 和 <code>post</code> 两个钩子，但不能方便地管理多个任务之间的依赖。</p><h3 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h3><p><a href="https://gruntjs.com/" target="_blank" rel="noopener">Grunt</a> 和 Npm Script 类似，也是一个任务执行者。Grunt 有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 <code>Gruntfile.js</code> 里，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有插件的配置信息</span></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="comment">// uglify 插件的配置信息</span></span><br><span class="line">    uglify: &#123;</span><br><span class="line">      app_task: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          <span class="string">'build/app.min.js'</span>: [<span class="string">'lib/index.js'</span>, <span class="string">'lib/test.js'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// watch 插件的配置信息</span></span><br><span class="line">    watch: &#123;</span><br><span class="line">      another: &#123;</span><br><span class="line">          files: [<span class="string">'lib/*.js'</span>],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉 grunt 我们将使用这些插件</span></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务</span></span><br><span class="line">  grunt.registerTask(<span class="string">'dev'</span>, [<span class="string">'uglify'</span>,<span class="string">'watch'</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在项目根目录下执行命令 <code>grunt dev</code> 就会启动 JavaScript 文件压缩和自动刷新功能。</p><p>Grunt的优点是：</p><ul><li>灵活，它只负责执行你定义的任务；</li><li>大量的可复用插件封装好了常见的构建任务。</li></ul><p>Grunt的缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。</p><p>Grunt 相当于进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><a href="http://gulpjs.com/" target="_blank" rel="noopener">Gulp</a> 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5个方法就可以胜任几乎所有构建场景：</p><ul><li>通过 <code>gulp.task</code> 注册一个任务；</li><li>通过 <code>gulp.run</code> 执行任务；</li><li>通过 <code>gulp.watch</code> 监听文件变化；</li><li>通过 <code>gulp.src</code> 读取文件；</li><li>通过 <code>gulp.dest</code> 写文件。</li></ul><p>Gulp 的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Gulp</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>); </span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">var</span> jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>);</span><br><span class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 SCSS 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件通过管道喂给插件</span></span><br><span class="line">  gulp.src(<span class="string">'./scss/*.scss'</span>)</span><br><span class="line">    <span class="comment">// SCSS 插件把 scss 文件编译成 CSS 文件</span></span><br><span class="line">    .pipe(sass())</span><br><span class="line">    <span class="comment">// 输出文件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并压缩 JS</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.src(<span class="string">'./js/*.js'</span>)</span><br><span class="line">    .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 当 scss 文件被编辑时执行 SCSS 任务</span></span><br><span class="line">  gulp.watch(<span class="string">'./scss/*.scss'</span>, [<span class="string">'sass'</span>]);</span><br><span class="line">  gulp.watch(<span class="string">'./js/*.js'</span>, [<span class="string">'scripts'</span>]);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。</p><p>可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。</p><p>其官网的首页图很形象的画出了 Webpack 是什么，如下：</p><p><img src="/posts/6e7939e6/1569474242621.png" alt="1569474242621"></p><p>一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。</p><p>Webpack 具有很大的灵活性，能配置如何处理文件，大致使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块</span></span><br><span class="line">  entry: <span class="string">'./app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 </span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webpack的优点是：</p><ul><li>专注于处理模块化的项目，能做到开箱即用一步到位；</li><li>通过 Plugin 扩展，完整好用又不失灵活；</li><li>使用场景不仅限于 Web 开发；</li><li>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</li><li>良好的开发体验。</li></ul><p>Webpack的缺点是只能用于采用模块化开发的项目。</p><h3 id="为什么选择-Webpack"><a href="#为什么选择-Webpack" class="headerlink" title="为什么选择 Webpack"></a>为什么选择 Webpack</h3><p>上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物，侧面反映出 Web 开发的发展趋势如下：</p><ol><li>在 Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入，用于简化流程；</li><li>在 Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想的出现是为了简化文件转换的流程，例如将 ES6 转换成 ES5。</li><li>在 Webpack 时代由于单页应用的流行，一个网页的功能和实现代码变得庞大，Web 开发向模块化改进。</li></ol><p>这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务，也可以相互搭配起来弥补各自的不足。 在了解这些常见的构建工具后，你需要根据自己的需求去判断应该如何选择和搭配它们才能更好地完成自己的需求。</p><p>经过多年的发展， Webpack 已经成为构建工具中的首选，这是有原因的：</p><ul><li>大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；</li><li>Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；</li><li>Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。</li></ul><h2 id="使用Webpack"><a href="#使用Webpack" class="headerlink" title="使用Webpack"></a>使用Webpack</h2><h3 id="安装-Webpack-到本项目"><a href="#安装-Webpack-到本项目" class="headerlink" title="安装 Webpack 到本项目"></a>安装 Webpack 到本项目</h3><p>在开始给项目加入构建前， 在安装 Webpack 前请确保你的系统安装了5.0.0及以上版本的 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>。你还需要先新建一个 Web 项目，进入项目根目录执行 <code>npm init</code> 来初始化最简单的采用了模块化开发的项目；</p><p>要安装 Webpack 到本项目，可按照你的需要选择以下任意命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies</span></span><br><span class="line"><span class="comment"># 安装最新稳定版</span></span><br><span class="line">npm i -D webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">npm i -D webpack@&lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最新体验版本</span></span><br><span class="line">npm i -D webpack@beta</span><br></pre></td></tr></table></figure><p>安装完后你可以通过这些途径运行安装到本项目的 Webpack：</p><ul><li><p>在项目根目录下对应的命令行里通过 <code>node_modules/.bin/webpack</code> 运行 Webpack 可执行文件。</p></li><li><p>在 <a href="http://webpack.wuhaolin.cn/1入门/常见的构建工具及对比/npm_script.md" target="_blank" rel="noopener">Npm Script</a> 里定义的任务会优先使用本项目下的 Webpack，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "webpack --config webpack.config.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>npx webpack</code></p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npx</span><br></pre></td></tr></table></figure><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 webpack 而且全局没有安装 webpack。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D webpack</span><br></pre></td></tr></table></figure><p>一般来说，调用 webpack，只能在项目脚本和 package.json 的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener"><code>scripts</code></a>字段里面， 如果想在命令行下调用，必须像下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line"><span class="built_in">cd</span> node_modules\.bin</span><br><span class="line">webpack --version   <span class="comment"># 输出 4.41.0</span></span><br></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line">npx webpack --version</span><br></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx create-react-app my-react-app</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码运行时，npx 将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载<code>create-react-app</code>。</p><p>下载全局模块时，npx 允许指定版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码指定使用 3.1.0 版本的<code>uglify-js</code>压缩脚本。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装<code>http-server</code>模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ npx http-server</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">npx 使用教程</a></p></blockquote></li></ul><h3 id="安装-Webpack-到全局"><a href="#安装-Webpack-到全局" class="headerlink" title="安装 Webpack 到全局"></a>安装 Webpack 到全局</h3><p>安装到全局后你可以在任何地方共用一个 Webpack 可执行文件，而不用各个项目重复安装，安装方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g webpack</span><br></pre></td></tr></table></figure><div class="note danger">虽然介绍了以上两种安装方式，但是我们推荐安装到本项目，原因是可防止不同项目依赖不同版本的 Webpack 而导致冲突。</div>### 使用 Webpack<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>Webpack 在执行构建时默认会从项目根目录下的 <code>webpack.config.js</code> 文件读取配置，所以你还需要新建它，其内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JavaScript 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把所有依赖的模块合并输出到一个 bundle.js 文件</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 Webpack 构建运行在 Node.js 环境下，所以该文件最后需要通过 CommonJS 规范导出一个描述如何构建的 <code>Object</code> 对象。</p><h4 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h4><p>Webpack 把一切文件看作模块，CSS 文件也不例外，Webpack 不原生支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制。Webpack的配置修改使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JavaScript 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 把所有依赖的模块合并输出到一个 bundle.js 文件</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用正则去匹配要用该 loader 转换的 CSS 文件</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader?minimize'</span>],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Loader 可以看作具有文件转换功能的翻译员，配置里的 <code>module.rules</code> 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 <code>.css</code> 结尾的文件时先使用 <code>css-loader</code> 读取 CSS 文件，再交给 <code>style-loader</code> 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：</p><ul><li><code>use</code> 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；</li><li>每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 <code>css-loader?minimize</code> 中的 <code>minimize</code> 告诉 <code>css-loader</code> 要开启 CSS 压缩。</li></ul><p>Webpack 构建前要先安装新引入的 Loader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D style-loader css-loader</span><br></pre></td></tr></table></figure><p>给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入，以上的 Loader 配置可以修改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  <span class="string">'style-loader'</span>, </span><br><span class="line">  &#123;</span><br><span class="line">    loader:<span class="string">'css-loader'</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      minimize:<span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>除了在 <code>webpack.config.js</code> 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 <code>main.js</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'style-loader!css-loader?minimize!./main.css'</span>);</span><br></pre></td></tr></table></figure><p>这样就能指定对 <code>./main.css</code> 这个文件先采用 css-loader 再采用 style-loader 转换。</p><h4 id="使用-Plugin"><a href="#使用-Plugin" class="headerlink" title="使用 Plugin"></a>使用 Plugin</h4><p>plugin 可以在 webpack 运行到某一时刻的时候，帮你做一些事情。</p><p>htmlWepackPluginnn 会在打包结束后，自动生成一个 html 文件，并把打包的生成的 js 自动引入到这个 html 文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>); <span class="comment">//通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>); <span class="comment">//访问内置的插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: <span class="string">"file-loader"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">"./src/index.html"</span> &#125;)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h4 id="使用-DevServer"><a href="#使用-DevServer" class="headerlink" title="使用 DevServer"></a>使用 DevServer</h4><p>DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。</p><p>首先需要安装 DevServer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>安装成功后执行 <code>webpack-dev-server</code> 命令， DevServer 就启动了，这时你会看到控制台有一串日志输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project is running at http://localhost:8080/</span><br><span class="line">webpack output is served from /</span><br></pre></td></tr></table></figure><p>这意味着 DevServer 启动的 HTTP 服务器监听在 <code>http://localhost:8080/</code> ，DevServer 启动后会一直驻留在后台保持运行，访问这个网址你就能获取项目根目录下的 <code>index.html</code>。 用浏览器打开这个地址你会发现页面空白错误原因是 <code>./dist/bundle.js</code> 加载404了。 同时你会发现并没有文件输出到 <code>dist</code> 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。 由于 DevServer 不会理会 <code>webpack.config.js</code> 里配置的 <code>output.path</code> 属性，所以要获取 <code>bundle.js</code>的正确 URL 是 <code>http://localhost:8080/bundle.js</code>，对应的 <code>index.html</code> 应该修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入 DevServer 输出的 JavaScript 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Webpack 可以在启动 Webpack 时通过 <code>webpack --watch</code> 来开启监听模式，实时预览。Webpack 支持生成 Source Map，只需在启动时带上 <code>--devtool source-map</code> 参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。</p><p>DevServer 还有一种被称作模块热替换的刷新技术。 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上 <code>--hot</code> 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config=<span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> complier=wepack(config)</span><br><span class="line"><span class="comment">// 在node中使用webpack的方法。</span></span><br></pre></td></tr></table></figure><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>Webpack 有以下几个核心概念。</p><ul><li><strong>Entry</strong>：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</li><li><strong>Module</strong>：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li><strong>Chunk</strong>：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li><strong>Loader</strong>：模块转换器，用于把模块原内容按照需求转换成新内容。</li><li><strong>Plugin</strong>：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li><li><strong>Output</strong>：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</li></ul><p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。</p><h2 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>entry 是配置模块的入口，可抽象成输入， Webpack 执行构建的第 步将从入 口开始，搜寻及递归解析出所有入口依赖的模块。entry 配置是必填的，若不填则将导致 Webpack 报错、退出。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>Webpack 在寻找相对路径的文件时会以 context 为根目录， context 默认为执行启动<br>Webpack 时所在的当前工作目录。如果想改变 context 的默认配置，则可以在配置文件里这<br>样设置它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">context: path.resolve(__dirname,<span class="string">'app'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>就会拷贝到打包文件夹内</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./src/index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"file-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"[name].[ext]"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>会变成 base64，在 js 文件中直接加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./src/index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"url-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"[name].[ext]"</span>,</span><br><span class="line">            outputPath: <span class="string">"images/"</span>,</span><br><span class="line">            limit: <span class="number">1024</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader style-loader"></a>css-loader style-loader</h3><h2 id="Webpack-进阶"><a href="#Webpack-进阶" class="headerlink" title="Webpack 进阶"></a>Webpack 进阶</h2><h2 id="Webpack-配置及案例"><a href="#Webpack-配置及案例" class="headerlink" title="Webpack 配置及案例"></a>Webpack 配置及案例</h2><h2 id="Webpack-原理及脚手架"><a href="#Webpack-原理及脚手架" class="headerlink" title="Webpack 原理及脚手架"></a>Webpack 原理及脚手架</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/6e7939e6/webpack.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="webpack" scheme="https://blog.aigisss.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程总结</title>
    <link href="https://blog.aigisss.com/posts/9364fbab.html"/>
    <id>https://blog.aigisss.com/posts/9364fbab.html</id>
    <published>2019-09-19T04:35:34.000Z</published>
    <updated>2019-09-25T15:23:47.304Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="What-is-Object-oriented-Programming"><a href="#What-is-Object-oriented-Programming" class="headerlink" title="What is Object-oriented Programming"></a>What is Object-oriented Programming</h2><p><img src="/posts/9364fbab/1569242664504.png" alt="1569242664504"></p><a id="more"></a><div class="note info">OOP是一种编程范例，或者编程风格，这是围绕对象而不是函数</div>面向对象编程中的四个核心概念<p><code>Encapsulation</code>—封装 <code>Abstraction</code>—抽象 <code>Inheritance</code>—继承 <code>Polymorphism</code>—多态</p><p>区别与面向过程编程</p><p><img src="/posts/9364fbab/1568869135169.png" alt="1568869135169"></p><p><img src="/posts/9364fbab/1568868905016.png" alt="1568868905016"></p><div class="note danger">改变了其中一个函数，然后其他几个函数可能就奔溃了，这就是我们说的意大利面条代码。 函数之间深层次的关联变成了各种问题的来源，OOP就应运而生。</div><p><img src="/posts/9364fbab/1568869159417.png" alt="1568869159417"></p><p>OOP 就一组相关的变量和函数组成合成一个单元，我们称之为对象(object)。把里面的函数称为方法，里面的变量称之为属性。</p><p><img src="/posts/9364fbab/1568869302595.png" alt="1568869302595"></p><div class="note info">最好的函数是那些没有参数的函数，参数个数越少，使用和维护就越简单。这就是封装！</div>![1568869634914](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568869634914.png)<p><img src="/posts/9364fbab/1568869889043.png" alt="1568869889043"></p><div class="note info">多态意味着多种形态</div>![1568873343511](JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/1568873343511.png)<p><img src="/posts/9364fbab/1568873363029.png" alt="1568873363029"></p><div class="note success">使用封装重新组合的相关的变量和函数，这样可以减少复杂性，可以在程序的不同部分重用这些对象 或者在不同程序中，通过抽象，隐藏细节和复杂性，只显示必要性，这种技术降低了复杂性，也隔离了代码更改的影响。 继承让我们消除多余的代码 多态性可以避免写出复杂丑陋的选择性代码</div><p><img src="/posts/9364fbab/1568873756718.png" alt="1568873756718"></p><h2 id="原型与原型继承"><a href="#原型与原型继承" class="headerlink" title="原型与原型继承"></a>原型与原型继承</h2><p>原型<code>Prototypes</code> 和 原型继承<code>Prototyical Inheritance</code></p><p>JavaScript 中的类并不同于 Java 或者 c#中的类，因为 Javascript 是动态语言，所以类的本质上是更像是为了配合原型和原型继承所采取的必要的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字面量创建对象</span></span><br><span class="line"><span class="keyword">const</span> circle = &#123;&#125;;</span><br><span class="line"><span class="comment">//一个Javascript的对象实际上是一组键值对的集合</span></span><br><span class="line"><span class="comment">//使用字面量语法来创建多个对象是有问题的，那就是对象的行为性，就像人一样可以做很多事就叫做行为性。</span></span><br><span class="line"><span class="comment">//解决方法就是用工厂函数（factory）或者构造函数（constructor）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    radius,</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle2 = createCircle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = raius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle3 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//当我们使用new操作符调用一个函数时，3件事发生了</span></span><br><span class="line"><span class="comment">//首先new操作符创建了一个空对象，然后设置this指向这个对象，最后返回这个对象</span></span><br></pre></td></tr></table></figure><p>补充：</p><p><a href="https://www.baidu.com/s?wd=字面量&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">字面量</a>是变量的字符串表示形式。它不是一种值，而是一种变量记法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">//1是字面量</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">"hello world"</span>; <span class="comment">//hello world是字面量</span></span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//[1,2,3]是字面量</span></span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;; <span class="comment">//&#123;"foo":"bar"&#125;是字面量</span></span><br></pre></td></tr></table></figure><p>每个对象都有构造函数属性</p><p>这个属性引用了用来创建这个对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(); <span class="comment">// ''," ",``</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(); <span class="comment">// true ,false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(); <span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/9364fbab/1568897883740.png" alt="1568897883740"></p><div class="note info"><p>值类型复制值</p><p>对象或者引用类型复制他们的引用</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    number++;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number) <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> object=&#123;<span class="attr">value</span>:<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">object.value++;</span><br><span class="line">&#125;</span><br><span class="line">increase(object);</span><br><span class="line"><span class="built_in">console</span>.log(object) <span class="comment">//&#123;value:11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>不知道要访问的对象名称属性，是在运行时产生的，可以使用方括号的语法,或者属性名不符合命名规则时。</p><p>抽象意味着我们应该隐藏细节和复杂部分，只显示或者暴露必要的部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.defaultLocaltion=&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>&#125; <span class="comment">// ====&gt; let defaultLocaltion=&#123;x:0,y:1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'defaultLocaltion'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultLocaltion</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        defaultLocaltion=value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div class="note info">Javascript 中没有类，只有对象，那只有对象的时候如何引入继承？答案是原型。 原型可以理解为一个对象的父母，原型就是一般的对象。</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">writable: <span class="literal">false</span>,</span><br><span class="line">enumerable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: 'hello' &#125;</span></span><br></pre></td></tr></table></figure><p>获得对象原型的方法是调用 Object 对象的 getPrototypeOf 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">Circle.prototype; <span class="comment">//这是构造函数创建的对象的父母真身</span></span><br><span class="line">circle.__proto__ === Circle.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object.keys 只返回实例的成员</p><p>for-in 循环返回所有的成员，对象实例本身的和它的原型的</p><p><img src="/posts/9364fbab/1568956155416.png" alt="1568956155416"></p><p><img src="/posts/9364fbab/1568982071111.png" alt="1568982071111"></p><p>在 Javascript 中，有个函数可以从给定的原型创建对象，就是 Object.create(第一个参数是用作创建的原型)</p><p>Javascript 里每个对象都有一个构造函数属性，能返回用以创建这个对象的构造函数</p><p>避免创建层级式继承关系，因为这十分脆弱。如果要用继承特性，最好维持在一级。好的组合胜过继承。</p><p><img src="/posts/9364fbab/1568984473440.png" alt="1568984473440"></p><p><img src="/posts/9364fbab/1568984534425.png" alt="1568984534425"></p><div class="note info">Object.assign()可以用这个方法从一个对象拷贝所有成员到另外一个对象</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> canEat = &#123;</span><br><span class="line">      eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eating"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> canWalk = &#123;</span><br><span class="line">      walk: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eating"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> canSwin = &#123;</span><br><span class="line">      swin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"swining"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//   const person = Object.assign(&#123;&#125;, canEat, canWalk);</span></span><br><span class="line"><span class="comment">// 空对象实际上变成了2个对象的组合</span></span><br><span class="line">    <span class="comment">//   console.log(person);</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">target, ...sources</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(target.prototype, ...sources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   function Person() &#123;&#125;</span></span><br><span class="line">    <span class="comment">//   Object.assign(Person.prototype, canEat, canWalk);</span></span><br><span class="line">    <span class="comment">//   console.log(new Person());</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    mixins(Dog, canEat, canWalk);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> Dog());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">GoldFish</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    mixins(GoldFish, canEat, canSwin);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> GoldFish());</span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>函数声明 <code>funciton sayHello(){}</code> 结尾不需要加分号，函数声明是置顶的。</p><p>函数表达式<code>const sayGoodbye=function(){}</code> 结尾需要加分号，不会被置顶。</p><p>不同于函数，类声明和类表达式都不会被置顶</p><p>实例方法和静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Instance Method</span></span><br><span class="line">  draw() &#123;&#125;</span><br><span class="line">  <span class="comment">// Static Mthod</span></span><br><span class="line">  <span class="keyword">static</span> parse(str) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; radius &#125; = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = Circle.parse(<span class="string">'&#123;"radius":1&#125;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Go: circle"</span>, circle); <span class="comment">// Go: circle Circle &#123; radius: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>所以我们用静态方法的方式创建不属于具体实例的工具函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// Method call</span></span><br><span class="line">c.draw(); <span class="comment">// Circle &#123; radius: 2 &#125;</span></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line"><span class="comment">// Function call</span></span><br><span class="line">draw(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ES6 私有</p><p>第一种是用在命名的时候加下划线</p><p>第二种是使用 Symbol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _draw = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// Symbol() 是一个函数，能创建一个Symbol，这个不是构造函数，不能在前面加new修饰符，这样会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>[_radius] = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  [_draw]() &#123;</span><br><span class="line">    <span class="comment">// 计算生成属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> key = <span class="built_in">Object</span>.getOwnPropertySymbols(c)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c[key]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>第三种是使用 WeakMap</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _move = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">    _move.set(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 箭头函数将从调用它的构造器继承过来，在这个构造器里。this是circle对象实例的引用。</span></span><br><span class="line">      <span class="comment">// 当我们在构造器函数里使用箭头函数时，this不会重新绑定，也不会重设，直接从构造器继承</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"moving"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    _move.get(<span class="keyword">this</span>)();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"drawing..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line">c.draw();</span><br></pre></td></tr></table></figure><p>getter&amp;&amp;setter</p><p>方法重写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"moving...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">super</span>.move();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"circle move"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p><img src="/posts/9364fbab/1569201901993.png" alt="1569201901993"></p><p>AMD，也就是异步模块定义，主要是在浏览器程序中使用。</p><p><img src="/posts/9364fbab/1569202170920.png" alt="1569202170920"></p><p><img src="/posts/9364fbab/1569202287766.png" alt="1569202287766"></p><p>CommonJS</p><blockquote><p>class Circle{</p><p>}</p><p>module.exports.Circle=Circle</p><p>只需要引入一个模块时，可以简化代码<code>module.exports=Circle</code></p><p>引入时，使用 require 函数。</p><p>所以时 CommonJS 定义了 require 函数和 module 函数，这是 CommonJS 当中的语法。</p></blockquote><p>ES6</p><blockquote><p>export &amp;&amp; import</p><script type="module" src="../"></script></blockquote><p>在模块化之前，要记住一个首要原则，高度关联的东西应该放在一起。就好比在厨房放置了杯子盘子勺子等餐具，不应该把衣服存放在厨房，这就是高度关联。这就是编程中说的 Cohesion(内聚)。</p><p><img src="/posts/9364fbab/1569203914069.png" alt="1569203914069"></p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>npm i -g webpack-cli</li><li>webpack-cli init</li><li>npm init –yes</li></ul><p><a href="https://www.bilibili.com/video/av35179218/?p=1" target="_blank" rel="noopener">完结</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;What-is-Object-oriented-Programming&quot;&gt;&lt;a href=&quot;#What-is-Object-oriented-Programming&quot; class=&quot;headerlink&quot; title=&quot;What is Object-oriented Programming&quot;&gt;&lt;/a&gt;What is Object-oriented Programming&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/9364fbab/1569242664504.png&quot; alt=&quot;1569242664504&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://blog.aigisss.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>mapboxgl实现marker的聚类</title>
    <link href="https://blog.aigisss.com/posts/a2d9d205.html"/>
    <id>https://blog.aigisss.com/posts/a2d9d205.html</id>
    <published>2019-09-17T05:08:43.000Z</published>
    <updated>2019-09-17T14:24:39.049Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><p><img src="/posts/a2d9d205/1568697066499.png" alt="1568697066499"></p><p><img src="/posts/a2d9d205/1568697307582.png" alt="1568697307582"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/a2d9d205/1568697066499.png&quot; alt=&quot;1568697066499&quot;&gt;&lt;/p&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="mapbox" scheme="https://blog.aigisss.com/tags/mapbox/"/>
    
  </entry>
  
  <entry>
    <title>vue学习与总结</title>
    <link href="https://blog.aigisss.com/posts/3d0c447.html"/>
    <id>https://blog.aigisss.com/posts/3d0c447.html</id>
    <published>2019-09-16T01:29:36.000Z</published>
    <updated>2019-09-25T14:02:20.474Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><a id="more"></a><ul><li><p>v-cloak</p></li><li><p>v-text</p></li><li><p>v-html</p></li><li><p>v-bind(缩写:)</p></li><li><p>v-on(缩写@)</p></li><li><p>v-model 只能用于表单元素</p></li><li><p>v-for</p></li><li><p>v-if</p></li><li><p>v-show</p><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换，v-show 较好，如果运行时条件不太可能改变 v-if 较好</p></blockquote></li></ul><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ul><li>.stop 阻止冒泡</li><li>.prevent 阻止默认事件</li><li>.capture 添加事件侦听器时使用事件捕获模式</li><li>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</li><li>.once 事件只触发一次</li></ul><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li>数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>数组中使用三元表达式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>数组中嵌套对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>直接使用对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</li></ol><ul><li>在data上定义样式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</li></ol><ul><li>在data上定义样式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;,</span><br><span class="line">        h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class="line"></span><br><span class="line">    dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错</span><br><span class="line"></span><br><span class="line">      var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">      // 获取年月日</span><br><span class="line"></span><br><span class="line">      var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">      var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">      var d = dt.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">      // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">      if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 获取时分秒</span><br><span class="line"></span><br><span class="line">        var hh = dt.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">        var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">        var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局过滤器</span><br><span class="line"></span><br><span class="line">Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123;</span><br><span class="line"></span><br><span class="line">  var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">  // 获取年月日</span><br><span class="line"></span><br><span class="line">  var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">  var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">  var d = dt.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">  // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">  if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 获取时分秒</span><br><span class="line"></span><br><span class="line">    var hh = dt.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">    var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">    var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用自定义的按键修饰符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><ul><li><p>使用 Vue.directive()定义全局的指令，比如 v-focus</p></li><li><p>其中 参数 1：指令的名称，定义时不需要加 v-的前缀</p></li><li><p>使用的时候必须在指令名称前面加上 v-前缀来调用</p></li><li><p>参数 2：是一个对象，这个对象上有一些指令相关的函数，这些函数可以在特定的阶段执行相关的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.dirctive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">bind:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line"><span class="comment">//每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次</span></span><br><span class="line">    <span class="comment">//每个函数中的第一个参数永远是el表示被绑定的指令的那个元素，是原生的js对象</span></span><br><span class="line">    <span class="comment">//每当指令绑定到元素上的时候会立即执行这个bind函数，只执行一次</span></span><br><span class="line">    <span class="comment">// 和样式相关的操作，一般都可以在bind执行</span></span><br><span class="line">&#125;,</span><br><span class="line">    inserted(el)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">      <span class="comment">// 和js行为相关的操作，最好在inserted中执行，防止js行为不生效</span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated(el)&#123;</span><br><span class="line">       <span class="comment">//当Vnode更新时，会执行updated，可能会触发多次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>私有指令的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dirctives:&#123;</span><br><span class="line">     <span class="comment">//自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span></span><br><span class="line"> <span class="string">'fontsize'</span>:<span class="function"><span class="keyword">function</span> (<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">         el.style.fontSize=binding.value</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义指令的使用方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现筛选的方式显示过滤-排序结果："><a href="#实现筛选的方式显示过滤-排序结果：" class="headerlink" title="实现筛选的方式显示过滤-排序结果："></a>实现筛选的方式显示过滤-排序结果：</h3><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr&gt; 输入筛选名称：</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line"></span><br><span class="line">      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">        &lt;td&gt;</span><br><span class="line"></span><br><span class="line">          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/tbody&gt;</span><br></pre></td></tr></table></figure><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">search(name) &#123;</span><br><span class="line"></span><br><span class="line">  return this.list.filter(x =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return x.name.indexOf(name) != -1;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP的实现原理"><a href="#JSONP的实现原理" class="headerlink" title="JSONP的实现原理"></a>JSONP的实现原理</h2><ul><li><p>由于浏览器安全限制，不允许AXAJ访问协议不同、域名不同、端口号不同——不符合同源策略的。</p></li><li><p>可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址。因为script标签不存在跨域限制，这种数据获取方式称之为JSONP</p></li><li><p>具体实现过程</p><ul><li><p>先在客户端定义一个回调方法，预定义对数据的操作；</p></li><li><p>再把这个回调方法的名称通过URL传参的形式提交到服务器的数据接口；</p></li><li><p>服务器数据接口组织好要发送给客户端的数据，再拿客户端传递过来的回调方法名称拼接出一个调用这个方法的字符串，发送给客户端解析执行；</p></li><li><p>客户端拿到服务器的返回的字符串之后，当作script脚本执行。</p></li><li><p>Node.js 实现一个JSONP的请求例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">    // 导入解析 URL 地址的核心模块</span><br><span class="line">    const urlModule = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">    const server = http.createServer();</span><br><span class="line">    // 监听 服务器的 request 请求事件，处理每个请求</span><br><span class="line">    server.on(&apos;request&apos;, (req, res) =&gt; &#123;</span><br><span class="line">      const url = req.url;</span><br><span class="line"></span><br><span class="line">      // 解析客户端请求的URL地址</span><br><span class="line">      var info = urlModule.parse(url, true);</span><br><span class="line"></span><br><span class="line">      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据</span><br><span class="line">      if (info.pathname === &apos;/getjsonp&apos;) &#123;</span><br><span class="line">        // 获取客户端指定的回调函数的名称</span><br><span class="line">        var cbName = info.query.callback;</span><br><span class="line">        // 手动拼接要返回给客户端的数据对象</span><br><span class="line">        var data = &#123;</span><br><span class="line">          name: &apos;zs&apos;,</span><br><span class="line">          age: 22,</span><br><span class="line">          gender: &apos;男&apos;,</span><br><span class="line">          hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：</span><br><span class="line">        var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`;</span><br><span class="line">        // 将拼接好的方法的调用，返回给客户端去解析执行</span><br><span class="line">        res.end(result);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.end(&apos;404&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.listen(3000, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;server running at =http://127.0.0.1:3000&apos;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><ol><li>HTML结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt;</span><br><span class="line">    &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span><br><span class="line">    &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">      &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>VM 实例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Vue 实例，得到 ViewModel</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isshow: false</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      this.isshow = !this.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>定义两组类样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 定义进入和离开时候的过渡状态 */</span><br><span class="line">    .fade-enter-active,</span><br><span class="line">    .fade-leave-active &#123;</span><br><span class="line">      transition: all 0.2s ease;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span><br><span class="line">    .fade-enter,</span><br><span class="line">    .fade-leave-to &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      transform: translateX(100px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h3><ol><li>导入动画类库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义 transition 及属性：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">enter-active-class=&quot;fadeInRight&quot;</span><br><span class="line">    leave-active-class=&quot;fadeOutRight&quot;</span><br><span class="line">    :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol><li>定义 transition 组件以及三个钩子函数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt;</span><br><span class="line">    &lt;transition</span><br><span class="line">    @before-enter=&quot;beforeEnter&quot;</span><br><span class="line">    @enter=&quot;enter&quot;</span><br><span class="line">    @after-enter=&quot;afterEnter&quot;&gt;</span><br><span class="line">      &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义三个 methods 钩子方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; // 动画进入之前的回调</span><br><span class="line">          el.style.transform = &apos;translateX(500px)&apos;;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; // 动画进入完成时候的回调</span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = &apos;translateX(0px)&apos;;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; // 动画进入完成之后的回调</span><br><span class="line">          this.isshow = !this.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义动画过渡时长和样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.show&#123;</span><br><span class="line">      transition: all 0.4s ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h3><ol><li>定义过渡样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .list-enter,</span><br><span class="line">    .list-leave-to &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      transform: translateY(10px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .list-enter-active,</span><br><span class="line">    .list-leave-active &#123;</span><br><span class="line">      transition: all 0.3s ease;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义 VM中的结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Vue 实例，得到 ViewModel</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    txt: &apos;&apos;,</span><br><span class="line">    list: [1, 2, 3, 4]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.list.push(this.txt);</span><br><span class="line">      this.txt = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.v-move&#123;</span><br><span class="line">  transition: all 0.8s ease;</span><br><span class="line">&#125;</span><br><span class="line">.v-leave-active&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；</li></ul><h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><ol><li>使用 Vue.extend 配合 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var login = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.component(&apos;login&apos;, login);</span><br></pre></td></tr></table></figure><ol start="2"><li>直接使用 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;register&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>将模板字符串，定义到script标签种：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同时，需要使用 Vue.component 来定义组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;, &#123;</span><br><span class="line">      template: &apos;#tmpl&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol><li>在组件中，<code>data</code>需要被定义为一个方法，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;, &#123;</span><br><span class="line">      template: &apos;#tmpl&apos;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &apos;大家好！&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(&apos;点击了登录按钮&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li></ol><h2 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h2><p>vue 提供了 component，来展示对应的名称组件<br>component 是一个占位符,:is 属性，可以用来指定展示的组件的名称</p><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;这是父组件中的消息&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">          props: [&apos;finfo&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func=<span class="string">"getMsg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type=<span class="string">"x-template"</span> id=<span class="string">"son"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"向父组件传值"</span> @click=<span class="string">"sendMsg"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 子组件的定义方式</span></span><br><span class="line"><span class="regexp">    Vue.component('son', &#123;</span></span><br><span class="line"><span class="regexp">      template: '#son', /</span><span class="regexp">/ 组件模板Id</span></span><br><span class="line"><span class="regexp">      methods: &#123;</span></span><br><span class="line"><span class="regexp">        sendMsg() &#123; /</span><span class="regexp">/ 按钮的点击事件</span></span><br><span class="line"><span class="regexp">          this.$emit('func', 'OK'); /</span><span class="regexp">/ 调用父组件传递过来的方法，同时把数据传递出去</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="regexp">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">      el: '#app',</span></span><br><span class="line"><span class="regexp">      data: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">      methods: &#123;</span></span><br><span class="line"><span class="regexp">        getMsg(val)&#123; /</span><span class="regexp">/ 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span></span><br><span class="line"><span class="regexp">          alert(val);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;插值表达式&quot;&gt;&lt;a href=&quot;#插值表达式&quot; class=&quot;headerlink&quot; title=&quot;插值表达式&quot;&gt;&lt;/a&gt;插值表达式&lt;/h2&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="vue" scheme="https://blog.aigisss.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>重构2——改善既有代码的设计</title>
    <link href="https://blog.aigisss.com/posts/b189f81a.html"/>
    <id>https://blog.aigisss.com/posts/b189f81a.html</id>
    <published>2019-09-14T15:05:54.000Z</published>
    <updated>2019-09-18T15:20:01.984Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><p><img src="/posts/b189f81a/005Ouxuxgy1g1omsp9johj33281j4u0x.jpg" alt></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note info">都能写出计算机可以理解代码，唯有写出人类容易理解的代码的，才是优秀的程序员。<p>好代码的标准就是人们能否轻而易举地修改它</p></div><h1 id="重构的原则"><a href="#重构的原则" class="headerlink" title="重构的原则"></a>重构的原则</h1><h2 id="何谓重构"><a href="#何谓重构" class="headerlink" title="何谓重构"></a>何谓重构</h2><p>重构这个词既可以是名词也可以是动词，名词形式的定义的是：</p><div class="note info">对软件内部结构的调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</div>动词形式的定义的是：<div class="note success">使用一系列的重构手法，在不改变可观察行为的前提下，调整其结构</div><h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><ul><li>重构改进软件的设计</li><li>重构时软件更容易理解</li><li>重构帮助找到bug</li><li>重构提高编程速度</li></ul><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><ul><li>预备性重构：让添加的新功能更容易</li><li>帮助理解的重构：使代码更容易理解</li><li>捡垃圾式重构</li><li>有计划的重构和见机行事的重构</li><li>长期重构</li><li>复审代码时重构</li></ul><h2 id="何时不重构"><a href="#何时不重构" class="headerlink" title="何时不重构"></a>何时不重构</h2><ul><li>重写比重构还容易</li></ul><p>只有需要理解其工作原理时，对其重构才有价值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/b189f81a/005Ouxuxgy1g1omsp9johj33281j4u0x.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="摘抄" scheme="https://blog.aigisss.com/tags/%E6%91%98%E6%8A%84/"/>
    
      <category term="总结" scheme="https://blog.aigisss.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中python代码输出中文乱码解决方法</title>
    <link href="https://blog.aigisss.com/posts/87ed0839.html"/>
    <id>https://blog.aigisss.com/posts/87ed0839.html</id>
    <published>2019-09-12T02:10:35.000Z</published>
    <updated>2019-09-13T13:15:19.446Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法："><a href="#在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：" class="headerlink" title="在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法："></a>在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：</h2><p><img src="/posts/87ed0839/1568254353802.png" alt="1568254353802"></p><a id="more"></a><h3 id="先检查右下角编码集设置是否正确"><a href="#先检查右下角编码集设置是否正确" class="headerlink" title="先检查右下角编码集设置是否正确"></a>先检查右下角编码集设置是否正确</h3><p><img src="/posts/87ed0839/1568254487426.png" alt="1568254487426"></p><h3 id="修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索-code-runner-executorMap-选项，提示需要在-setting-json-中修改"><a href="#修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索-code-runner-executorMap-选项，提示需要在-setting-json-中修改" class="headerlink" title="修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改"></a>修改完后运行仍不行，可以在”文件”－”首选项”－”用户设置”中搜索 code-runner.executorMap 选项，提示需要在 setting.json 中修改</h3><p><img src="/posts/87ed0839/1568254594172.png" alt="1568254594172"></p><p>在 json 中添加下列属性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"code-runner.executorMap": &#123;</span><br><span class="line">"python": "set PYTHONIOENCODING=utf8 &amp;&amp; python -u"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default">https://mp.weixin.qq.com/s/QIJ-QHkxZUyKyQAPG49vPg</div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：&quot;&gt;&lt;a href=&quot;#在-vscode-中编写-python-代码，输出中文时，控制台输出为乱码解决方法：&quot; class=&quot;headerlink&quot; title=&quot;在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：&quot;&gt;&lt;/a&gt;在 vscode 中编写 python 代码，输出中文时，控制台输出为乱码解决方法：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/87ed0839/1568254353802.png&quot; alt=&quot;1568254353802&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://blog.aigisss.com/tags/python/"/>
    
      <category term="vscode" scheme="https://blog.aigisss.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo下next主题时出错</title>
    <link href="https://blog.aigisss.com/posts/326cb881.html"/>
    <id>https://blog.aigisss.com/posts/326cb881.html</id>
    <published>2019-09-09T01:58:21.000Z</published>
    <updated>2019-09-13T13:16:29.267Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><div class="note danger"><h4 id="next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin-时会不起作用"><a href="#next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin-时会不起作用" class="headerlink" title="next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用"></a>next6.3+自带代码复制，使用代码高亮插件时 hexo-prism-plugin 时会不起作用</h4><p>在主题下的<code>_config.yml</code>文件中设置：</p><h4 id="使用了-hexo-asset-image-和-hexo-abbrlink-后，图片显示不出来。"><a href="#使用了-hexo-asset-image-和-hexo-abbrlink-后，图片显示不出来。" class="headerlink" title="使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。"></a>使用了 hexo-asset-image 和 hexo-abbrlink 后，图片显示不出来。</h4><p>issue：<a href="https://github.com/rozbo/hexo-abbrlink/issues/19" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink/issues/19</a></p><p>解决方法：<a href="https://github.com/foreveryang321/hexo-asset-image" target="_blank" rel="noopener">https://github.com/foreveryang321/hexo-asset-image</a></p></div><p><img src="/posts/326cb881/QQ%E5%9B%BE%E7%89%8720190911114226.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;h4 id=&quot;next6-3-自带代码复制，使用代码高亮插件时-hexo-prism-plugin
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>markdown的使用总结</title>
    <link href="https://blog.aigisss.com/posts/3c0dd009.html"/>
    <id>https://blog.aigisss.com/posts/3c0dd009.html</id>
    <published>2019-09-08T09:50:40.000Z</published>
    <updated>2019-09-28T12:04:49.813Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gitGraph:</span><br><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    "nodeSpacing": 150,</span></span><br><span class="line"><span class="code">    "nodeRadius": 10</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line">commit</span><br><span class="line">branch newbranch</span><br><span class="line">checkout newbranch</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">checkout master</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">merge newbranch</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gitGraph:</span><br><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line">    &quot;nodeSpacing&quot;: 150,</span><br><span class="line">    &quot;nodeRadius&quot;: 10</span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line">commit</span><br><span class="line">branch newbranch</span><br><span class="line">checkout newbranch</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">checkout master</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">merge newbranch</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划中               :         des3, after des2, 5d</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划中               :         des3, after des2, 5d</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Threejs学习与总结10</title>
    <link href="https://blog.aigisss.com/posts/456b67a9.html"/>
    <id>https://blog.aigisss.com/posts/456b67a9.html</id>
    <published>2019-09-08T02:19:55.000Z</published>
    <updated>2019-09-29T15:34:40.921Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h2 id="three-js-master-目录结构"><a href="#three-js-master-目录结构" class="headerlink" title="three.js-master 目录结构"></a>three.js-master 目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">three.js-master</span><br><span class="line">└───build——src目录下各个代码模块打包后的结果</span><br><span class="line">    │───three.js——开发的时候.html文件中要引入的threejs引擎库，和引入jquery一样，可以辅助浏览器调试</span><br><span class="line">    │───three.min.js——three.js压缩后的结构文件体积更小，可以部署项目的时候在.html中引入。</span><br><span class="line">    │</span><br><span class="line">└───docs——Three.js API文档文件</span><br><span class="line">    │───index.html——打开该文件可以实现离线查看threejs API文档</span><br><span class="line">    │</span><br><span class="line">└───editor——Three.js的可视化编辑器，可以编辑3D场景</span><br><span class="line">    │───index.html——打开应用程序</span><br><span class="line">    │</span><br><span class="line">└───docs——Three.js API文档文件</span><br><span class="line">    │───index.html——打开该文件可以实现离线查看threejs API文档</span><br><span class="line">    │</span><br><span class="line">└───examples——里面有大量的threejs案例，平时可以通过代码编辑全局查找某个API、方法或属性来定位到一个案例</span><br><span class="line">    │</span><br><span class="line">└───src——Three.js引擎的各个模块，可以通过阅读源码深度理解threejs引擎</span><br><span class="line">    │───index.html——打开该文件可以实现离线查看threejs API文档</span><br><span class="line">    │</span><br><span class="line">└───utils——一些辅助工具</span><br><span class="line">    │───\utils\exporters\blender——blender导出threejs文件的插件</span><br></pre></td></tr></table></figure><p><img src="/posts/456b67a9/1569639814386.png" alt="1569639814386"></p><p>这就好比拍照，站在一个场景中，用相机拍照，咔嚓一下就是渲染操作，指定场景、相机作为参数。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="网格模型-Mesh"><a href="#网格模型-Mesh" class="headerlink" title="网格模型 Mesh"></a>网格模型 Mesh</h3><h4 id="几何体对象-Geometry"><a href="#几何体对象-Geometry" class="headerlink" title="几何体对象 Geometry"></a>几何体对象 Geometry</h4><h4 id="材质对象-Material"><a href="#材质对象-Material" class="headerlink" title="材质对象 Material"></a>材质对象 Material</h4><h3 id="光照-Light"><a href="#光照-Light" class="headerlink" title="光照 Light"></a>光照 Light</h3><h4 id="平行光、环境光、点光源"><a href="#平行光、环境光、点光源" class="headerlink" title="平行光、环境光、点光源"></a>平行光、环境光、点光源</h4><h2 id="相机-Camera"><a href="#相机-Camera" class="headerlink" title="相机 Camera"></a>相机 Camera</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置相机指向(指向的场景对象)</span></span><br><span class="line">camera.lookAt(scene.position);</span><br></pre></td></tr></table></figure><h2 id="渲染器-Renderer"><a href="#渲染器-Renderer" class="headerlink" title="渲染器 Renderer"></a>渲染器 Renderer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>渲染器 render 方法</p><p><img src="/posts/456b67a9/1569641783057.png" alt="1569641783057"></p><p>three 动画程序一般选择 requestAnimationFrame 方法，而不是 setInterval()方法设置固定的刷新频率，也就是周期性执行时间。</p><p><img src="/posts/456b67a9/1569645786552.png" alt="1569645786552"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[设置材质效果]  --&gt; C(材质类型)</span><br><span class="line">C --&gt; D(MeshBasicMaterial)</span><br><span class="line">D --&gt; D1(基础网格材质)</span><br><span class="line">D --&gt; D2(不受光照影响的材质)</span><br><span class="line">C --&gt; E(MeshLambertMaterial)</span><br><span class="line">E --&gt; E1(Lambert网格材质)</span><br><span class="line">E --&gt; E2(与光照有反应,漫反射)</span><br><span class="line">C --&gt; F(MeshPhongMaterial)</span><br><span class="line">F --&gt; F1(与光照有反应)</span><br><span class="line">F --&gt; F2(高光材质)</span><br></pre></td></tr></table></figure><p><img src="/posts/456b67a9/1569665791516.png" alt="1569665791516"><br>going on</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;three-js-master-目录结构&quot;&gt;&lt;a href=&quot;#three-js-master-目录结构&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用Hexo + NexT 快速搭建博客</title>
    <link href="https://blog.aigisss.com/posts/eba3f111.html"/>
    <id>https://blog.aigisss.com/posts/eba3f111.html</id>
    <published>2019-09-07T07:34:54.000Z</published>
    <updated>2019-09-15T15:26:12.570Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><img src="/posts/eba3f111/pic1.png"><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h2><div class="note success"><p>如果你已经安装了 node.js，请忽略。</p></div><p>访问<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js 官网</a>，根据指引进行安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><div class="note success"><p>如果你已经安装了 Git，请忽略。</p></div><p>访问<a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a>，根据指引进行安装。</p><div class="note warning"><p>由于众所周知的原因，Windows 从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></div><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ul><li><p><strong>国内的朋友</strong>，因为众所周知的原因，从 npm 直接安装 hexo 会非常慢，所以你需要用到<a href="https://npm.taobao.org/" target="_blank" rel="noopener"><strong>镜像源</strong></a>，参考上面的步骤，使用 cnpm 命令行工具代替默认的 npm: 在 windows 控制台（cmd）里输入并执行<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>，然后安装 hexo: <code>cnpm install -g hexo-cli</code></p></li><li><p><strong>国外的朋友</strong>，请直接打开 windows 控制台，输入<code>npm install -g hexo-cli</code>并执行。</p></li></ul><hr><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="建立本地博客文件夹"><a href="#建立本地博客文件夹" class="headerlink" title="建立本地博客文件夹"></a>建立本地博客文件夹</h2><p>在命令行执行如下命令，其中<code>&lt;folder&gt;</code>为文件夹路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br></pre></td></tr></table></figure><div class="note warning"><p><strong>所有有关<code>hexo</code>的命令</strong> 均要在<code>&lt;folder&gt;</code>路径下执行。</p></div><p>建立好后文件夹目录如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── node_modules</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><p><code>_config.yml</code>：站点的配置文件，可以在此配置大部分的参数。</p></li><li><p><code>package.json</code>：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line"><span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"hexo"</span>: &#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"3.9.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"dependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"3.9.0"</span></span><br><span class="line"><span class="string">"hexo-generator-archive"</span>: <span class="string">"^0.1.5"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line"><span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.3"</span>,</span><br><span class="line"><span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^1.0.1"</span>,</span><br><span class="line"><span class="attr">"hexo-server"</span>: <span class="string">"^0.3.3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>scaffolds：模板文件夹，是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p></li><li><p>source：资源文件夹，存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></li><li><p>themes：主题文件夹。Hexo 会根据主题来生成静态页面。</p></li><li><p>node_modules：node.js 模块，一些 <strong>插件</strong> 和 <strong>依赖</strong> 会被安装到这里。</p></li></ul><div class="note info"><p>更加详细的解释请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a></p></div><h3 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h3><p>进入本地博客文件夹并将 NexT 主题<code>clone</code>至<code>themes</code>文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>你会看到，在<code>next</code>下也有一个<code>_config.yml</code>的文件，这是 <strong>NexT 主题的配置文件</strong>，为了区别它和 <strong>博客配置文件</strong>，下面会用带路径的文件名来描述它们：</p><ul><li><code>&lt;folder&gt;/_config.yml</code>：站点配置文件</li><li><code>next/_config.yml</code>：主题配置文件</li></ul><h2 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a>启用 NexT 主题</h2><p>在<code>&lt;folder&gt;/_config.yml</code>里<code>theme:</code>选项填<code>next</code>，=&gt;<code>theme: next</code>，注意冒号后空一格。</p><p>到这里，建站的任务就完成了。你现在可以打开控制台，输入并执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>完成没有报错之后执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>hexo g</code>：新建<code>public</code>文件夹，并在其中生成网站静态文件（html，css，等文件）</li><li><code>hexo s</code>：启动 hexo 服务器，默认情况下，访问网址为：<code>http://localhost:4000/</code></li></ul><div class="note info"><p>更多有关 hexo 的命令，请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a>的<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">命令</a>部分。</p></div><p>你最后会看到控制台有如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在浏览器地址栏输入<code>http://localhost:4000/</code>并访问，你应该会看到如下页面：</p><img src="/posts/eba3f111/pic2.png"><div class="note success"><i class="fa fa-thumbs-o-up" aria-hidden="true"></i>&nbsp;**恭喜你！你已经完成了博客搭建的主要工作！接下来就是细节的配置了。请耐心阅读以下内容。**</div><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="网站脚注"><a href="#网站脚注" class="headerlink" title="网站脚注"></a>网站脚注</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment">#建站时间</span></span><br><span class="line"><span class="attr">  since:</span> <span class="number">2018</span></span><br><span class="line">  <span class="comment">#作者头像并且是动画效果</span></span><br><span class="line"><span class="attr">  icon:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">    animated:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">"##66CDAA"</span></span><br><span class="line">  <span class="comment">#显示版权作者</span></span><br><span class="line"><span class="attr">  copyright:</span> <span class="string">aigisss</span> <span class="string">爱即是诗</span></span><br><span class="line">  <span class="comment">#不显示Hexo</span></span><br><span class="line"><span class="attr">  powered:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#不显示主题和版本</span></span><br><span class="line"><span class="attr">  theme:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#显示备案号</span></span><br><span class="line"><span class="attr">  beian:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    icp:</span> <span class="string">赣ICP备18013338-1号</span></span><br></pre></td></tr></table></figure><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># 自定义边框半径，默认是1</span></span><br><span class="line">  <span class="comment"># 值越大弧度越大</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">6</span></span><br><span class="line">  <span class="comment"># 右上角显示复制按钮</span></span><br><span class="line"><span class="attr">  copy_button:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 显示复制结果</span></span><br><span class="line"><span class="attr">    show_result:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  postbottom:</span></span><br><span class="line">    <span class="comment">#文章底部</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">bottomCenter</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">      <span class="comment">#左下角悬浮按钮</span></span><br><span class="line"><span class="attr">  float:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">middleRight</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br></pre></td></tr></table></figure><h2 id="访问次数"><a href="#访问次数" class="headerlink" title="访问次数"></a>访问次数</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># busuanzi统计</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 总访客数</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="comment"># 总浏览量</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="comment"># 文章浏览量</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><h2 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">"#37c6c0"</span></span><br><span class="line"><span class="attr">  height:</span> <span class="number">2</span><span class="string">px</span></span><br></pre></td></tr></table></figure><h2 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="comment"># 启用</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 异步加载</span></span><br><span class="line"><span class="attr">  async:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line">    <span class="comment"># 文章摘要动画</span></span><br><span class="line"><span class="attr">    post_block:</span> <span class="string">bounceIn</span></span><br><span class="line">    <span class="comment"># 加载各种页面动画（分类，关于，标签等等）</span></span><br><span class="line"><span class="attr">    post_header:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment"># 文章详情动画</span></span><br><span class="line"><span class="attr">    post_body:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="attr">    coll_header:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="comment"># 侧边栏（人物头像的那部分）</span></span><br><span class="line"><span class="attr">    sidebar:</span> <span class="string">fadeIn</span></span><br></pre></td></tr></table></figure><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p><code>NexT</code>自带提供了两个搜索</p><ul><li><code>algolia_search</code></li><li><code>local_search</code></li></ul><p>其实这个<code>local_search</code>已经很好用了，配置<code>algolia_search</code>挺麻烦的，而且搜索功能也用的不多</p><p>毕竟有万能的<code>Ctrl + F</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line"><span class="attr">  unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="添加-RSS-订阅"><a href="#添加-RSS-订阅" class="headerlink" title="添加 RSS 订阅"></a>添加 RSS 订阅</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span> <span class="bullet">--save</span></span><br><span class="line"></span><br><span class="line"><span class="string">复制代码</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">   <span class="string">hexo-generate-feed</span></span><br><span class="line"><span class="attr">feed:</span> <span class="comment"># RSS订阅插件</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">0</span> <span class="comment">#0就是代表所有</span></span><br></pre></td></tr></table></figure><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default(true) will load mathjax/katex script on demand</span></span><br><span class="line">  <span class="comment"># That is it only render those page who has 'mathjax: true' in Front Matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="comment">#engine: katex</span></span><br></pre></td></tr></table></figure><p>还需要在文章的 Front-matter 里打开 mathjax 开关，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">使用hexo下next主题搭建博客的记录</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">日常</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="number">326</span><span class="string">cb881</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-09</span><span class="bullet">-09</span> <span class="number">09</span><span class="string">:58:21</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>网上一大堆说会出现语义冲突—–类 Latex 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括<code>*</code>, <code>{</code>, <code>}</code>, <code>\\</code>等。但是！！</p></blockquote><div class="note danger"><p>在我试验下没有出现此类问题，只要在主题中打开，md 中申明 mathjax: true 就好了，可能在我使用的<code>next6.7</code>中解决了冲突。比如以下的公式能出来！</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span><br></pre></td></tr></table></figure><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">P = \frac</span><br><span class="line">&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;</span><br><span class="line">&#123;\displaystyle \left[</span><br><span class="line">\sum_&#123;i=1&#125;^n (x_i-x)^2</span><br><span class="line">\sum_&#123;i=1&#125;^n (y_i-y)^2</span><br><span class="line">\right]^&#123;1/2&#125; &#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>P = \frac<br>{\sum_{i=1}^n (x_i- x)(y_i- y)}<br>{\displaystyle \left[<br>\sum_{i=1}^n (x_i-x)^2<br>\sum_{i=1}^n (y_i-y)^2<br>\right]^{1/2} }<br>$$</p><h2 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h2><p>以新建「相册」菜单为例：在博客目录下的 source 文件夹下新建名为 photo 文件夹，然后在 photo 文件夹下新建一个 index.md 文件，然后在该文件填写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">相册</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-04</span><span class="bullet">-16</span> <span class="number">22</span><span class="string">:14:07</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"photo"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>然后打开主题配置文件 <code>_config.yml</code>，在 menu 中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment">#添加「相册」菜单</span></span><br><span class="line">  <span class="string">相册:</span> <span class="string">/photo</span> <span class="string">||</span> <span class="string">camera</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的「相册」是博客中显示的菜单名称，紧跟的 photo 要和前面 index.md 文件的 type 值一致，|| 后面的菜单的图标，图标名称来自于 FontAwesome icon，若没有配置图标，默认会使用问号图标</p></blockquote><h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ol><li><strong><em><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db" target="_blank" rel="noopener">Hexo+NexT 打造一个炫酷博客</a></em></strong></li><li><strong><em><a href="https://juejin.im/post/5a71ab9f518825735300ee6c" target="_blank" rel="noopener">篇Ⅱ：NexT主题的配置和优化指南</a></em></strong></li></ol></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;img src=&quot;/posts/eba3f111/pic1.png&quot;&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>git的操作记录</title>
    <link href="https://blog.aigisss.com/posts/d5d49586.html"/>
    <id>https://blog.aigisss.com/posts/d5d49586.html</id>
    <published>2019-09-07T00:41:08.000Z</published>
    <updated>2019-09-18T15:22:28.368Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><h3 id="与服务器上的代码产生冲突"><a href="#与服务器上的代码产生冲突" class="headerlink" title="与服务器上的代码产生冲突"></a>与服务器上的代码产生冲突</h3><p>如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:</p><div class="note danger"><p>error: Your local changes to the following files would be overwritten by merge:<br>protected/config/main.php<br>Please, commit your changes or stash them before you can merge.</p></div><p>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>git diff -w +文件名</code>来确认代码自动合并的情况.</p><p>反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>其中 <code>git reset</code> 是针对版本,如果想针对文件回退本地修改,使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD file/to/restore</span><br></pre></td></tr></table></figure><h3 id="辛辛苦苦加班一星期敲的代码没了"><a href="#辛辛苦苦加班一星期敲的代码没了" class="headerlink" title="辛辛苦苦加班一星期敲的代码没了"></a>辛辛苦苦加班一星期敲的代码没了</h3><p>过程是这样的，在终端输入 git log，列出所有的 commit 信息，如下图：</p><p><img src="/posts/d5d49586/1568253175476.png" alt="1568253175476"></p><p>commit 的信息很简单，就是做了 6 个功能，每个功能对应一个 commit 的提交，分别是 feature-1 到 feature-6。</p><p>接下来执行了强制回滚，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 2216d4e</span><br></pre></td></tr></table></figure><p>回滚到了 feature-1 上，并且回滚的时候加了–hard，导致之前 feature-2 到 feature-6 的所有代码全部弄丢了，现在 git log 的显示如下：</p><p><img src="/posts/d5d49586/1568253317626.png" alt="1568253317626"></p><p>现在 feature-2 到 feature-6 的代码没了。。。。。</p><p>然鹅还没完，在这个基础上新添加了一个 commit 提交，信息叫 feature-7，如下图：</p><p><img src="/posts/d5d49586/1568253390009.png" alt="1568253390009"></p><p>现在 feature-2 到 feature-6 全没了，还多了一个 feature-7</p><div class="note info"><p>请问 如何把丢失的代码 feature-2 到 feature-6 全部恢复回来，并且 feature-7 的代码也要保留</p></div><p><strong>用git reflog和git cherry-pick就能解决</strong></p><p>在终端里输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>然后就会展示出所有你之前git操作，你以前所有的操作都被git记录了下来，如下图：</p><p><img src="/posts/d5d49586/1568296363901.png" alt="1568296363901"></p><p>这时候要记好两个值：4c97ff3和cd52afc，他们分别是feature-7和feature-6的hash码。然后执行回滚，回到feature-6上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard cd52afc</span><br></pre></td></tr></table></figure><p>现在我们回到了feature-6上，如下图：</p><p><img src="/posts/d5d49586/1568296459828.png" alt="1568296459828"></p><p>我们回到了feature-6上，但是feature-7没了，如何加上来呢？</p><p>这个时候就用上了git cherry-pick，刚刚我们知道了feature-7的hash码为4c97ff3，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 4c97ff3</span><br></pre></td></tr></table></figure><p>回车之后，你的feature-7的代码就回来了。</p><p>期间可能会有一些冲突，按照提示解决就好。最后的结果如下图：</p><p><img src="/posts/d5d49586/169d3f52baa26b7e.png" alt></p><p>feature-1 到 feature-7的代码就合并到了一起，以前的代码也都回来了。</p><p><a href="https://juejin.im/post/5cbd82165188250a926108bd?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文出自前端时光机</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;与服务器上的代码产生冲突&quot;&gt;&lt;a href=&quot;#与服务器上的代码产生冲突&quot; class=&quot;headerlink&quot; title=&quot;与服务器上的代码产生冲突&quot;&gt;&lt;/a&gt;与服务器上的代码产生冲突&lt;/h3&gt;&lt;p&gt;如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:&lt;/p&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;error: Your local changes to the following files would be overwritten by merge:&lt;br&gt;protected/config/main.php&lt;br&gt;Please, commit your changes or stash them before you can merge.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="更新中" scheme="https://blog.aigisss.com/categories/%E7%BC%96%E7%A8%8B/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
      <category term="git" scheme="https://blog.aigisss.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用coding-pages时出现静态文件丢失</title>
    <link href="https://blog.aigisss.com/posts/372cd070.html"/>
    <id>https://blog.aigisss.com/posts/372cd070.html</id>
    <published>2019-09-05T01:32:57.000Z</published>
    <updated>2019-09-12T14:22:59.547Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --><p><img src="/posts/372cd070/1567646753123.png" alt></p><a id="more"></a><p>出现这种情况，发现静态资源都加载不到，后来网上搜索了半天，才发现原来你要打算用 coding 的 pages 服务部署你的博客的话，你创建项目的名字必须和用户名保持一致，不能自己随便自定义。我重新创建了一个和用户名一致的项目，部署到他的 pages 服务，访问正常</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 08 2019 23:34:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/posts/372cd070/1567646753123.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.aigisss.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.aigisss.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.aigisss.com/tags/NexT/"/>
    
  </entry>
  
</feed>
